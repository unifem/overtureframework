#include "Maxwell.h"
#include "DispersiveMaterialParameters.h"
#include "CompositeGridOperators.h"
#include "display.h"
#include "UnstructuredMapping.h"
#include "OGPolyFunction.h"
#include "OGTrigFunction.h"
#include "OGPulseFunction.h"
#include "interpPoints.h"
#include "ShowFileReader.h"
#include "ParallelUtility.h"
#include "gridFunctionNorms.h"

#define exmax EXTERN_C_NAME(exmax)
extern "C"
{

 void exmax(double&Ez,double&Bx,double&By,const int &nsources,const double&xs,const double&ys,
            const double&tau,const double&var,const double&amp, const double&a,
            const double&x,const double&y,const double&time);

}


#define FOR_3D(i1,i2,i3,I1,I2,I3) \
int I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
int I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

#define FOR_3(i1,i2,i3,I1,I2,I3) \
I1Base =I1.getBase(),   I2Base =I2.getBase(),  I3Base =I3.getBase();  \
I1Bound=I1.getBound(),  I2Bound=I2.getBound(), I3Bound=I3.getBound(); \
for(i3=I3Base; i3<=I3Bound; i3++) \
for(i2=I2Base; i2<=I2Bound; i2++) \
for(i1=I1Base; i1<=I1Bound; i1++)

// Define macros for forcing functions:
#Include "forcing.h"
#Include "annulusEigenFunction.h"
#Include "boxEigenFunction.h"

// Macros for the plane material interface:
#Include "planeMaterialInterface.h"
 definePlaneMaterialInterfaceMacros(C)

// Macros for dispersive waves
#Include "dispersionMacros.h"

//! local function to compute errors for the staggered grid DSI schemes
void
computeDSIErrors( Maxwell &mx, MappedGrid &mg, realArray &uh, realArray &uhp, realArray &ue, realArray &uep,
		  realArray &errh, realArray &erre, 
		  RealArray &solutionNorm, RealArray &maximumError )
{
  bool skipGhosts = true;
  ArraySimpleFixed<int,6,1,1,1> ml;
  ml = -1;

  real l2h_err,l2e_err;
  real nE, nH;
  l2h_err = l2e_err = 0;
  nE=nH=0;

  real maxDivE = 0, maxDivH = 0;
  if ( mg.getGridType()==MappedGrid::unstructuredGrid )
  {
      
    UnstructuredMapping & umap = (UnstructuredMapping &) mg.mapping().getMapping();
    int rDim = umap.getRangeDimension();

//       const realArray &verts = umap.getNodes();
//       const intArray  &edges = umap.getEntities(UnstructuredMapping::Edge);

    UnstructuredMappingIterator iter,iter_end;
    iter_end = umap.end( UnstructuredMapping::Edge, skipGhosts ); // true means skip ghosts
    for ( iter = umap.begin( UnstructuredMapping::Edge, skipGhosts );
	  iter!=iter_end;
	  iter++ )
    {
      assert(!umap.isGhost(UnstructuredMapping::Edge, *iter));
      int e = *iter;
      //	  if ( !umap.hasTag(UnstructuredMapping::Edge, e, "__bcnum ") )
    {
      for ( int c=0; c<ue.getLength(3); c++ )
      {
	solutionNorm(c) = max(solutionNorm(c), fabs(ue(e,0,0,c)));
	if ( maximumError(c)<fabs(erre(e,0,0,c)) )
	  ml[c] = e;
	maximumError(c) = max(maximumError(c), fabs(erre(e,0,0,c)));
	l2e_err += erre(e,0,0,c)*erre(e,0,0,c);
      }
      nE++;
    }
    //	  cout<<.5*(verts(edges(*iter,0),0)+verts(edges(*iter,1),0))<<"  "<<.5*(verts(edges(*iter,0),1)+verts(edges(*iter,1),1))<<"  "<<erre(*iter,0,0,0)<<endl;
    }
      
    l2e_err /= real(nE);

    int off = ue.getLength(3);
    iter_end = umap.end( UnstructuredMapping::Face, skipGhosts ); // true means skip ghosts
    for ( iter = umap.begin( UnstructuredMapping::Face, skipGhosts );
	  iter!=iter_end;
	  iter++ )
    {
      int f = *iter;
      assert(!umap.isGhost(UnstructuredMapping::Face, *iter));
      //	  if ( !umap.hasTag(UnstructuredMapping::Face, f, "__bcnum ") )
    {
      for ( int c=0; c<uh.getLength(3); c++ )
      {
	solutionNorm(off+c) = max(solutionNorm(off+c), fabs(uh(f,0,0,c)));
	if ( maximumError(off+c)<fabs(errh(f,0,0,c)) )
	  ml[off+c] = f;
	maximumError(off+c) = max(maximumError(off+c), fabs(errh(f,0,0,c)));
	l2h_err += errh(f,0,0,c)*errh(f,0,0,c);
      }
      nH++;
    }
    }
    l2h_err /= real(nH);
    maximumError(0) = sqrt(l2e_err);
    maximumError(off) = sqrt(l2h_err);
      
    iter_end = umap.end(UnstructuredMapping::Vertex);
    for ( iter=umap.begin(UnstructuredMapping::Vertex); iter!=iter_end; iter++ )
    {
      if ( !(iter.isGhost() || iter.isBC()) )
      {
	real divE = 0;
	UnstructuredMappingAdjacencyIterator aiter,aiter_end;
	aiter_end = umap.adjacency_end(iter, UnstructuredMapping::Edge);
	for ( aiter=umap.adjacency_begin(iter, UnstructuredMapping::Edge); aiter!=aiter_end; aiter++ )
	{
	  divE += aiter.orientation()*uep(*aiter,0,0);
	  if ( aiter.isBC() || aiter.isGhost() )
	  {
	    divE = 0;
	    break;
	  }
	}
	maxDivE = max(maxDivE,fabs(divE));
      }
	  
    }

    if (rDim==3)
    {
      iter_end = umap.end(UnstructuredMapping::Region);
      for ( iter=umap.begin(UnstructuredMapping::Region); iter!=iter_end; iter++ )
      {
	if ( !(iter.isGhost() || iter.isBC()) )
	{
	  real divH = 0;
	  UnstructuredMappingAdjacencyIterator aiter,aiter_end;
	  aiter_end = umap.adjacency_end(iter, UnstructuredMapping::Face);
	  for ( aiter=umap.adjacency_begin(iter, UnstructuredMapping::Face); aiter!=aiter_end; aiter++ )
	  {
	    divH += aiter.orientation()*uhp(*aiter,0,0);
	    if ( aiter.isBC() || aiter.isGhost() )
	    {
	      divH = 0;
	      break;
	    }
	  }
	  maxDivH = max(maxDivH,fabs(divH));
	}
	      
      }
    }

  }

  //  cout<<"max error locs "<<ml<<endl;
  //  cout<<"max Div E = "<<maxDivE<<endl;
  //  cout<<"max Div H = "<<maxDivH<<endl;
  mx.divEMax = maxDivE;
  mx.gradEMax = maxDivH; // use this spot for div H in the dsi code
  cout<<"max E error location "<<ml<<endl;
  maximumError.display("maximum error");
}

// =============================================================================================
// MACRO: Get errors for a plane wave solution
// =============================================================================================
#beginMacro getErrorsPlaneWave()     
{
  
  if( numberOfDimensions==2 )
  {
// 	      err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-exTrue(x,y,t);
// 	      err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-eyTrue(x,y,t);
// 	      err(I1,I2,I3,hz)=u(I1,I2,I3,hz)-hzTrue(x,y,t);
    if( dispersionModel == noDispersion )
    {
      erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-exTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-eyTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-hzTrue(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH);
    }
    else
    {
      // --- dispersive plane wave ---
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      // Dispersive material parameters
      // DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);

      // evaluate the dispersion relation,  exp(i(k*x-omega*t))
      //    omega is complex 
      const real kk = twoPi*sqrt( kx*kx+ky*ky+kz*kz);

      // *new way*
      assert( numberOfPolarizationVectors<10 );

      real sr,si,psir[10],psii[10];
      dmp.evaluateDispersionRelation( c,kk, sr, si, psir,psii ); 
      real expt=exp(sr*t);
      real ct = cos(si*t)*expt, st=sin(si*t)*expt;
      //  Hz = (i/s) * (-1) * (kx*Ey - ky*Ex )/mu
      real hFactor = - twoPi*( kx*pwc[1] - ky*pwc[0] )/mu;
      real sNormSq = sr*sr+si*si;
      //  hr + i*hi = (i/s)*hfactor
      real hr = hFactor*si/sNormSq;
      real hi = hFactor*sr/sNormSq;

      RealArray xi(Ie1,Ie2,Ie3), cx, sx, eHat(Ie1,Ie2,Ie3);
      xi = twoPi*(kx*xe(Ie1,Ie2,Ie3)+ky*ye(Ie1,Ie2,Ie3));
      cx=cos(xi); sx=sin(xi);
      eHat = cx*ct - sx*st;

      erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-pwc[0]*eHat;
      erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-pwc[1]*eHat;
      errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-( (hr*ct-hi*st)*cx - (hr*st+hi*ct)*sx);
      // -- dispersion model components --

      for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
      {
        const int pc= iv*numberOfDimensions;
        eHat =(psir[iv]*ct-psii[iv]*st)*cx - (psir[iv]*st+psii[iv]*ct)*sx; // Phat 

        errPolarization(Ie1,Ie2,Ie3,pc  ) = pLocal(Ie1,Ie2,Ie3,pc  ) - pwc[0]*eHat;
        errPolarization(Ie1,Ie2,Ie3,pc+1) = pLocal(Ie1,Ie2,Ie3,pc+1) - pwc[1]*eHat;
      }

      // *old* 
      // if( pxc>=0 )
      // {
                      
      //   errLocal(Ie1,Ie2,Ie3,pxc) = uLocal(Ie1,Ie2,Ie3,pxc) - pwc[0]*eHat;
      //   errLocal(Ie1,Ie2,Ie3,pyc) = uLocal(Ie1,Ie2,Ie3,pyc) - pwc[1]*eHat;
      // }
          
      // // real omegaDpwRe, omegaDpwIm;
      // // dmp.computeDispersivePlaneWaveParameters( c,eps,mu,kk, omegaDpwRe, omegaDpwIm );
      // real reS, imS, omegaDpwRe, omegaDpwIm;
      // dmp.computeDispersionRelation( c,eps,mu,kk, reS, imS ); // s = reS + i*imS
      // omegaDpwRe=imS; omegaDpwIm=reS;

      // printF("++++ getErrors: dispersion relation: omegar=%g, omegai=%g\n",omegaDpwRe, omegaDpwIm );

      // OV_ABORT("Finish me -- add eval of Px and Py");

      // const real dpwExp =exp(omegaDpwIm*tE);
      // erre(Ie1,Ie2,Ie3,ex)  = ue(Ie1,Ie2,Ie3,ex)-exDpw(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE,dpwExp);
      // erre(Ie1,Ie2,Ie3,ey)  = ue(Ie1,Ie2,Ie3,ey)-eyDpw(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE,dpwExp);
      // errh(Ih1,Ih2,Ih3,hz)  = uh(Ih1,Ih2,Ih3,hz)-hzDpw(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH,dpwExp);

    }
	
    if( method==sosup )
    {
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      // printF(" errLocal = [%i,%i]\n",errLocal.getBase(3),errLocal.getBound(3));

      errLocal(Ie1,Ie2,Ie3,ext)  = uLocal(Ie1,Ie2,Ie3,ext)-extTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      errLocal(Ie1,Ie2,Ie3,eyt)  = uLocal(Ie1,Ie2,Ie3,eyt)-eytTrue(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),tE);
      errLocal(Ih1,Ih2,Ih3,hzt)  = uLocal(Ih1,Ih2,Ih3,hzt)-hztTrue(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),tH);

    }

  }
  else // 3D
  {
// 	      if( solveForElectricField )
// 	      {
// 		err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-exTrue3d(x,y,z,t);
// 		err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-eyTrue3d(x,y,z,t);
// 		err(I1,I2,I3,ez)=u(I1,I2,I3,ez)-ezTrue3d(x,y,z,t);
// 	      }
//               if( solveForMagneticField )
// 	      {
// 		err(I1,I2,I3,hx)=u(I1,I2,I3,hx)-hxTrue3d(x,y,z,t);
// 		err(I1,I2,I3,hy)=u(I1,I2,I3,hy)-hyTrue3d(x,y,z,t);
// 		err(I1,I2,I3,hz)=u(I1,I2,I3,hz)-hzTrue3d(x,y,z,t);
// 	      }
    if( solveForElectricField )
    {
      erre(Ie1,Ie2,Ie3,ex)=ue(Ie1,Ie2,Ie3,ex)-exTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
      erre(Ie1,Ie2,Ie3,ey)=ue(Ie1,Ie2,Ie3,ey)-eyTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
      erre(Ie1,Ie2,Ie3,ez)=ue(Ie1,Ie2,Ie3,ez)-ezTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);

      if( method==sosup )
      {
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        // printF(" errLocal = [%i,%i]\n",errLocal.getBase(3),errLocal.getBound(3));

        errLocal(Ie1,Ie2,Ie3,ext)  = uLocal(Ie1,Ie2,Ie3,ext)-extTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
        errLocal(Ie1,Ie2,Ie3,eyt)  = uLocal(Ie1,Ie2,Ie3,eyt)-eytTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);
        errLocal(Ie1,Ie2,Ie3,ezt)  = uLocal(Ie1,Ie2,Ie3,ezt)-eztTrue3d(xe(Ie1,Ie2,Ie3),ye(Ie1,Ie2,Ie3),ze(Ie1,Ie2,Ie3),tE);

      }

    }
    if( solveForMagneticField )
    {
      errh(Ih1,Ih2,Ih3,hx)=uh(Ih1,Ih2,Ih3,hx)-hxTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
      errh(Ih1,Ih2,Ih3,hy)=uh(Ih1,Ih2,Ih3,hy)-hyTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
      errh(Ih1,Ih2,Ih3,hz)=uh(Ih1,Ih2,Ih3,hz)-hzTrue3d(xh(Ih1,Ih2,Ih3),yh(Ih1,Ih2,Ih3),zh(Ih1,Ih2,Ih3),tH);
    }
  }
}

#endMacro

// =============================================================================================
// MACRO: Get errors for Rod Sterling
// =============================================================================================
#beginMacro getErrorsTwilightZone()
{
      
  assert( tz!=NULL );
  OGFunction & e = *tz;
  realArray & center = mg.center();
  // display(center,"center"); //ok
	    
  // display(ee,"exact solution for error computation");
	    
  Index J1,J2,J3;

  int i1,i2,i3;
  if( mg.numberOfDimensions()==2 )
  {
    J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
    J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
    J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
    FOR_3D(i1,i2,i3,J1,J2,J3)
    {
      real x0 = XEP(i1,i2,i3,0);
      real y0 = XEP(i1,i2,i3,1);
      ERREX(i1,i2,i3)=UEX(i1,i2,i3)-e(x0,y0,0.,ex,tE);
      ERREY(i1,i2,i3)=UEY(i1,i2,i3)-e(x0,y0,0.,ey,tE);
    }
    if( method==sosup )
    {
      // Compute errors in the time derivative
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)- e(x0,y0,0.,ext,tE);
        errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)- e(x0,y0,0.,eyt,tE);
        errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)- e(x0,y0,0.,hzt,tH);
      }
    }
	

    J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
    J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
    J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
    FOR_3(i1,i2,i3,J1,J2,J3)
    {
      real x0 = XHP(i1,i2,i3,0);
      real y0 = XHP(i1,i2,i3,1);
      ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3)-e(x0,y0,0.,hz,tH);
    }

    if( dispersionModel != noDispersion )
    {         
      // --- error in dispersion variables ---
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);

        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  )- e(x0,y0,0.,pxc+pc,tE);
          errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1)- e(x0,y0,0.,pyc+pc,tE);
        }

      }
    }

  }
  else // 3D
  {
    if( solveForElectricField ) 
    {
      J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        real z0 = XEP(i1,i2,i3,2);
        ERREX(i1,i2,i3)=UEX(i1,i2,i3)-e(x0,y0,z0,ex,tE);
        ERREY(i1,i2,i3)=UEY(i1,i2,i3)-e(x0,y0,z0,ey,tE);
        ERREZ(i1,i2,i3)=UEZ(i1,i2,i3)-e(x0,y0,z0,ez,tE);
      }
      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          real x0 = XEP(i1,i2,i3,0);
          real y0 = XEP(i1,i2,i3,1);
          real z0 = XEP(i1,i2,i3,2);
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)- e(x0,y0,z0,ext,tE);
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)- e(x0,y0,z0,eyt,tE);
          errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt)- e(x0,y0,z0,ezt,tE);
        }
      }

    }

    if( solveForMagneticField ) 
    {
      J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
      J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
      J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XHP(i1,i2,i3,0);
        real y0 = XHP(i1,i2,i3,1);
        real z0 = XHP(i1,i2,i3,2);
        ERRHX(i1,i2,i3)=UHX(i1,i2,i3)-e(x0,y0,z0,hx,tH);
        ERRHY(i1,i2,i3)=UHY(i1,i2,i3)-e(x0,y0,z0,hy,tH);
        ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3)-e(x0,y0,z0,hz,tH);
      }
      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          real x0 = XHP(i1,i2,i3,0);
          real y0 = XHP(i1,i2,i3,1);
          real z0 = XHP(i1,i2,i3,2);
          errLocal(i1,i2,i3,hxt) = uLocal(i1,i2,i3,hxt)- e(x0,y0,z0,hxt,tH);
          errLocal(i1,i2,i3,hyt) = uLocal(i1,i2,i3,hyt)- e(x0,y0,z0,hyt,tH);
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)- e(x0,y0,z0,hzt,tH);
        }
      }
    }

    if( dispersionModel != noDispersion )
    {         
      // --- error in dispersion variables ---
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        real x0 = XEP(i1,i2,i3,0);
        real y0 = XEP(i1,i2,i3,1);
        real z0 = XEP(i1,i2,i3,2);

        for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
        {
          const int pc= iv*numberOfDimensions;
          // *fix* me for numberOfPolarizationVectors>1 
          errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - e(x0,y0,z0,pxc+pc,tE);
          errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc  ) - e(x0,y0,z0,pyc+pc,tE);
          errPolarization(i1,i2,i3,pc+2) = pLocal(i1,i2,i3,pc+1) - e(x0,y0,z0,pzc+pc,tE);
        }
      }
    } // end if dispersion 

  }

  if( debug & 4 ) 
  {
    display(erre(J1,J2,J3),sPrintF("getErrors: errE on grid %i at t=%e",grid,t),pDebugFile,"%9.2e "); 
    display(errh(J1,J2,J3),sPrintF("getErrors: errH on grid %i at t=%e",grid,t),pDebugFile,"%9.2e "); 
  }
}

#endMacro

// =============================================================================================
// MACRO: Get errors for a Guassian plane wave
// =============================================================================================
#beginMacro getErrorsGuassianPlaneWave()
{
      
  realSerialArray xei(Ie1,Ie2,Ie3),xhi(Ih1,Ih2,Ih3);
  //xi=kx*(x-x0GaussianPlaneWave)+ky*(y-y0GaussianPlaneWave) -cc*t;
  xei=kx*(xe(Ie1,Ie2,Ie3)-x0GaussianPlaneWave)+ky*(ye(Ie1,Ie2,Ie3)-y0GaussianPlaneWave) -cc*tE;
  xhi=kx*(xh(Ih1,Ih2,Ih3)-x0GaussianPlaneWave)+ky*(yh(Ih1,Ih2,Ih3)-y0GaussianPlaneWave) -cc*tH;

//             err(I1,I2,I3,hz)=hzGaussianPulse(xi);  // save Hz here temporarily

//             err(I1,I2,I3,ex)=u(I1,I2,I3,ex)-err(I1,I2,I3,hz)*(-ky/(eps*cc));
//             err(I1,I2,I3,ey)=u(I1,I2,I3,ey)-err(I1,I2,I3,hz)*( kx/(eps*cc));
// 	    err(I1,I2,I3,hz)-=u(I1,I2,I3,hz);
  realSerialArray hzei(Ie1,Ie2,Ie3);
  hzei = hzGaussianPulse(xei);
  erre(Ie1,Ie2,Ie3,ex)=ue(Ie1,Ie2,Ie3,ex)-hzei(Ie1,Ie2,Ie3)*(-ky/(eps*cc));
  erre(Ie1,Ie2,Ie3,ey)=ue(Ie1,Ie2,Ie3,ey)-hzei(Ie1,Ie2,Ie3)*( kx/(eps*cc));
  errh(Ih1,Ih2,Ih3,hz)=uh(Ih1,Ih2,Ih3,hz) - hzGaussianPulse(xhi(Ih1,Ih2,Ih3));
}
#endMacro

// =============================================================================================
// MACRO: Get errors for a square or box eigenfunction
// =============================================================================================
#beginMacro getErrorsSquareEigenFunction()
{
  real fx=Pi*initialConditionParameters[0];
  real fy=Pi*initialConditionParameters[1];
  real fz=Pi*initialConditionParameters[2];
  real x0=initialConditionParameters[3];
  real y0=initialConditionParameters[4];
  real z0=initialConditionParameters[5];
  real omega;
  real a1=0., a2=0., a3=0.;  // Divergence free if a1+a2+a3=0
  if( numberOfDimensions==2 )
  {
    a1=1., a2=-1., a3=0.;  // For 2d, divergence free if a1+a2=0
    omega=c*sqrt(fx*fx+fy*fy);
    printF("--MX-ER-- box eigenfunction: fx=%g Pi, fy=%g Pi omega=%g Pi.\n",
           fx/Pi, fy/Pi, omega/Pi);
    // x0=-.5, y0=-.5;   // for the square [-.5,.5]x[-.5,.5] 
  }
  else
  {
    a1=1., a2=-2., a3=1.;  // For 3d, divergence free if a1+a2+a3=0
    omega=c*sqrt(fx*fx+fy*fy+fz*fz);
  }
	    
  // Behaviour in time for Ex is  phiEx(t), phiExt = time-derivative
  real phiEx, phiExt, phiPx[10];
  real phiEy, phiEyt, phiPy[10];
  real phiEz, phiEzt, phiPz[10];
  real phiHz, phiHzt;
	  
  getBoxEigenfunctionCoefficients( tE, tH, omega );

  int i1,i2,i3;
  real xd,yd,zd;
  if( isRectangular )
  {

    if( numberOfDimensions==2 )
    {
      Index J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
      Index J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
      Index J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        xd=X0(i1,i2,i3)-x0;
        yd=X1(i1,i2,i3)-y0;

        ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*phiHz;
        // ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*cos(omega*tH);
      }

      J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3(i1,i2,i3,J1,J2,J3)
      {
        xd=X0(i1,i2,i3)-x0;
        yd=X1(i1,i2,i3)-y0;
        ERREX(i1,i2,i3)=UEX(i1,i2,i3) - cos(fx*xd)*sin(fy*yd)*phiEx;  // Ex.t = Hz.y
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) - sin(fx*xd)*cos(fy*yd)*phiEy;  // Ey.t = - Hz.x
        // ERREX(i1,i2,i3)=UEX(i1,i2,i3) - (-fy/omega)*cos(fx*xd)*sin(fy*yd)*sin(omega*tE);  // Ex.t = Hz.y
        // ERREY(i1,i2,i3)=UEY(i1,i2,i3) - ( fx/omega)*sin(fx*xd)*cos(fy*yd)*sin(omega*tE);  // Ey.t = - Hz.x
      }
      if( dispersionModel!=noDispersion )
      {
        // -- dispersion model components --
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=X0(i1,i2,i3)-x0;
          yd=X1(i1,i2,i3)-y0;
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - cos(fx*xd)*sin(fy*yd)*phiPx[iv];
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - sin(fx*xd)*cos(fy*yd)*phiPy[iv];
          }
        }
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          real xde=X0(i1,i2,i3)-x0;
          real yde=X1(i1,i2,i3)-y0;
          // time derivatives: 
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - cos(fx*xde)*sin(fy*yde)*phiExt;  // Ex.t
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - sin(fx*xde)*cos(fy*yde)*phiEyt;  // Ey.t
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - cos(fx*xde)*cos(fy*yde)*phiHzt;  // Hz.t 
          // errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-fy)*cos(fx*xde)*sin(fy*yde)*cos(omega*tE);  // Ex.t
          // errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - ( fx)*sin(fx*xde)*cos(fy*yde)*cos(omega*tE);  // Ey.t
          // errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - (-omega)*cos(fx*xde)*cos(fy*yde)*sin(omega*tH);  // Hz.t 
        }
      }
    } 
    else // 3D
    {

      Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
        xd=X0(i1,i2,i3)-x0;
        yd=X1(i1,i2,i3)-y0;
        zd=X2(i1,i2,i3)-z0;

        ERREX(i1,i2,i3)=UEX(i1,i2,i3) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiEx;  // 
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiEy;  // 
        ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiEz;  // 

        // ERREX(i1,i2,i3)=UEX(i1,i2,i3) -  (a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        // ERREY(i1,i2,i3)=UEY(i1,i2,i3) -  (a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        // ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) -  (a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*cos(omega*tE);  // 
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=X0(i1,i2,i3)-x0;
          yd=X1(i1,i2,i3)-y0;
          zd=X2(i1,i2,i3)-z0;
          // time derivatives: 
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*phiExt;
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*phiEyt;
          errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt) - sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*phiEzt;
          // errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-omega*a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*sin(omega*tE);
          // errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - (-omega*a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*sin(omega*tE);
          // errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt) - (-omega*a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*sin(omega*tE);
        }
      }
    }
  }
  else // curvilinear 
  {
    // curvilinear
    if( numberOfDimensions==2 )
    {
      Index J1 = Range(max(Ih1.getBase(),uhl.getBase(0)),min(Ih1.getBound(),uhl.getBound(0)));
      Index J2 = Range(max(Ih2.getBase(),uhl.getBase(1)),min(Ih2.getBound(),uhl.getBound(1)));
      Index J3 = Range(max(Ih3.getBase(),uhl.getBase(2)),min(Ih3.getBound(),uhl.getBound(2)));

      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        xd=XHP(i1,i2,i3,0)-x0;
        yd=XHP(i1,i2,i3,1)-y0;
        ERRHZ(i1,i2,i3)=UHZ(i1,i2,i3) - cos(fx*xd)*cos(fy*yd)*cos(omega*tH);
      }

      J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3(i1,i2,i3,J1,J2,J3)
      {
        xd=XEP(i1,i2,i3,0)-x0;
        yd=XEP(i1,i2,i3,1)-y0;
        ERREX(i1,i2,i3)=UEX(i1,i2,i3) - (-fy/omega)*cos(fx*xd)*sin(fy*yd)*sin(omega*tE);  // Ex.t = Hz.y
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) - ( fx/omega)*sin(fx*xd)*cos(fy*yd)*sin(omega*tE);  // Ey.t = - Hz.x
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);
        FOR_3(i1,i2,i3,J1,J2,J3)
        {
          xd=XEP(i1,i2,i3,0)-x0;
          yd=XEP(i1,i2,i3,1)-y0;
          // time derivatives: 
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-fy)*cos(fx*xd)*sin(fy*yd)*cos(omega*tE);  // Ex.t
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - ( fx)*sin(fx*xd)*cos(fy*yd)*cos(omega*tE);  // Ey.t
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt) - (-omega)*cos(fx*xd)*cos(fy*yd)*sin(omega*tH);  // Hz.t 
        }
      }

    } 
    else // 3D
    {
      Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        xd=XEP(i1,i2,i3,0)-x0;
        yd=XEP(i1,i2,i3,1)-y0;
        zd=XEP(i1,i2,i3,2)-z0;

        ERREX(i1,i2,i3)=UEX(i1,i2,i3) -  (a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        ERREY(i1,i2,i3)=UEY(i1,i2,i3) -  (a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*cos(omega*tE);  // 
        ERREZ(i1,i2,i3)=UEZ(i1,i2,i3) -  (a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*cos(omega*tE);  // 
      }

      if( method==sosup )
      {
        // Compute errors in the time derivative
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          xd=XEP(i1,i2,i3,0)-x0;
          yd=XEP(i1,i2,i3,1)-y0;
          zd=XEP(i1,i2,i3,2)-z0;

          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext) - (-omega*a1/fx)*cos(fx*xd)*sin(fy*yd)*sin(fz*zd)*sin(omega*tE);
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt) - (-omega*a2/fy)*sin(fx*xd)*cos(fy*yd)*sin(fz*zd)*sin(omega*tE);
          errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt) - (-omega*a3/fz)*sin(fx*xd)*sin(fy*yd)*cos(fz*zd)*sin(omega*tE);
        }
      }

    }

  }
}

#endMacro

// =============================================================================================
// MACRO: Get errors for various scattering exact solutions
// =============================================================================================
#beginMacro getErrorsScattering()
{
      
  const real cc0= cGrid(0)*sqrt( kx*kx+ky*ky ); // NOTE: use grid 0 values for multi-materials

  if( knownSolution==NULL )
  {
    initializeKnownSolution();
  }
  const realArray & ug = (*knownSolution)[grid];
  realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

  // The analytic solution assumed incident field was Ei = exp(i*k*x-i*w*t) 
  //     This gives solution
  //           Re(E)*cos(w*t) - Im(E)*sin(w*t) for Ei=cos(w*t)
  //      or   Re(E)*cos(w*t-pi/2) - Im(E)*sin(w*t-pi/2) for Ei=cos(w*t-pi/2)               
  //      i.e. Re(E)*sin(w*t) + Im(E)*cos(w*t) for Ei=sin(w*t)
  // Ex:
  Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
  Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);

#ifdef USE_PPP
  const realSerialArray & ugLocal = ug.getLocalArrayWithGhostBoundaries();
#else
  const realSerialArray & ugLocal = ug; 
#endif
  if( method==nfdtd || method==sosup )
  { // do this with scalar indexing to avoid a possible bug in P++
    real *ugp = ugLocal.Array_Descriptor.Array_View_Pointer3;
    const int ugDim0=ugLocal.getRawDataSize(0);
    const int ugDim1=ugLocal.getRawDataSize(1);
    const int ugDim2=ugLocal.getRawDataSize(2);
#undef UG
#define UG(i0,i1,i2,i3) ugp[i0+ugDim0*(i1+ugDim1*(i2+ugDim2*(i3)))]

    // const real cost = cos(-twoPi*cc0*tH);  // *wdh* 050731 -- use cc0 
    // const real sint = sin(-twoPi*cc0*tH);
    // const real dcost =  twoPi*cc0*sint;  // d(sin(..))/dt 
    // const real dsint = -twoPi*cc0*cost;  // d(sin(..))/dt 

    getKnownSolutionTimeCoefficients();

    // // NOTE: This next section is repeated in getInitialConditions.bC,
    // //        getErrors.bC and assignBoundaryConditions.bC *FIX ME*
    // real cost,sint,dcost,dsint;
    // if( dispersionModel==noDispersion )
    // {
    //   cost = cos(-twoPi*cc0*t); 
    //   sint = sin(-twoPi*cc0*t); 
    //   dcost =  twoPi*cc0*sint;  // d(sin(..))/dt 
    //   dsint = -twoPi*cc0*cost;  // d(sin(..))/dt 
    // }
    // else
    // {
    //   // -- dispersive model --  *CHECK ME*

    //   // Evaluate the dispersion relation for "s"
    //   DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
    //   const real kk = twoPi*cc0;  // Parameter in dispersion relation **check me**
    //   real reS, imS;
    //   dmp.computeDispersionRelation( c,eps,mu,kk, reS, imS );
    //   real expS = exp(reS*t), expSm=exp(reS*(t-dt));
    //   imS=-imS;  // flip sign 
    //   printF("--ER-- scatCyl imS=%g, Im(s)/(twoPi*cc0)=%g reS=%g\n",imS,imS/twoPi*cc0,reS);

    //   cost = cos( imS*t )*expS;      // "cos(t)" for dispersive model 
    //   sint = sin( imS*t )*expS;

    //   dcost = -imS*sint + reS*cost;  //  d/dt of "cost" 
    //   dsint =  imS*cost + reS*sint;  //  d/dt of "cost" 
	    
    // }

    // adjust array dimensions for local arrays
    Index J1 = Range(max(Ie1.getBase(),uel.getBase(0)),min(Ie1.getBound(),uel.getBound(0)));
    Index J2 = Range(max(Ie2.getBase(),uel.getBase(1)),min(Ie2.getBound(),uel.getBound(1)));
    Index J3 = Range(max(Ie3.getBase(),uel.getBase(2)),min(Ie3.getBound(),uel.getBound(2)));

    int i1,i2,i3;
    if( numberOfDimensions==2 )
    {
      FOR_3D(i1,i2,i3,J1,J2,J3)
      {
        ERREX(i1,i2,i3) = UEX(i1,i2,i3)-(UG(i1,i2,i3,ex)*sint+UG(i1,i2,i3,ex+3)*cost);
        ERREY(i1,i2,i3) = UEY(i1,i2,i3)-(UG(i1,i2,i3,ey)*sint+UG(i1,i2,i3,ey+3)*cost);
        ERRHZ(i1,i2,i3) = UHZ(i1,i2,i3)-(UG(i1,i2,i3,hz)*sint+UG(i1,i2,i3,hz+3)*cost);
        if( method==sosup )
        { // errors in time derivatives:
          errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)-(UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost);
          errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)-(UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost);
          errLocal(i1,i2,i3,hzt) = uLocal(i1,i2,i3,hzt)-(UG(i1,i2,i3,hz)*dsint+UG(i1,i2,i3,hz+3)*dcost);
        }
      }

      // -- dispersion model components --
      if( dispersionModel!=noDispersion )
      {
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            // *fix* me for numberOfPolarizationVectors>1 
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - (UG(i1,i2,i3,ex)*phiPs + UG(i1,i2,i3,ex+3)*phiPc);
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc+1) - (UG(i1,i2,i3,ey)*phiPs + UG(i1,i2,i3,ey+3)*phiPc);
          }
        }
      }
    }
    else  // --- 3D ----
    {
      if( solveForElectricField )
      {
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          ERREX(i1,i2,i3) = UEX(i1,i2,i3)-(UG(i1,i2,i3,ex)*sint+UG(i1,i2,i3,ex+3)*cost);
          ERREY(i1,i2,i3) = UEY(i1,i2,i3)-(UG(i1,i2,i3,ey)*sint+UG(i1,i2,i3,ey+3)*cost);
          ERREZ(i1,i2,i3) = UEZ(i1,i2,i3)-(UG(i1,i2,i3,ez)*sint+UG(i1,i2,i3,ez+3)*cost);
          if( method==sosup )
          { // errors in time derivatives:
            errLocal(i1,i2,i3,ext) = uLocal(i1,i2,i3,ext)-(UG(i1,i2,i3,ex)*dsint+UG(i1,i2,i3,ex+3)*dcost);
            errLocal(i1,i2,i3,eyt) = uLocal(i1,i2,i3,eyt)-(UG(i1,i2,i3,ey)*dsint+UG(i1,i2,i3,ey+3)*dcost);
            errLocal(i1,i2,i3,ezt) = uLocal(i1,i2,i3,ezt)-(UG(i1,i2,i3,ez)*dsint+UG(i1,i2,i3,ez+3)*dcost);
          }
        }
      }
      if( solveForMagneticField )
      {
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          ERRHX(i1,i2,i3) = UHX(i1,i2,i3)-(UG(i1,i2,i3,hx)*sint+UG(i1,i2,i3,hx+3)*cost);
          ERRHY(i1,i2,i3) = UHY(i1,i2,i3)-(UG(i1,i2,i3,hy)*sint+UG(i1,i2,i3,hy+3)*cost);
          ERRHZ(i1,i2,i3) = UHZ(i1,i2,i3)-(UG(i1,i2,i3,hz)*sint+UG(i1,i2,i3,hz+3)*cost);
        }
      }
      // -- dispersion model components --
      if( dispersionModel!=noDispersion )
      {
        FOR_3D(i1,i2,i3,J1,J2,J3)
        {
          for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
          {
            const int pc= iv*numberOfDimensions;
            // *fix* me for numberOfPolarizationVectors>1 
            errPolarization(i1,i2,i3,pc  ) = pLocal(i1,i2,i3,pc  ) - (UG(i1,i2,i3,ex)*phiPs + UG(i1,i2,i3,ex+3)*phiPc);
            errPolarization(i1,i2,i3,pc+1) = pLocal(i1,i2,i3,pc  ) - (UG(i1,i2,i3,ey)*phiPs + UG(i1,i2,i3,ey+3)*phiPc);
            errPolarization(i1,i2,i3,pc+2) = pLocal(i1,i2,i3,pc+1) - (UG(i1,i2,i3,ez)*phiPs + UG(i1,i2,i3,ez+3)*phiPc);
          }
          // errLocal(i1,i2,i3,pxc) = uLocal(i1,i2,i3,pxc) - (UG(i1,i2,i3,ex)*phiPs + UG(i1,i2,i3,ex+3)*phiPc);
          // errLocal(i1,i2,i3,pyc) = uLocal(i1,i2,i3,pyc) - (UG(i1,i2,i3,ey)*phiPs + UG(i1,i2,i3,ey+3)*phiPc);
          // errLocal(i1,i2,i3,pzc) = uLocal(i1,i2,i3,pzc) - (UG(i1,i2,i3,ez)*phiPs + UG(i1,i2,i3,ez+3)*phiPc);
        }
      }

    }
#undef UG
	      
  }
  else
  {
    real cost = cos(-twoPi*cc*tH);  // *wdh* 040626 add "-"
    real sint = sin(-twoPi*cc*tH);
    errh(Ih1,Ih2,Ih3,Ch)=uh(Ih1,Ih2,Ih3,Ch) - (ugLocal(Ih1,Ih2,Ih3,Ch)*sint+ugLocal(Ih1,Ih2,Ih3,Ch+3)*cost);

    cost = cos(-twoPi*cc*tE);  // *wdh* 040626 add "-"
    sint = sin(-twoPi*cc*tE);  // *wdh* 040626 add "-"
    erre(Ie1,Ie2,Ie3,Ce)=ue(Ie1,Ie2,Ie3,Ce) - (ugLocal(Ie1,Ie2,Ie3,Ce)*sint+ugLocal(Ie1,Ie2,Ie3,Ce+3)*cost);
	    
//              // err(I1,I2,I3,C)=fabs( u(I1,I2,I3,C) - (ug(I1,I2,I3,C)*sint+ug(I1,I2,I3,C+3)*cost) );
//              // ok err(I1,I2,I3,hz)=fabs( u(I1,I2,I3,hz) - (-ug(I1,I2,I3,hz)*sint)+ug(I1,I2,I3,hz+3)*cost));

//              err(I1,I2,I3,ex)=fabs( u(I1,I2,I3,ex) + (ug(I1,I2,I3,ex)*sint+ug(I1,I2,I3,ex+3)*cost) );
//              err(I1,I2,I3,ey)=fabs( u(I1,I2,I3,ey) + (ug(I1,I2,I3,ey)*sint+ug(I1,I2,I3,ey+3)*cost) );
//              // ok err(I1,I2,I3,ey)=fabs( u(I1,I2,I3,ey) - (-ug(I1,I2,I3,ey+3)*cost) );

//              err(I1,I2,I3,hz)=fabs( u(I1,I2,I3,hz) - (ug(I1,I2,I3,hz)*sint+ug(I1,I2,I3,hz+3)*cost));
  }

}

#endMacro






// =================================================================================================================
/// \brief Determine the errors.
// =================================================================================================================
void Maxwell::
getErrors( int current, real t, real dt )
{
  if( !checkErrors )
    return;

  real time0=getCPU();
  
  const real cc= c*sqrt( kx*kx+ky*ky+kz*kz);
  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Iav[3], &Ia1=Iav[0], &Ia2=Iav[1], &Ia3=Iav[2]; 
  Index Ibv[3], &Ib1=Ibv[0], &Ib2=Ibv[1], &Ib3=Ibv[2]; 
  Index Icv[3], &Ic1=Icv[0], &Ic2=Icv[1], &Ic3=Icv[2]; 

  const int prev = (current-1+numberOfTimeLevels) % numberOfTimeLevels;
  const int next = (current+1) % numberOfTimeLevels;
  
  // printF(" >>>>>>>>getErrors: current=%i next=%i <<<<<<<<<<< \n",current,next);
  

  assert( cgp!=NULL );
  CompositeGrid & cg = *cgp;
  const int numberOfComponentGrids = cg.numberOfComponentGrids();
  const int numberOfDimensions = cg.numberOfDimensions();

  // Range C(ex,hz);
  // const int numberOfComponents= cgfields[0][0].getLength(3);
  const int & numberOfComponents= dbase.get<int>("numberOfComponents");

  int & numberOfErrorComponents= dbase.get<int>("numberOfErrorComponents");

  numberOfErrorComponents=numberOfComponents;
  const int epc = numberOfComponents;  // save P norm and errors in this component
  if( dispersionModel != noDispersion )
  {
     numberOfErrorComponents++;  // save error in all polarization vectors 
  }
  
  
  Range C=numberOfComponents;
  solutionNorm.redim(numberOfErrorComponents);  

  // When we compute the energy we also save energy, and delta(energy)
  int numErr=numberOfErrorComponents;
  if( computeEnergy )
    numErr+=2;
  
  // maximumError.redim(numberOfSequences); 
  maximumError.redim(numErr);

  if( method==nfdtd || method==yee )
  {
  }
  else if( method==sosup )
  {
  }
  else
  {
    if(numberOfDimensions==2)
    {
      solutionNorm.redim(3);
    }
    else
    {
      solutionNorm.redim(6);
    }
  }

  maximumError=0.;
  solutionNorm=1.;
  
  realCompositeGridFunction *uReference=NULL;
  if( compareToReferenceShowFile )
  {
    // This case is used for comparing absorbing BC's -- we compare the solution to a reference
    // solution that was computed on a bigger grid
    if( referenceShowFileReader==NULL )
    {
      referenceShowFileReader = new ShowFileReader(nameOfReferenceShowFile);
    }
	    
    CompositeGrid cgRef;
    realCompositeGridFunction uRef;
	    
    int solutionNumber = 1 + int( t/tPlot + .5); // fix this ******************************
    printF(" **** compareToReferenceShowFile: t=%f solutionNumber=%i\n",t,solutionNumber);
    
    referenceShowFileReader->getASolution(solutionNumber,cgRef,uRef);        // read in a grid and solution

    // This solution uReference will live on the smaller domain 
    Range all;
    uReference = new realCompositeGridFunction(cg,all,all,all,C);
    cg.update(MappedGrid::THEmask );
    cgRef.update(MappedGrid::THEmask );
    interpolateAllPoints( uRef,*uReference );  // interpolate uReference from uRef
  }

  maximumError=0.;  // max error over all grids
  solutionNorm=0.;
  
  //kkc 040310 moved this assertion outside the following loop
  assert( cgerrp!=NULL || errp!=NULL );

  // For dispersive models keep track of the maxium errors in the polarization vector per domain  
  RealArray maxErrPolarization(cg.numberOfDomains());
  maxErrPolarization=0.;
  

  for( int grid=0; grid<numberOfComponentGrids; grid++ )
  {

    if( method==yee )
    {
      assert( numberOfComponentGrids==1 );
      
      int option=1;
      int iparam[5] = { -1,-1,0,0,0 }; // 
      getValuesFDTD( option, iparam, current, t, dt, cgerrp );

      continue;
    }

    c = cGrid(grid);
    eps = epsGrid(grid);
    mu = muGrid(grid);

    EXTRACT_GFP(ERRORS);    // bpp macro


    DispersiveMaterialParameters & dmp = getDispersiveMaterialParameters(grid);
    int numberOfPolarizationVectors = 0;
    const int domain = cg.domainNumber(grid);
    if(  dispersionModel != noDispersion )
    {
      numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;
    }
    

    // --- Get Arrays for the dispersive model ----
    realMappedGridFunction & pCur = getDispersionModelMappedGridFunction( grid,current );

    RealArray pLocal;
    if( numberOfPolarizationVectors>0 )
    {
      OV_GET_SERIAL_ARRAY(real, pCur,pLoc);
      pLocal.reference(pLoc);
      // ::display(pLocal,"pLocal");
    }

    // --- Allocate arrays to hold errors in the polarization vectors  ----
    RealArray errPolarization;
    if( numberOfPolarizationVectors>0 )
    {
      Range Pc = numberOfPolarizationVectors*numberOfDimensions;
      errPolarization.redim(uLocal.dimension(0),uLocal.dimension(1),uLocal.dimension(2),Pc);
      errPolarization=0.;
    }    


    bool energyOnly = false;

    const int i0a=mg.gridIndexRange(0,0);
    const int i1a=mg.gridIndexRange(0,1);
    const int i2a=mg.gridIndexRange(0,2);

    const real xa=xab[0][0], dx0=dx[0];
    const real ya=xab[0][1], dy0=dx[1];
    const real za=xab[0][2], dz0=dx[2];

#define X0(i0,i1,i2) (xa+dx0*(i0-i0a))
#define X1(i0,i1,i2) (ya+dy0*(i1-i1a))
#define X2(i0,i1,i2) (za+dz0*(i2-i2a))

    const int numberOfGhost=method==nfdtd ? orderOfAccuracyInSpace/2 : 0;
      
    // Range C(ex,hz);

    real errEx,errEy,errHz;

    // Here is the box where we evaluate the error when there is a PML
    bool usePML = getBoundsForPML( mg,Iv,pmlErrorOffset ); 
    if( usePML )
    { // do NOT include PML region in the bounds: 
      adjustBoundsForPML(mg,Iev,pmlErrorOffset ); 
      adjustBoundsForPML(mg,Ihv,pmlErrorOffset ); 
    }

    errh = 0.;
    erre = 0.;
    // if( initialConditionOption==planeWaveInitialCondition )
    if( knownSolutionOption==planeWaveKnownSolution )
    {
      // ********** Plane wave **********

      getErrorsPlaneWave();
	    
    }
    else if( knownSolutionOption==twilightZoneKnownSolution )
    {

      // ********** Twilight Zone errors *************

      getErrorsTwilightZone();
    
    }
    else if( knownSolutionOption==gaussianPlaneWaveKnownSolution )
    {
      // ********** Gaussian plane wave **********
      getErrorsGuassianPlaneWave();
      

    
    }
    else if( knownSolutionOption==squareEigenfunctionKnownSolution )
    {
      // ********** Square or Box eigenfunctions **********

      getErrorsSquareEigenFunction();
      
    }
    else if( knownSolutionOption==annulusEigenfunctionKnownSolution )
    {
      //kkc XXX not implemented for dsi schemes
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

      Index J1 = Range(max(I1.getBase(),uLocal.getBase(0)),min(I1.getBound(),uLocal.getBound(0)));
      Index J2 = Range(max(I2.getBase(),uLocal.getBase(1)),min(I2.getBound(),uLocal.getBound(1)));
      Index J3 = Range(max(I3.getBase(),uLocal.getBase(2)),min(I3.getBound(),uLocal.getBound(2)));

      annulusEigenFunction(error,J1,J2,J3);
            
    }
    else if( knownSolutionOption==planeMaterialInterfaceKnownSolution )
    {
      if( method==nfdtd || method==sosup )
      { 
        realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);

	// adjust array dimensions for local arrays
	Index J1 = Range(max(I1.getBase(),uel.getBase(0)),min(I1.getBound(),uel.getBound(0)));
	Index J2 = Range(max(I2.getBase(),uel.getBase(1)),min(I2.getBound(),uel.getBound(1)));
	Index J3 = Range(max(I3.getBase(),uel.getBase(2)),min(I3.getBound(),uel.getBound(2)));

	setPlaneMaterialInterfaceMacro(error,J1,J2,J3);
      }
      else
      {
	printF("MX:getErrors: ERROR: initialConditionOption==planeMaterialInterfaceInitialCondition but method=%i\n",
	       (int)method);
	OV_ABORT("ERROR");
      }
    }
    else if( knownSolutionOption==gaussianIntegralKnownSolution )
    {
	    
      // adjust array dimensions for local arrays
      Index J1 = Range(max(I1.getBase(),uel.getBase(0)),min(I1.getBound(),uel.getBound(0)));
      Index J2 = Range(max(I2.getBase(),uel.getBase(1)),min(I2.getBound(),uel.getBound(1)));
      Index J3 = Range(max(I3.getBase(),uel.getBase(2)),min(I3.getBound(),uel.getBound(2)));

      getGaussianIntegralSolution(error,UEX,UEY,UHZ,tE,J1,J2,J3);

	    
    }
    else if( compareToReferenceShowFile )
    {
      //kkc XXX not implemented for dsi schemes

      assert( uReference!=NULL );
	    
      realMappedGridFunction & ur = (*uReference)[grid];
	    
#ifdef USE_PPP
      realSerialArray urLocal;  getLocalArrayWithGhostBoundaries(ur,urLocal);
#else
      const realSerialArray & urLocal  =  ur;
#endif

      //            err(I1,I2,I3,C)=fabs(u(I1,I2,I3,C)-ur(I1,I2,I3,C));
      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      errh(Ih1,Ih2,Ih3,Ch)=uh(I1,I2,I3,Ch)-urLocal(I1,I2,I3,Ch);
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
      erre(Ie1,Ie2,Ie3,Ce)=ue(Ie1,Ie2,Ie3,Ce) - urLocal(Ie1,Ie2,Ie3,Ce);
    }

    else if( knownSolutionOption==scatteringFromADiskKnownSolution ||
             knownSolutionOption==scatteringFromADielectricDiskKnownSolution ||
             knownSolutionOption==scatteringFromASphereKnownSolution ||
             knownSolutionOption==scatteringFromADielectricSphereKnownSolution )
    {

      // Get errors for various scattering exact solutions
      getErrorsScattering();
      

    }
    else if( knownSolutionOption==userDefinedKnownSolution )
    {
      realCompositeGridFunction & cgerr = (*cgerrp);
      realSerialArray errLocal; getLocalArrayWithGhostBoundaries((*cgerrp)[grid],errLocal);      

      // save exact solution in cgrerr: 
      int numberOfTimeDerivatives=0;
      getUserDefinedKnownSolution(   t, cg,grid, cgerr[grid],I1,I2,I3,numberOfTimeDerivatives);

      errLocal(I1,I2,I3,C) = errLocal(I1,I2,I3,C) -  uLocal(I1,I2,I3,C);

    }
    else if( knownSolutionOption!=noKnownSolution )
    {
      printF("Maxwell::getErrors: unexpected value for knownSolutionOption=%i\n",(int)knownSolutionOption);
      Overture::abort("Maxwell::getErrors");
    }
    else
    {
      energyOnly = true;
    }


    // ===========================================================================
    // =============== DETERMINE MAX ERRORS AND SOLUTION NORMS ===================
    // ===========================================================================

    getIndex(mg.gridIndexRange(),I1,I2,I3);
    RealArray errMax(C);
    errMax=0.;  // max error on this grid
	
    if ( method==dsiMatVec && !energyOnly )
    { // punt here and use a special function that knows how to exclude uns. ghost points
#ifdef USE_PPP
      Overture::abort("Error: finish me");
#else
      computeDSIErrors( *this,mg, uh, uhpp, ue, uepp, errh, erre, solutionNorm, maximumError );
#endif
    }
    else if( radiusForCheckingErrors<= 0. && (method==nfdtd || method==sosup) && !energyOnly) 
    {
      Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
      Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
      if( true )
      {
	const int ng=orderOfAccuracyInSpace/2;
	const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
 
	Index J1 = Range(max(I1.getBase(),uel.getBase(0)+ng ),min(I1.getBound(),uel.getBound(0)-ng ));
	Index J2 = Range(max(I2.getBase(),uel.getBase(1)+ng ),min(I2.getBound(),uel.getBound(1)-ng ));
	Index J3 = Range(max(I3.getBase(),uel.getBase(2)+ng3),min(I3.getBound(),uel.getBound(2)-ng3));

	int i1,i2,i3;
	FOR_3D(i1,i2,i3,J1,J2,J3)
	{
	  if( MASK(i1,i2,i3)!=0 )
	  {
	    for( int c=C.getBase(); c<=C.getBound(); c++ )
	    {
#undef ERR
#define ERR(i0,i1,i2,i3) errep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]
#undef U
#define U(i0,i1,i2,i3) uep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]

	      errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
	      solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
#undef ERR
#undef U	    
	    }


            for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
            {
              const int pc= iv*numberOfDimensions;
              for( int dir=0; dir<numberOfDimensions; dir++ )
              {
                maxErrPolarization(domain) = max(maxErrPolarization(domain),fabs(errPolarization(i1,i2,i3,pc+dir)));
                solutionNorm(epc)=max(solutionNorm(epc),fabs(pLocal(i1,i2,i3,pc+dir))); 
              }
              
            }
            
          }
          // ::display(pLocal,"pLocal","%8.1e ");
        
          // printF(">> getErr >>> maxErrPolarization(domain=%i)=%e solutionNorm=%e\n",domain,maxErrPolarization(domain),
          //                solutionNorm(epc));
        
          if( debug & 2 )
          {
            fprintf(pDebugFile," *** Max errors on this processor for grid %i at t=%8.2e: ",grid,t);
            for( int c=C.getBase(); c<=C.getBound(); c++ )
              fprintf(pDebugFile,"%10.4e,",errMax(c));
            fprintf(pDebugFile,"\n");
          }
          for( int c=C.getBase(); c<=C.getBound(); c++ )
          {
// 	  errMax(c)=getMaxValue(errMax(c));
// 	  solutionNorm(c)=getMaxValue(solutionNorm(c));
	      
            maximumError(c)=max(maximumError(c),errMax(c));  // max error over all grids
          }
	    
        }
      }
      else // check inside radius
      {
        // printF(" Check errors within the sphere of radius %10.2e\n",radiusForCheckingErrors);
	  
        // new way
        const int ng=orderOfAccuracyInSpace/2;
        const int ng3 = mg.numberOfDimensions()==2 ? 0 : ng;
 
        Index J1 = Range(max(I1.getBase(),uLocal.getBase(0)+ng ),min(I1.getBound(),uLocal.getBound(0)-ng ));
        Index J2 = Range(max(I2.getBase(),uLocal.getBase(1)+ng ),min(I2.getBound(),uLocal.getBound(1)-ng ));
        Index J3 = Range(max(I3.getBase(),uLocal.getBase(2)+ng3),min(I3.getBound(),uLocal.getBound(2)-ng3));

        Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
        Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
	    
        if ( method==nfdtd )
        {
          const real radiusForCheckingErrorsSquared=SQR(radiusForCheckingErrors);
		
          real radius;
          int i1,i2,i3;
#undef ERR
#define ERR(i0,i1,i2,i3) errep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]
#undef U
#define U(i0,i1,i2,i3) uep[i0+ueDim0*(i1+ueDim1*(i2+ueDim2*(i3)))]

          if( isRectangular )
          {
            FOR_3D(i1,i2,i3,J1,J2,J3)
            {
              radius = SQR(X0(i1,i2,i3))+SQR(X1(i1,i2,i3));
              if( numberOfDimensions==3 ) radius+=SQR(X2(i1,i2,i3));
			
              if( radius<radiusForCheckingErrorsSquared && MASK(i1,i2,i3)!=0 )
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                {
                  errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
                  solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
				
                }
                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                  {
                    maxErrPolarization(domain) = max(maxErrPolarization(domain),fabs(errPolarization(i1,i2,i3,pc+dir)));
                    solutionNorm(epc)=max(solutionNorm(epc),fabs(pLocal(i1,i2,i3,pc+dir))); 
                  }
                
                }
              }
              else
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                  ERR(i1,i2,i3,c)=0.;

                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                    errPolarization(i1,i2,i3,pc+dir)=0.;
                }
              }
            } // end FOR3D
          }
          else // curvilinear
          {
            FOR_3D(i1,i2,i3,J1,J2,J3)
            {
              radius = SQR(X(i1,i2,i3,0))+SQR(X(i1,i2,i3,1));
              if( numberOfDimensions==3 ) radius+=SQR(X(i1,i2,i3,2));
			
              if( radius<radiusForCheckingErrorsSquared && MASK(i1,i2,i3)!=0 )
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                {
                  errMax(c)=max(errMax(c),fabs(ERR(i1,i2,i3,c)));           // this is the max err on this grid
                  solutionNorm(c)=max(solutionNorm(c),fabs(U(i1,i2,i3,c)));
				
                }

                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                  {
                    maxErrPolarization(domain) = max(maxErrPolarization(domain),fabs(errPolarization(i1,i2,i3,pc+dir)));
                    solutionNorm(epc)=max(solutionNorm(epc),fabs(pLocal(i1,i2,i3,pc+dir))); 
                  }
                }

              }
              else
              {
                for( int c=C.getBase(); c<=C.getBound(); c++ )
                  ERR(i1,i2,i3,c)=0.;

                for( int iv=0; iv<numberOfPolarizationVectors; iv++ )
                {
                  const int pc= iv*numberOfDimensions;
                  for( int dir=0; dir<numberOfDimensions; dir++ )
                    errPolarization(i1,i2,i3,pc+dir)=0.;
                }
              }
			
            }
          }
        }
        
#undef ERR
#undef U		
	if( debug & 2 )
	{
	  fprintf(pDebugFile," *** Max errors on this processor for grid %i at t=%8.2e: ",grid,t);
	  for( int c=C.getBase(); c<=C.getBound(); c++ )
	    fprintf(pDebugFile,"%10.4e,",errMax(c));
          fprintf(pDebugFile,"\n");
	}
	
	
 	for( int c=C.getBase(); c<=C.getBound(); c++ )
 	{
// 	  errMax(c)=getMaxValue(errMax(c));
// 	  solutionNorm(c)=getMaxValue(solutionNorm(c));
		    
 	  maximumError(c)=max(maximumError(c),errMax(c));  // max error over all grids
 	}
      }
    
    } // end else if inside radius

    bool computeErrorsAtGhost=true;
#ifdef USE_PPP
    computeErrorsAtGhost=false;
#endif
    if( computeErrorsAtGhost && !usePML && (method==nfdtd || method==sosup) )
    {
	      
      // compute error including ghost points
      // *** this is wrong ==> only check ghost points where mask on boundary !=0 
      realMappedGridFunction & err = mgp==NULL ? (*cgerrp)[grid] : *errp;
      #ifdef USE_PPP
        realSerialArray errLocal;  getLocalArrayWithGhostBoundaries(err,errLocal);
      #else
        const realSerialArray & errLocal  =  err;
      #endif	    
      
	      
      RealArray ghostError(C,Range(1,numberOfGhost));
      ghostError=0.;
      int c,ghost;
      Index Ig1,Ig2,Ig3;
      for( int axis=0; axis<mg.numberOfDimensions(); axis++)
      {
	for( int side=0; side<=1; side++ )
	{
	  getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
          bool ok = ParallelUtility::getLocalArrayBounds(mask,maskLocal,I1,I2,I3);
          if( !ok ) continue;
	  for( ghost=1; ghost<=numberOfGhost; ghost++ )
	  {
	    getGhostIndex(mg.gridIndexRange(),side,axis,Ig1,Ig2,Ig3,ghost);
	    bool ok = ParallelUtility::getLocalArrayBounds(mask,maskLocal,Ig1,Ig2,Ig3);
	    if( !ok ) continue;

	    Index Ch = cg.numberOfDimensions()==2 ? Range(hz,hz) : Range(hx,hz);
	    Index Ce = cg.numberOfDimensions()==2 ? Range(ex,ey) : Range(ex,ez);
			
	    where( maskLocal(I1,I2,I3)!=0 && maskLocal(Ig1,Ig2,Ig3)!=0 )
	    {
	      for( c=C.getBase(); c<=C.getBound(); c++ )
		ghostError(c,ghost)=max(ghostError(c,ghost),max(fabs(errLocal(Ig1,Ig2,Ig3,c))));
			    
	      for( c=C.getBase(); c<=C.getBound(); c++ )
	      {
		if( max(fabs(errLocal(Ig1,Ig2,Ig3,c)))>1.e+1 )
		{
		  fprintf(pDebugFile," *** grid=%i side,axis=%i,%i ghost=%i c=%i ****\n",grid,side,axis,ghost,c);
		  display(errLocal(Ig1,Ig2,Ig3,c),"ERROR on the ghost line",pDebugFile);
		}
	      }
			    
	    }
	  }
	}
      }

      if( debug & 2 )
      {
	for( ghost=1; ghost<=numberOfGhost; ghost++ )
	{
	  printF(" t=%9.3e: grid=%i: Errors at ghost line %i: ",t,grid,ghost);
	  for( c=C.getBase(); c<=C.getBound(); c++ )
	    printF("%8.2e, ",ghostError(c,ghost));
	  printF("\n");
	}
      }
      
    } // end if compute error at ghost

  
    EXTRACT_GFP_END(ERRORS);
  } // end for grid
  

  for( int c=C.getBase(); c<=C.getBound(); c++ )
  {
    solutionNorm(c)=getMaxValue(solutionNorm(c)); // fix me -- could do all at once
    maximumError(c)=getMaxValue(maximumError(c));
  }

  if( debug & 2 )
  {
    fprintf(pDebugFile,"\n --> t=%10.4e dt=%7.1e Errors: ",t,dt);
    for( int c=C.getBase(); c<=C.getBound(); c++ )
      fprintf(pDebugFile,"%10.4e,",maximumError(c));
    fprintf(pDebugFile,"\n");
  }

  // -------- PRINT ERRORS IN POLARIZATION VECTORS FOR DISPERSIVE MODELS --------
  if( dispersionModel != noDispersion )
  {
    for( int domain=0; domain<cg.numberOfDomains(); domain++ )
    {
      DispersiveMaterialParameters & dmp = getDomainDispersiveMaterialParameters(domain);
      const int numberOfPolarizationVectors = dmp.numberOfPolarizationVectors;  

      maxErrPolarization(domain) = getMaxValue(maxErrPolarization(domain)); // fix me -- could do all at once
      maximumError(epc)=max(maximumError(epc),maxErrPolarization(domain));
      solutionNorm(epc)=getMaxValue(solutionNorm(epc));

      if( numberOfPolarizationVectors>0 )
      {
        printF("--getErrors: t=%9.3e domain=%i (%s) numPolarizationVectors=%i P-norm=%9.3e max-err = %9.3e\n",
               t,domain,(const char*)cg.getDomainName(domain), numberOfPolarizationVectors,
               solutionNorm(epc),maxErrPolarization(domain));
      }
    }
    
  }
  

  if( method==nfdtd || method==yee || method==sosup )
  {
    realCompositeGridFunction & cgerr = *cgerrp;
    realCompositeGridFunction & cgu = cgfields[current];

    // We print the max norm and optionally some lp norms
    // const int errorNorm = parameters.dbase.get<int >("errorNorm");
    int numberOfNormsToPrint=1;
    if( errorNorm<10000 ) numberOfNormsToPrint+=errorNorm;

    for( int norm=0; norm<numberOfNormsToPrint; norm++ )
    { // norm==0 : max-norm, otherwise Lp-norm with p=norm
      int pNorm = norm==0 ? INT_MAX : norm;

      if( norm!=0 ) // max-norm values are already computed -- we could avoid doing this above --
      {
	// compute the Lp norm
	maximumError=0.;
	for( int c=C.getBase(); c<=C.getBound(); c++ )
	{
	  const int maskOption=0;  // check points where mask != 0
          const int checkErrorsAtGhostPoints=0;
	  if( pNorm<10000 )
	  {
	    maximumError(c)=lpNorm(pNorm,cgerr,c,maskOption,checkErrorsAtGhostPoints);
	    solutionNorm(c)=lpNorm(pNorm,cgu  ,c,maskOption,checkErrorsAtGhostPoints);
	  }
	  else
	  { // assume this is the max-norm
	    maximumError(c)=maxNorm(cgerr,c,maskOption,checkErrorsAtGhostPoints);
	    solutionNorm(c)=maxNorm(cgu  ,c,maskOption,checkErrorsAtGhostPoints);
	  }
	}
      }
      
      aString normName;
      if( pNorm<1000 )
	sPrintF(normName,"l%i",pNorm);
      else
	normName="max";

      for( int fileio=0; fileio<2; fileio++ )
      {
	FILE *output = fileio==0 ? logFile : stdout;

	if( radiusForCheckingErrors>0 && radiusForCheckingErrors<10. )
	  fPrintF(output,"                t=%8.2e dt=%7.1e %s errors(r=%3.2f):[",
                   t,dt,radiusForCheckingErrors,(const char*)normName);
	else
	  fPrintF(output,">>> t=%8.2e dt=%7.1e %s errors:[",t,dt,(const char*)normName);

	for( int c=C.getBase(); c<=C.getBound(); c++ )
	  fPrintF(output,"%8.2e,",maximumError(c));
	// fPrintF(output,"%10.4e,",maximumError(c));

	fPrintF(output,"], %s (u):[",(const char*)normName);

	for( int c=C.getBase(); c<=C.getBound(); c++ )
	  fPrintF(output,"%8.2e,",solutionNorm(c));

	fPrintF(output,"] (%i steps)\n",numberOfStepsTaken);
      }
    } // end for norm 
  }
  
  timing(timeForGetError)+=getCPU()-time0;
}

