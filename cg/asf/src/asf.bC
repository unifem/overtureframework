#include "Cgasf.h"
#include "AsfParameters.h"
#include "MappedGridOperators.h"
#include "interpPoints.h"
#include "Chemkin.h"
#include "ParallelUtility.h"

// Macros for extracting local arrays
#beginMacro getLocalRealArray(u,uLocal)
#ifdef USE_PPP
  realSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
#else
  const realSerialArray & uLocal=u;
#endif
#endMacro

#beginMacro getLocalIntArray(u,uLocal)
#ifdef USE_PPP
  intSerialArray uLocal; getLocalArrayWithGhostBoundaries(u,uLocal);
#else
  const intSerialArray & uLocal=u;
#endif
#endMacro

// ==================================
//  All speed flow algorithm
// ==================================


// This macro is used to loop over the boundaries
#define ForBoundary(side,axis)   for( axis=0; axis<c.numberOfDimensions(); axis++ ) \
                                 for( side=0; side<=1; side++ )

#define asfdt EXTERN_C_NAME(asfdt)
extern "C"
{
 void asfdt(const int&nd,
	    const int&n1a,const int&n1b,const int&n2a,const int&n2b,const int&n3a,const int&n3b,
	    const int&nd1a,const int&nd1b,const int&nd2a,const int&nd2b,const int&nd3a,const int&nd3b,
	    const int&nd4a,const int&nd4b,
	    const int&mask, const real& xy, const real& rx, 
	    const real& u, const real& uu, real&ut, real&uti, 
            const real& rhoL, const real& pL,
            const real&gv, const real & dw, const int&bc, const int&ipar, const real&rpar, const int&ierr );
}



#define U(c)     u(I1,I2,I3,c)   
#define UU(c)   uu(I1,I2,I3,c)
#define UX(c)   ux(I1,I2,I3,c)
#define UY(c)   uy(I1,I2,I3,c)
#define UZ(c)   uz(I1,I2,I3,c)
#define UXX(c) uxx(I1,I2,I3,c)
#define UXY(c) uxy(I1,I2,I3,c)
#define UXZ(c) uxz(I1,I2,I3,c)
#define UYY(c) uyy(I1,I2,I3,c)
#define UYZ(c) uyz(I1,I2,I3,c)
#define UZZ(c) uzz(I1,I2,I3,c)

void Cgasf::
computeSource(const Index & I1,
	      const Index & I2, 
	      const Index & I3, 
	      const realArray & v, 
              const realArray & s1_, 
	      const realArray & s2_, 
	      const realArray & gamma_, 
	      const realArray & cp_, 
	      const realArray & r_ )
// ===============================================================================================
// r : R = \sum Y_i/mbar_i
// g = gamma = cp/cv = cp/(cp-R) = 1/(1-R/cp)
// /s1 (output) : $s1 = \sum R_i \sigma_i$
// /s2 (output) : s2 = sum h_i*sigma_i
// /gamma (output) : gamma = cp/cv
// /cp (output) : cp
// /r (output) : r = sum R_i Y_i
// ===============================================================================================
{
#ifdef USE_PPP
    Overture::abort("Error- fix this Bill");
#else
  // cast away const:
  realArray & s1 = (realArray &) s1_;
  realArray & s2 = (realArray &) s2_;
  realArray & gamma = (realArray &) gamma_;
  realArray & cp = (realArray &) cp_;
  realArray & r  = (realArray &) r_;
  
  // const int & rc = parameters.dbase.get<int >("rc");
  // const int & uc = parameters.dbase.get<int >("uc");
  // const int & vc = parameters.dbase.get<int >("vc");
  // const int & wc = parameters.dbase.get<int >("wc");
  const int & pc = parameters.dbase.get<int >("pc");
  const int & tc = parameters.dbase.get<int >("tc");
  const int & sc = parameters.dbase.get<int >("sc");
  const int & numberOfSpecies = parameters.dbase.get<int >("numberOfSpecies");

  Range S0(0,numberOfSpecies-1);
  Range S(sc,sc+numberOfSpecies-1);
  realArray hi(I1,I2,I3,S0), cpi(I1,I2,I3,S0), sigma(I1,I2,I3,S0);

  assert( parameters.dbase.get<Reactions* >("reactions")!=NULL );
  Reactions & reactions = *(parameters.dbase.get<Reactions* >("reactions"));
  
//  reactions.chemicalSource(v(I1,I2,I3,rc),v(I1,I2,I3,tc), v(I1,I2,I3,S), sigma(I1,I2,I3,S0));
//  reactions.sigmaFromScaledPTY(v(I1,I2,I3,pc),v(I1,I2,I3,tc), v(I1,I2,I3,S), sigma(I1,I2,I3,S0));
    reactions.sigmaFromPTY(v(I1,I2,I3,pc),v(I1,I2,I3,tc), v(I1,I2,I3,S), sigma(I1,I2,I3,S0)); // 991018
  
  realArray teUnscaled(I1,I2,I3);
  teUnscaled=v(I1,I2,I3,tc)*parameters.dbase.get<real >("te0"); // unscaled temperature
  
  reactions.cp( teUnscaled,cpi);
  reactions.h ( teUnscaled,hi);
  
  MaterialProperties & mp = reactions.mp;
  s1=0.; s2=0.;  cp=0.; r=0.; 
  for( int s=0; s<numberOfSpecies; s++ )
  {
    real RuOverMbar = mp.R/reactions.mw(s);

    s1(I1,I2,I3)+=RuOverMbar*sigma(I1,I2,I3,s);        // s1 = sum R_u * sigma_i/mbar_i
    s2(I1,I2,I3)+=hi(I1,I2,I3,s)*sigma(I1,I2,I3,s);      // s2 = sum h_i*sigma_i
    cp(I1,I2,I3)+=cpi(I1,I2,I3,s)*v(I1,I2,I3,s+sc);      // cp = sum cp_i * Y_i 

    r(I1,I2,I3)+=v(I1,I2,I3,s+sc)*RuOverMbar;          // this is R:
  }
  gamma(I1,I2,I3)=cp(I1,I2,I3)/(cp(I1,I2,I3)-r(I1,I2,I3));  // gamma = cp/cv = cp/(cp-R)

  // nondimensionalize:
  cp*=1./(parameters.dbase.get<real >("R0"));
  r *=1./(parameters.dbase.get<real >("R0"));
  
  s1*=parameters.dbase.get<real >("l0")/(parameters.dbase.get<real >("rho0")*parameters.dbase.get<real >("u0")*parameters.dbase.get<real >("R0"));
  s2*=parameters.dbase.get<real >("l0")/(parameters.dbase.get<real >("rho0")*parameters.dbase.get<real >("u0")*parameters.dbase.get<real >("R0")*parameters.dbase.get<real >("te0"));

#endif
}


#define AD2(kd) (  \
        (ad21 + cd22*    \
         ( fabs(UX(uc))+fabs(UY(uc))    \
          +fabs(UX(vc))+fabs(UY(vc)) ) )    \
         *(u(I1+1,I2,I3,kd)-4.*u(I1,I2,I3,kd)+u(I1-1,I2,I3,kd)    \
          +u(I1,I2+1,I3,kd)                  +u(I1,I2-1,I3,kd))    \
                         )    \
                 
//  ---3D:
#define  AD23(kd)  (    \
        (ad21 + cd22*    \
         ( fabs(UX(uc))+fabs(UY(uc))+fabs(UZ(uc))    \
          +fabs(UX(vc))+fabs(UY(vc))+fabs(UZ(vc))    \
          +fabs(UX(wc))+fabs(UY(wc))+fabs(UZ(wc)) ) )    \
         *(u(I1+1,I2,I3,kd)-6.*u(I1,I2,I3,kd)+u(I1-1,I2,I3,kd)    \
          +u(I1,I2+1,I3,kd)                   +u(I1,I2-1,I3,kd)    \
          +u(I1,I2,I3+1,kd)                   +u(I1,I2,I3-1,kd))    \
                            )
                       
//  ---fourth-order artficial diffusion in 2D
#define AD4(kd) (    \
        (ad41 + cd42*    \
         ( fabs(UX(uc))+fabs(UY(uc))    \
          +fabs(UX(vc))+fabs(UY(vc)) ) )    \
         *(   -u(I1+2,I2,I3,kd)-u(I1-2,I2,I3,kd)    \
              -u(I1,I2+2,I3,kd)-u(I1,I2-2,I3,kd)    \
          +4.*(u(I1+1,I2,I3,kd)+u(I1-1,I2,I3,kd)    \
              +u(I1,I2+1,I3,kd)+u(I1,I2-1,I3,kd))    \
           -12.*u(I1,I2,I3,kd) )    \
                         )
//   ---fourth-order artficial diffusion in 3D
#define AD43(kd) (    \
        (ad41 + cd42*    \
         ( fabs(UX(uc))+fabs(UY(uc))+fabs(UZ(uc))    \
          +fabs(UX(vc))+fabs(UY(vc))+fabs(UZ(vc))    \
          +fabs(UX(wc))+fabs(UY(wc))+fabs(UZ(wc)) ) )    \
         *(   -u(I1+2,I2,I3,kd)-u(I1-2,I2,I3,kd)    \
              -u(I1,I2+2,I3,kd)-u(I1,I2-2,I3,kd)    \
              -u(I1,I2,I3+2,kd)-u(I1,I2,I3-2,kd)    \
          +4.*(u(I1+1,I2,I3,kd)+u(I1-1,I2,I3,kd)    \
              +u(I1,I2+1,I3,kd)+u(I1,I2-1,I3,kd)    \
              +u(I1,I2,I3+1,kd)+u(I1,I2,I3-1,kd))    \
           -18.*u(I1,I2,I3,kd) )    \
                          )

int Cgasf::
getUt(const realMappedGridFunction & v, 
      const realMappedGridFunction & gridVelocity_,
      realMappedGridFunction & dvdt, 
      int iparam[], real rparam[],
      realMappedGridFunction & dvdtImplicit /* = Overture::nullRealMappedGridFunction() */,
      MappedGrid *pmg2 /* =NULL */,
      const realMappedGridFunction *pGridVelocity2 /* = NULL */  )
// =======================================================================================================
// /Purpose:
//    determine du/dt 
// /Notes: The variable cImplicit should be set to zero for implicit timeStepping
//
// r_t + u*r_x + r*u_x = nuRho r_xx - nu4 *D4(r)
// u_t + u*u_x + (1/r)p.x = nu u_xx - nu4 *D4(u)
// p_t + u*p_x + gamma*p*u_x = - nu4 *D4(p)
//
// D4 = fourth-order undivided difference
// pressure = (gamma-1)( E -.5 r*u^2 )
// =======================================================================================================
{ 
  real cpu0=getCPU();

  const int & explicitMethod = parameters.dbase.get<int >("explicitMethod");
    

  if( debug() & 2 && explicitMethod )
  {
    printF("Cgasf:getUT: explicitMethod=true\n");
  }

  const real & t=rparam[0];
  real tForce   =rparam[1];
  const real & tImplicit=rparam[2];
  const int & grid = iparam[0];

  AsfParameters & asfParameters = (AsfParameters &)parameters;
  const AsfParameters::AlgorithmVariation & algorithmVariation = 
                  parameters.dbase.get<AsfParameters::AlgorithmVariation>("algorithmVariation");

  const realArray & u = v;
  Index I1,I2,I3;

  const realArray & gridVelocity = gridVelocity_;
  realArray & ut = dvdt;
  realArray & uti = dvdtImplicit;

  const int & numberOfComponents = parameters.dbase.get<int >("numberOfComponents");
  const int & rc = parameters.dbase.get<int >("rc");
  const int & uc = parameters.dbase.get<int >("uc");
  const int & vc = parameters.dbase.get<int >("vc");
  const int & wc = parameters.dbase.get<int >("wc");
  const int & pc = parameters.dbase.get<int >("pc");
  const int & tc = parameters.dbase.get<int >("tc");
  const int & sc = parameters.dbase.get<int >("sc");
  const int & kc = parameters.dbase.get<int >("kc");
  const int & computeReactions = parameters.dbase.get<bool >("computeReactions");
  // const int & numberOfSpecies = parameters.dbase.get<int >("numberOfSpecies");
  const bool & gridIsMoving = parameters.gridIsMoving(grid);

  const Parameters::ImplicitMethod & implicitMethod = 
                   parameters.dbase.get<Parameters::ImplicitMethod >("implicitMethod");
  const Parameters::ImplicitOption & implicitOption = 
                   parameters.dbase.get<Parameters::ImplicitOption >("implicitOption");
  const int & linearizeImplicitMethod = parameters.dbase.get<int >("linearizeImplicitMethod");
  
  // const real & nu = parameters.dbase.get<real >("nu");
  const real & mu = parameters.dbase.get<real >("mu");
  const real & gamma = parameters.dbase.get<real >("gamma");
  const real & kThermal = parameters.dbase.get<real >("kThermal");
  const real & Rg = parameters.dbase.get<real >("Rg");
  // const real & avr = parameters.dbase.get<real >("avr");
  const real & pressureLevel = parameters.dbase.get<real >("pressureLevel");
  const real & nuRho = parameters.dbase.get<real >("nuRho");
  const real & anu = parameters.dbase.get<real >("anu");
  const real & ad21 = parameters.dbase.get<real >("ad21");
  const real & ad22 = parameters.dbase.get<real >("ad22");
  const real & advectionCoefficient = parameters.dbase.get<real >("advectionCoefficient");  
  const ArraySimpleFixed<real,3,1,1,1> & gravity = parameters.dbase.get<ArraySimpleFixed<real,3,1,1,1> >("gravity");
  const Range & Rt = parameters.dbase.get<Range >("Rt");

  const real implicitFactor = (parameters.getGridIsImplicit(grid) 
                          && implicitMethod==Parameters::crankNicolson ) ? .5 : 1.;

  MappedGrid & mg = *(v.getMappedGrid());
  const int isRectangular=mg.isRectangular(); 

  bool useOpt=true; // explicitMethod;
  if( useOpt )
  {
    const bool & gridIsMoving = parameters.gridIsMoving(grid);

    int useWhereMask=false; // **NOTE** for  moving grids we may need to evaluate at more points than just mask >0 

    int *pMask;
    if( pmg2!=NULL )
    {
      // only need to evaluate du/dt at mask>0 in this case -- we have the mask at the new time level
      useWhereMask=true;
#ifdef USE_PPP
      pMask = pmg2->mask().getLocalArray().getDataPointer();
#else
      pMask = pmg2->mask().getDataPointer();
#endif

      // printf(" ***getUtINS: useWhereMask=%i \n",useWhereMask);
    }
    else
    {
#ifdef USE_PPP
      pMask = mg.mask().getLocalArray().getDataPointer(); 
#else
      pMask = mg.mask().getDataPointer();
#endif
    }

    real dx[3]={1.,1.,1.};
    if( isRectangular )
      mg.getDeltaX(dx);
    else
      mg.update(MappedGrid::THEinverseVertexDerivative);
   
    const int orderOfAccuracy=parameters.dbase.get<int >("orderOfAccuracy");
    const int gridType= isRectangular ? 0 : 1;

#ifdef USE_PPP
    realSerialArray uLocal;  getLocalArrayWithGhostBoundaries(u,uLocal);
#else
    const realSerialArray & uLocal = u;
#endif
    const real *pu = u.getDataPointer();

    // For now we need the center array for the axisymmetric case:
    const realArray & xy = parameters.isAxisymmetric() ? mg.center() : u;
    if( parameters.isAxisymmetric() ) 
    {
      assert( mg.center().getLength(0)>0 );
    }
    const realArray & rsxy = isRectangular ? u :  mg.inverseVertexDerivative();
    // For non-moving grids u==uu, otherwise uu is a temp space to hold (u-gv)


    const realArray & dw = parameters.dbase.get<realCompositeGridFunction* >("pDistanceToBoundary")==NULL ? u : 
      (*parameters.dbase.get<realCompositeGridFunction* >("pDistanceToBoundary"))[grid];
    

#ifdef USE_PPP
    const real *pxy = xy.getLocalArray().getDataPointer(); 
    const real *prsxy = rsxy.getLocalArray().getDataPointer(); 
    real *put = ut.getLocalArray().getDataPointer(); 
    real *puti = uti.getLocalArray().getDataPointer(); 
    const real *pgv = gridIsMoving ? gridVelocity.getLocalArray().getDataPointer() : pu;
    const real *pdw = dw.getLocalArray().getDataPointer();

    // prL/ppL points to the linearized rho/p (points to real rho/p if we don't linearize)
    const real *prL = linearizeImplicitMethod ? rL()[grid].getLocalArray().getDataPointer() : 
      &uLocal(uLocal.getBase(0),uLocal.getBase(1),uLocal.getBase(2),rc);
    const real *ppL = linearizeImplicitMethod ? pL()[grid].getLocalArray().getDataPointer(): 
      &uLocal(uLocal.getBase(0),uLocal.getBase(1),uLocal.getBase(2),pc);
#else
    const real *pxy = xy.getDataPointer(); 
    const real *prsxy = rsxy.getDataPointer(); 
    real *put = ut.getDataPointer(); 
    real *puti = uti.getDataPointer(); 
    const real *pgv = gridIsMoving ? gridVelocity.getDataPointer() : pu;
    const real *pdw = dw.getDataPointer();

    const real *prL = linearizeImplicitMethod ? rL()[grid].getDataPointer() : 
      &uLocal(uLocal.getBase(0),uLocal.getBase(1),uLocal.getBase(2),rc);
    const real *ppL = linearizeImplicitMethod ? pL()[grid].getDataPointer(): 
      &uLocal(uLocal.getBase(0),uLocal.getBase(1),uLocal.getBase(2),pc);
#endif 


    getIndex(mg.gridIndexRange(),I1,I2,I3);  // *wdh* 030220  - evaluate du/dt here
    
    int includeGhost=1;
    bool ok=ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);

    if( ok )
    {

      RealArray uw;  // this will hold u-gridVelocity in the moving grid case 
      if( parameters.gridIsMoving(grid) )
	uw.redim(uLocal);

      const RealArray & uuLocal = parameters.gridIsMoving(grid) ? uw : uLocal;
      const real *puu = uuLocal.getDataPointer(); 


      const int gridIsImplicit=parameters.getGridIsImplicit(grid);
      const real adcPassiveScalar=1.; // coeff or linear artificial diffusion for the passive scalar ** add to params

      // only apply fourth-order AD here if it is explicit
      const bool useFourthOrderArtificialDiffusion = 
              parameters.dbase.get<bool >("useFourthOrderArtificialDiffusion") &&
             !parameters.dbase.get<bool >("useImplicitFourthArtificialDiffusion");

      int viscoPlasticOption = 0; // not reall used yet
      int ipar[] ={(int)viscoPlasticOption, // kkc 070131 XXX THIS IS WHERE THE VISCOPLASTIC OPTION WOULD BE TURNED ON!!
                   parameters.dbase.get<Parameters::TurbulenceModel >("turbulenceModel"),
                   orderOfAccuracy,
                   rc,uc,vc,wc,tc,pc,kc,sc,
		   grid,
		   (int)parameters.gridIsMoving(grid),
		   useWhereMask,
		   (int)gridIsImplicit,
		   (int)parameters.dbase.get<int>("explicitMethod"),
		   (int)implicitMethod,
		   (int)implicitOption,
		   (int)parameters.isAxisymmetric(),
		   (int)parameters.dbase.get<bool >("useSecondOrderArtificialDiffusion"),
		   (int)useFourthOrderArtificialDiffusion,
		   (int)parameters.dbase.get<bool >("advectPassiveScalar"),
		   gridType,
                   linearizeImplicitMethod }; //
		   
      const real yEps=sqrt(REAL_EPSILON);  // tol for axisymmetric *** fix this ***
      real rpar[]={mg.gridSpacing(0),mg.gridSpacing(1),mg.gridSpacing(2),
		   dx[0],dx[1],dx[2],
		   parameters.dbase.get<real >("ad21"),
		   parameters.dbase.get<real >("ad22"),
		   parameters.dbase.get<real >("ad41"),
		   parameters.dbase.get<real >("ad42"),
		   parameters.dbase.get<real >("nuPassiveScalar"),
		   adcPassiveScalar,
		   parameters.dbase.get<real >("ad21n"),
		   parameters.dbase.get<real >("ad22n"),
		   parameters.dbase.get<real >("ad41n"),
		   parameters.dbase.get<real >("ad42n"),
		   yEps,                    // 17
		   parameters.dbase.get<ArraySimpleFixed<real,3,1,1,1> >("gravity")[0],
		   parameters.dbase.get<ArraySimpleFixed<real,3,1,1,1> >("gravity")[1],
		   parameters.dbase.get<ArraySimpleFixed<real,3,1,1,1> >("gravity")[2],
		   parameters.dbase.get<real >("mu"),
		   parameters.dbase.get<real >("kThermal"),
		   parameters.dbase.get<real >("gamma"),
		   parameters.dbase.get<real >("Rg"),
		   parameters.dbase.get<real >("nuRho"),
                   pressureLevel };

      int ierr=0;

      asfdt(mg.numberOfDimensions(),
	    I1.getBase(),I1.getBound(),
	    I2.getBase(),I2.getBound(),
	    I3.getBase(),I3.getBound(),
	    uLocal.getBase(0),uLocal.getBound(0),uLocal.getBase(1),uLocal.getBound(1),
	    uLocal.getBase(2),uLocal.getBound(2),uLocal.getBase(3),uLocal.getBound(3),
	    *pMask, *pxy, *prsxy,
	    *pu, *puu, *put, *puti,*prL,*ppL, *pgv, *pdw,
	    *mg.boundaryCondition().getDataPointer(), ipar[0], rpar[0], ierr );

    
    }
  }
  else
  {
    // -- old way --

#ifdef USE_PPP
    Overture::abort("Error- fix this Bill --> reactions ");
#else

    getIndex(mg.extendedIndexRange(),I1,I2,I3);

    const real a43 = 4./3.;
    const real a13 = 1./3.;

    // if( debug() &1 ) printF("asf: algorithmVariation=%i, nuRho=%g\n",(int)algorithmVariation,nuRho);


    assert( ( mu>0. && kThermal>0.) || ( mu==0. && kThermal==0.) );

    Range N = parameters.dbase.get<Range >("Rt");

    realArray uu(I1,I2,I3,parameters.dbase.get<Range >("Ru"));

    MappedGridOperators & op = *(v.getOperators());

    realArray ux(I1,I2,I3,N), uxx(I1,I2,I3,N), uy,uz;
    op.derivative(MappedGridOperators::xDerivative ,u,ux ,I1,I2,I3,N);  
    op.derivative(MappedGridOperators::xxDerivative,u,uxx,I1,I2,I3,N);  


//  MappedGridOperators & operators = *(v.getOperators());
//  operators.getDerivatives(v,I1,I2,I3,N);

    // realArray & phi = get(WorkSpace::phi);
    realArray phi(I1,I2,I3);

    if( mg.numberOfDimensions()==1 )
    {
      if( parameters.isMovingGridProblem() )
	uu(I1,I2,I3,uc)=gridVelocity(I1,I2,I3,0)-advectionCoefficient*u(I1,I2,I3,uc);
      else
	uu(I1,I2,I3,uc)=(-advectionCoefficient)*u(I1,I2,I3,uc);

      ut(I1,I2,I3,rc)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,rc) -u(I1,I2,I3,rc)*ux(I1,I2,I3,uc) +nuRho*uxx(I1,I2,I3,rc);     
      ut(I1,I2,I3,uc)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,uc);
      ut(I1,I2,I3,pc)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,pc);
      if( !parameters.dbase.get<bool >("computeReactions") )
	ut(I1,I2,I3,tc)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,tc)- (gamma-1.)*u(I1,I2,I3,tc)*(ux(I1,I2,I3,uc));
      else
	ut(I1,I2,I3,tc)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,tc); // gamma term added later

      if( mu>0. && !parameters.dbase.get<bool >("computeReactions") )
      { // note that we assume that mu>0 iff kThermal>0
	ut(I1,I2,I3,uc)+=(mu/U(rc))*(a43*UXX(uc)); 
	phi(I1,I2,I3)=(4./3.)*mu*( SQR(ux(I1,I2,I3,uc)) );
	ut(I1,I2,I3,pc)+= ((gamma-1.)*kThermal*Rg)*(uxx(I1,I2,I3,tc))+  (gamma-1.)*phi(I1,I2,I3) ; 
	ut(I1,I2,I3,tc)+= ((gamma-1.)/u(I1,I2,I3,rc))*( kThermal*uxx(I1,I2,I3,tc)	+ (1./Rg)*phi(I1,I2,I3) );

      }
    
      if( explicitMethod )
      {  // explicit, add in "fast" terms
	ut(I1,I2,I3,uc)-=ux(I1,I2,I3,pc)/u(I1,I2,I3,rc);
	if( !parameters.dbase.get<bool >("computeReactions") )
	  ut(I1,I2,I3,pc)+=(-gamma)*(u(I1,I2,I3,pc)+pressureLevel)*ux(I1,I2,I3,uc);  // **** fix gamma for species
      }
      else if( linearizeImplicitMethod )
      { // (rL,pL) contain the linearized state
	ut(I1,I2,I3,uc)+=ux(I1,I2,I3,pc)*(1./rL()[grid](I1,I2,I3)- 1./u(I1,I2,I3,rc)); // ***** ??? ****
	if( !parameters.dbase.get<bool >("computeReactions") )
	  ut(I1,I2,I3,pc)+=gamma*(pL()[grid](I1,I2,I3)-u(I1,I2,I3,pc))*ux(I1,I2,I3,uc);
      }


      if( computeReactions )
      {
	assert( parameters.dbase.get<Reactions* >("reactions")!=NULL );
	Reactions & reactions = *(parameters.dbase.get<Reactions* >("reactions"));
      
	// first compute some thermodynamic quantities needed for the p and T equations
	realArray s1(I1,I2,I3), s2(I1,I2,I3), cp(I1,I2,I3), r(I1,I2,I3);
	computeSource( I1,I2,I3, u, s1,s2,gam()[grid](I1,I2,I3),cp,r );


	const real & R0 =parameters.dbase.get<real >("R0");
	const real & P0 =parameters.dbase.get<real >("pStatic")/parameters.dbase.get<real >("p0");    

	Index I1g,I2g,I3g;
	getIndex(mg.extendedIndexRange(),I1g,I2g,I3g,1); // include ghost points so we can compute derivatives

	const int & numberOfSpecies = parameters.dbase.get<int >("numberOfSpecies");
	Range S0(0,numberOfSpecies-1);
	Range S(sc,sc+numberOfSpecies-1);

	// const realArray & x = moleFraction()(I1g,I2g,I3g,S0);    
	realArray x(I1g,I2g,I3g,S0);    

	Range Tn(0,numberOfSpecies+2 -1);
	// realArray & tranCoeff = transportCoefficients();        // holds viscosity and diffusion coefficients
	realArray tranCoeff(I1g,I2g,I3g,Tn);

	const realArray & te = u(I1g,I2g,I3g,tc);  
	const realArray & pe = u(I1g,I2g,I3g,pc);
      
	const int etac=0, lambdac=1;
	reactions.massFractionToMoleFraction(u(I1g,I2g,I3g,S),x);  
	reactions.viscosity(te,x,tranCoeff(I1g,I2g,I3g,etac) );  // uses mole fractions, eta is scaled

	reactions.thermalConductivity(te,x,tranCoeff(I1g,I2g,I3g,lambdac));

	reactions.diffusion(pe,te,x,tranCoeff(I1g,I2g,I3g,S0+2));

	// transportCoefficients().getDerivatives(I1,I2,I3,Tn);
	realArray transportCoefficientsX(I1,I2,I3,Tn);
	op.derivative(MappedGridOperators::xDerivative ,tranCoeff,transportCoefficientsX ,I1,I2,I3,Tn); 

//      realArray & transportCoefficientsX = get(WorkSpace::transportCoefficientsX);

	const RealArray & eta     = tranCoeff(I1,I2,I3,etac);
	const RealArray & etaX    = transportCoefficientsX(I1,I2,I3,etac);
	const RealArray & lambda  = tranCoeff(I1,I2,I3,lambdac);
	const RealArray & lambdaX = transportCoefficientsX(I1,I2,I3,lambdac);

	if( debug() & 4 )
	{
	  display(ut(I1,I2,I3,rc),"\n rho.t:",parameters.dbase.get<FILE* >("debugFile"));
	  display(gam()[grid],"\ngamma:",parameters.dbase.get<FILE* >("debugFile"));
	  display(x,"\nmole fractions:",parameters.dbase.get<FILE* >("debugFile"));
	  display(eta,"\nviscosity eta:",parameters.dbase.get<FILE* >("debugFile"));
	  display(lambda,"\nthermal conductivity, lambda:",parameters.dbase.get<FILE* >("debugFile"));
	  display(lambdaX,"\nlambdaX:",parameters.dbase.get<FILE* >("debugFile"));
	  display(evaluate(eta*cp/lambda),"\nPrandtl: eta/(lambda/cp) ",parameters.dbase.get<FILE* >("debugFile"));
	  display(tranCoeff(I1,I2,I3,S0+2),"species diffusion coefficients:",parameters.dbase.get<FILE* >("debugFile"));

	  fprintf(parameters.dbase.get<FILE* >("debugFile")," ***** R0 =% e, P0=%e \n",R0,P0);
	  display(evaluate(s1*P0),"\ns1*P0 source term:",parameters.dbase.get<FILE* >("debugFile"));
	  display(evaluate(s2*P0),"\ns2*P0 source term:",parameters.dbase.get<FILE* >("debugFile"));
	}
      


	// *wdh* 991016 ut(I1,I2,I3,uc)+=eta*(a43*(UXX(uc)+etaX*ux(I1,I2,I3,uc)))/u(I1,I2,I3,rc);
	ut(I1,I2,I3,uc)+=(a43*(eta*UXX(uc)+etaX*ux(I1,I2,I3,uc)))/u(I1,I2,I3,rc);
	// add phi term to T equation
	phi(I1,I2,I3)=(4./3.)*eta*( SQR(ux(I1,I2,I3,uc)) );
	if( reactions.getPressureIsConstant() )
	{
	  // use cp version of the T equation
	  ut(I1,I2,I3,tc)+= (
	    lambda*uxx(I1,I2,I3,tc)+lambdaX*ux(I1,I2,I3,tc) //  *** + (1./P0)*phi(I1,I2,I3)  // **** more stuff here ***
	    )/( u(I1,I2,I3,rc)*cp(I1,I2,I3) );      
	}
	else
	{
	  ut(I1,I2,I3,tc)+= -(gam()[grid](I1,I2,I3)-1.)*u(I1,I2,I3,tc)*ux(I1,I2,I3,uc)
	    + (1./( (cp(I1,I2,I3)-r(I1,I2,I3))*u(I1,I2,I3,rc) ))*( 
	      lambda*uxx(I1,I2,I3,tc)+lambdaX*ux(I1,I2,I3,tc) + (1./P0)*phi(I1,I2,I3)   // **** more stuff here ***
	      );     
	}
      


	if( FALSE && !( reactions.getPressureIsConstant()) )
	{
	  real pFactor=1.;
	  ut(I1,I2,I3,pc)+= P0*(
            pFactor*( gam()[grid](I1,I2,I3)*u(I1,I2,I3,tc)*s1(I1,I2,I3)-(gam()[grid](I1,I2,I3)-1.)*s2(I1,I2,I3) )
	    //  + (gam()[grid](I1,I2,I3)-1.)*(lambda*uxx(I1,I2,I3,tc)+lambdaX*ux(I1,I2,I3,tc))   // more here ************
	    ) + (gam()[grid](I1,I2,I3)-1.)*phi(I1,I2,I3);
	}

	if( explicitMethod )
	{  // explicit, add in "fast" terms
	  ut(I1,I2,I3,pc)+=(-gam()[grid](I1,I2,I3))*(u(I1,I2,I3,pc)+pressureLevel)*ux(I1,I2,I3,uc);  // **** fix gamma for species
	}
	else if( linearizeImplicitMethod )
	{ // (rL,pL) contain the linearized state
	  ut(I1,I2,I3,pc)+=gam()[grid](I1,I2,I3)*(pL()[grid](I1,I2,I3)-u(I1,I2,I3,pc))*ux(I1,I2,I3,uc);
	}

	// ***************************
	// **** Species equations ****
	// ***************************
	int s;
	for( s=sc; s<sc+numberOfSpecies; s++ )
	  ut(I1,I2,I3,s)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,s);

	
	// diffusion (1/rho) \div ( b \grad X_s ) = a * \div\grad( X_s ) + (1\over rho) (\grad b) . (\grad X_s)

	realArray dCoeff(I1g,I2g,I3g,S0), dCoeffx(I1g,I2g,I3g,S0), molex(I1,I2,I3,S0), molexx(I1,I2,I3,S0);
	op.derivative(MappedGridOperators::xDerivative,dCoeff,dCoeffx ,I1,I2,I3,S0);
	op.derivative(MappedGridOperators::xDerivative,x,molex,I1,I2,I3,S0);
	op.derivative(MappedGridOperators::xxDerivative,x,molexx,I1,I2,I3,S0);

	dCoeff(I1g,I2g,I3g,S0) = u(I1g,I2g,I3g,S)*tranCoeff(I1g,I2g,I3g,S0+2)/x(I1g,I2g,I3g,S0); // Y_i D_i / X_i
	
	ut(I1,I2,I3,S)+=dCoeff(I1,I2,I3,S0)*molexx(I1,I2,I3,S0);

	for( s=0; s<numberOfSpecies; s++ )
	  dCoeff(I1g,I2g,I3g,s) *= u(I1g,I2g,I3g,rc);
	dCoeff(I1,I2,I3,S0) = dCoeffx(I1,I2,I3,S0);  // ( rho Y_i D_i / X_i ).x
	for( s=0; s<numberOfSpecies; s++ )
	  dCoeff(I1,I2,I3,s)/=u(I1,I2,I3,rc);
	
	ut(I1,I2,I3,S)+= dCoeff(I1,I2,I3,S0)*molex(I1,I2,I3,S0);

//	ut(I1,I2,I3,s)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,s) 
//	  + tranCoeff(I1,I2,I3,s-sc+2)*uxx(I1,I2,I3,s) + tranX(I1,I2,I3,s-sc+2)*ux(I1,I2,I3,s); // **** fix grad(X)
      }
      if( anu>0. )
      { // add nonlinear artificial dissipation --- do these scale right??
	for( int n=Rt.getBase(); n<=Rt.getBound(); n++ )
	{
	  ut(I1,I2,I3,n)+= anu*(1.+fabs(ux(I1,I2,I3,n)))*(u(I1+1,I2,I3,n)+u(I1-1,I2,I3,n)-2.*u(I1,I2,I3,n));
	}
      }


    }  
    else if( mg.numberOfDimensions()==2 )
    {
      // ****************************************
      // ************* 2D ***********************
      // ****************************************

      uy.redim(I1,I2,I3,N);
    
      realArray uxy(I1,I2,I3,N), uyy(I1,I2,I3,N);
      op.derivative(MappedGridOperators::yDerivative ,u,uy ,I1,I2,I3,N);  
      op.derivative(MappedGridOperators::xyDerivative,u,uxy,I1,I2,I3,N);  
      op.derivative(MappedGridOperators::yyDerivative,u,uyy,I1,I2,I3,N);  

      const realArray & rho =  u(I1,I2,I3,rc);
      const realArray & rhoInverse =  evaluate( 1./rho );
      const realArray & u0  =   u(I1,I2,I3,uc);
      const realArray & u0x =  ux(I1,I2,I3,uc);
      const realArray & u0y =  uy(I1,I2,I3,uc);
//  const realArray & u0xx= uxx(I1,I2,I3,uc);
//  const realArray & u0yy= uyy(I1,I2,I3,uc);

      const realArray & v0  =   u(I1,I2,I3,vc);
      const realArray & v0x =  ux(I1,I2,I3,vc);
      const realArray & v0y =  uy(I1,I2,I3,vc);

      const realArray & te  =   u(I1,I2,I3,tc);
      const realArray & div = evaluate( u0x+v0y );

      if( gridIsMoving )
      {
	uu(I1,I2,I3,uc)=gridVelocity(I1,I2,I3,0)-advectionCoefficient*u0;
	uu(I1,I2,I3,vc)=gridVelocity(I1,I2,I3,1)-advectionCoefficient*v0;
      }
      else
      {
	uu(I1,I2,I3,uc)=(-advectionCoefficient)*u0;
	uu(I1,I2,I3,vc)=(-advectionCoefficient)*v0;
      }

      const realArray & ugv       =  uu(I1,I2,I3,uc);   // gridVelocity - u
      const realArray & vgv       =  uu(I1,I2,I3,vc);

      if( algorithmVariation==AsfParameters::defaultAlgorithm )
      {
	ut(I1,I2,I3,rc)=uu(I1,I2,I3,uc)*ux(I1,I2,I3,rc)+uu(I1,I2,I3,vc)*uy(I1,I2,I3,rc)
	  -( u(I1,I2,I3,rc)*(ux(I1,I2,I3,uc)+uy(I1,I2,I3,vc)) );

	if( nuRho>0. )
	  ut(I1,I2,I3,rc)+=nuRho*(uxx(I1,I2,I3,rc)+uyy(I1,I2,I3,rc));
      }
      else
      {
	ut(I1,I2,I3,rc)=div;  // save div **************************************************************
      }
    
      ut(I1,I2,I3,uc)=ugv*u0x+vgv*u0y;
      ut(I1,I2,I3,vc)=ugv*v0x+vgv*v0y;

      ut(I1,I2,I3,pc)=ugv*ux(I1,I2,I3,pc)+vgv*uy(I1,I2,I3,pc);

      ut(I1,I2,I3,tc)=ugv*ux(I1,I2,I3,tc)+vgv*uy(I1,I2,I3,tc) - (gamma-1.)*te*div;
//    ut(I1,I2,I3,tc)=ugv*ux(I1,I2,I3,tc)+vgv*uy(I1,I2,I3,tc);

    
      // save   ut(rc) = div( \uv.t ) 
//    ut(I1,I2,I3,rc)=ugv*(UXX(uc)+UXY(vc))+vgv*(UXY(uc)+UYY(vc))
//        -( u0x*u0x +2.*v0x*u0y  +v0y*v0y );  // need to add div( mu ... )


      if( mu>0. )
      { // note that we assume that mu>0 iff kThermal>0
	const RealArray & muOverRho = evaluate( (implicitFactor*mu)*rhoInverse );
	const RealArray & phi =evaluate( (4./3.)*( SQR(u0x)-u0x*v0y +SQR(v0y) ) +SQR(v0x+u0y) );
	const RealArray & lapT = evaluate( (implicitFactor*(gamma-1.)*kThermal)*(uxx(I1,I2,I3,tc)+uyy(I1,I2,I3,tc)) );

	if( parameters.getGridIsImplicit(grid) && implicitOption==Parameters::computeImplicitTermsSeparately )
	{
	  uti(I1,I2,I3,uc)=muOverRho*(a43*UXX(uc)+UYY(uc)+a13*UXY(vc));
	  uti(I1,I2,I3,vc)=muOverRho*(UXX(vc)+a43*UYY(vc)+a13*UXY(uc)); 
	
	  uti(I1,I2,I3,tc)=rhoInverse*( lapT + ((gamma-1.)*mu/Rg)*phi );
	  uti(I1,I2,I3,pc)= Rg*lapT +((gamma-1.)*mu)*phi;
	}
	else
	{
	  ut(I1,I2,I3,uc)+=muOverRho*(a43*UXX(uc)+UYY(uc)+a13*UXY(vc));  // nu*(uxx(I1,I2,I3,uc)+uyy(I1,I2,I3,uc));
	  ut(I1,I2,I3,vc)+=muOverRho*(UXX(vc)+a43*UYY(vc)+a13*UXY(uc));  // nu*(uxx(I1,I2,I3,vc)+uyy(I1,I2,I3,vc));
	  ut(I1,I2,I3,tc)+=rhoInverse*( lapT + ((gamma-1.)*mu/Rg)*phi );
	  ut(I1,I2,I3,pc)+= Rg*lapT +((gamma-1.)*mu)*phi;
	}

      }

      if( parameters.dbase.get<bool >("useSecondOrderArtificialDiffusion") && (ad21!=0. || ad22!=0.) )
      { // --- add 2nd order artificial diffusion
	real cd22=ad22/SQR(mg.numberOfDimensions());
	ut(I1,I2,I3,uc)+=AD2(uc);
	ut(I1,I2,I3,vc)+=AD2(vc);
      
      }

      if( anu>0. )
      { // add nonlinear artificial dissipation --- do these scale right??
	for( int n=Rt.getBase(); n<=Rt.getBound(); n++ )
	{
	  // skip rho except for the default algorithm
	  if( n==rc && algorithmVariation!=AsfParameters::defaultAlgorithm ) continue;
	  ut(I1,I2,I3,n)+= anu*(1.+fabs(ux(I1,I2,I3,n))+fabs(uy(I1,I2,I3,n)))
	    *(u(I1+1,I2,I3,n)+u(I1-1,I2,I3,n)+u(I1,I2+1,I3,n)+u(I1,I2-1,I3,n)-4.*u(I1,I2,I3,n));
	}
      }
    
      if( explicitMethod )
      {  // explicit, add in "fast" terms
	ut(I1,I2,I3,uc)-=ux(I1,I2,I3,pc)*rhoInverse;
	ut(I1,I2,I3,vc)-=uy(I1,I2,I3,pc)*rhoInverse;
	ut(I1,I2,I3,pc)+=(-gamma)*(u(I1,I2,I3,pc)+pressureLevel)*div;
      }
      else if( linearizeImplicitMethod )
      {
	const RealArray & rhoInverseDiff = evaluate( 1./rL()[grid](I1,I2,I3)- rhoInverse );
	ut(I1,I2,I3,uc)+=ux(I1,I2,I3,pc)*rhoInverseDiff;
	ut(I1,I2,I3,vc)+=uy(I1,I2,I3,pc)*rhoInverseDiff;
	ut(I1,I2,I3,pc)+=gamma*(pL()[grid](I1,I2,I3)-u(I1,I2,I3,pc))*div;
      }

      // Species equations
      if( parameters.dbase.get<int >("numberOfSpecies")>0 )
      {
	int s;
	for( s=sc; s<sc+parameters.dbase.get<int >("numberOfSpecies"); s++ )
	{
	  ut(I1,I2,I3,s)=ugv*ux(I1,I2,I3,s)+vgv*uy(I1,I2,I3,s);
	}
	if( mu>0. )
	{
	  // this is only approximate
	  real turbulentSchmidtNumber=.9;
	  const RealArray & muOverRho = evaluate( (turbulentSchmidtNumber*mu)*rhoInverse );
	  for( s=sc; s<sc+parameters.dbase.get<int >("numberOfSpecies"); s++ )
	  {
	    ut(I1,I2,I3,s)+=muOverRho*( UXX(sc) + UYY(sc) );
	  }
      
	}
      
      }

    }
    else if( mg.numberOfDimensions()==3 )
    {
      // ***** 3D ******
      uy.redim(I1,I2,I3,N);
      uz.redim(I1,I2,I3,N);
    
      realArray uy(I1,I2,I3,N), uxy(I1,I2,I3,N), uyy(I1,I2,I3,N);
      realArray uxz(I1,I2,I3,N), uyz(I1,I2,I3,N), uzz(I1,I2,I3,N);

      op.derivative(MappedGridOperators::yDerivative ,u,uy ,I1,I2,I3,N);  
      op.derivative(MappedGridOperators::xyDerivative,u,uxy,I1,I2,I3,N);  
      op.derivative(MappedGridOperators::yyDerivative,u,uyy,I1,I2,I3,N);

      op.derivative(MappedGridOperators::zDerivative ,u,uz ,I1,I2,I3,N);  
      op.derivative(MappedGridOperators::xzDerivative,u,uxz,I1,I2,I3,N);  
      op.derivative(MappedGridOperators::yzDerivative,u,uyz,I1,I2,I3,N); 
      op.derivative(MappedGridOperators::zzDerivative,u,uzz,I1,I2,I3,N); 

      const realArray & rho =  u(I1,I2,I3,rc);
      const realArray & rhoInverse =  evaluate( 1./rho );
      const realArray & u0  =  u(I1,I2,I3,uc);
      const realArray & u0x = ux(I1,I2,I3,uc);
      const realArray & u0y = uy(I1,I2,I3,uc);
      const realArray & u0z = uz(I1,I2,I3,uc);

      const realArray & v0  =  u(I1,I2,I3,vc);
      const realArray & v0x = ux(I1,I2,I3,vc);
      const realArray & v0y = uy(I1,I2,I3,vc);
      const realArray & v0z = uz(I1,I2,I3,vc);

      const realArray & w0  =  u(I1,I2,I3,wc);
      const realArray & w0x = ux(I1,I2,I3,wc);
      const realArray & w0y = uy(I1,I2,I3,wc);
      const realArray & w0z = uz(I1,I2,I3,wc);

      const realArray & te  =  u(I1,I2,I3,tc);
      const realArray & t0x = ux(I1,I2,I3,tc);
      const realArray & t0y = uy(I1,I2,I3,tc);
      const realArray & t0z = uz(I1,I2,I3,tc);

      const realArray & p0  =  u(I1,I2,I3,pc);
      const realArray & p0x = ux(I1,I2,I3,pc);
      const realArray & p0y = uy(I1,I2,I3,pc);
      const realArray & p0z = uz(I1,I2,I3,pc);

      const realArray & div = evaluate( u0x+v0y+w0z );

      if( gridIsMoving )
      {
	uu(I1,I2,I3,uc)=gridVelocity(I1,I2,I3,0)-advectionCoefficient*u0;
	uu(I1,I2,I3,vc)=gridVelocity(I1,I2,I3,1)-advectionCoefficient*v0;
	uu(I1,I2,I3,wc)=gridVelocity(I1,I2,I3,2)-advectionCoefficient*w0;
      }
      else
      {
	uu(I1,I2,I3,uc)=(-advectionCoefficient)*u0;
	uu(I1,I2,I3,vc)=(-advectionCoefficient)*v0;
	uu(I1,I2,I3,wc)=(-advectionCoefficient)*w0;
      }

      const realArray & ugv = uu(I1,I2,I3,uc);   // gridVelocity - u
      const realArray & vgv = uu(I1,I2,I3,vc);
      const realArray & wgv = uu(I1,I2,I3,wc);

      if( algorithmVariation==AsfParameters::defaultAlgorithm )
      {
	ut(I1,I2,I3,rc)=   ugv*ux(I1,I2,I3,rc)
	                  +vgv*uy(I1,I2,I3,rc)
	                  +wgv*uz(I1,I2,I3,rc)
	                  -u(I1,I2,I3,rc)*div; 
	if( nuRho>0. )
	  ut(I1,I2,I3,rc)+=nuRho*(uxx(I1,I2,I3,rc)+uyy(I1,I2,I3,rc)+uzz(I1,I2,I3,rc));     
      }
    
      ut(I1,I2,I3,uc)=ugv*u0x+vgv*u0y+wgv*u0z;
      ut(I1,I2,I3,vc)=ugv*v0x+vgv*v0y+wgv*v0z;
      ut(I1,I2,I3,wc)=ugv*w0x+vgv*w0y+wgv*w0z;
      ut(I1,I2,I3,pc)=ugv*p0x+vgv*p0y+wgv*p0z;
      ut(I1,I2,I3,tc)=ugv*t0x+vgv*t0y+wgv*t0z  - (gamma-1.)*te*div;
    
      if( mu>0. )
      { // note that we assume that mu>0 iff kThermal>0
	const RealArray & muOverRho = evaluate( (implicitFactor*mu)*rhoInverse );
//	phi(I1,I2,I3)=mu*( a43*( UX(uc)*(UX(uc)-UY(vc)) + UY(vc)*(UY(vc)-UZ(wc))+SQR(UZ(wc)) )
//			   +   2.*( UY(uc)*UX(vc)+UZ(uc)*UX(wc) + UZ(vc)*UY(wc))
//			   + SQR(UY(uc))+SQR(UZ(uc))+SQR(UX(vc))
//			   + SQR(UZ(vc))+SQR(UX(wc))+SQR(UY(wc)) );
	const RealArray & phi =evaluate( 
	  mu*( a43*( u0x*(u0x-v0y) + v0y*(v0y-w0z)+SQR(w0z) )
	       +   2.*( u0y*v0x+u0z*w0x + v0z*w0y)
	       + SQR(u0y)+SQR(u0z)+SQR(v0x) + SQR(v0z)+SQR(w0x)+SQR(w0y) ) );
      
	const RealArray & lapT = evaluate( (implicitFactor*(gamma-1.)*kThermal)
					   *(uxx(I1,I2,I3,tc)+uyy(I1,I2,I3,tc)+uzz(I1,I2,I3,tc)) );

	if( parameters.getGridIsImplicit(grid) && implicitOption==Parameters::computeImplicitTermsSeparately )
	{
	  uti(I1,I2,I3,uc)=muOverRho*(a43*UXX(uc)+UYY(uc)+UZZ(uc)+a13*(UXY(vc)+UXZ(wc)));
	  uti(I1,I2,I3,vc)=muOverRho*(UXX(vc)+a43*UYY(vc)+UZZ(vc)+a13*(UXY(uc)+UYZ(wc)));
	  uti(I1,I2,I3,wc)=muOverRho*(UXX(wc)+UYY(wc)+a43*UZZ(wc)+a13*(UXZ(uc)+UYZ(vc)));
	  uti(I1,I2,I3,pc)=Rg*lapT +(gamma-1.)*phi;
	  uti(I1,I2,I3,tc)=rhoInverse*( lapT + ((gamma-1.)/Rg)*phi );
	}
	else
	{
	  ut(I1,I2,I3,uc)+=muOverRho*(a43*UXX(uc)+UYY(uc)+UZZ(uc)+a13*(UXY(vc)+UXZ(wc)));
	  ut(I1,I2,I3,vc)+=muOverRho*(UXX(vc)+a43*UYY(vc)+UZZ(vc)+a13*(UXY(uc)+UYZ(wc)));
	  ut(I1,I2,I3,wc)+=muOverRho*(UXX(wc)+UYY(wc)+a43*UZZ(wc)+a13*(UXZ(uc)+UYZ(vc)));
	  ut(I1,I2,I3,pc)+=Rg*lapT +(gamma-1.)*phi;
	  ut(I1,I2,I3,tc)+=rhoInverse*( lapT + ((gamma-1.)/Rg)*phi );
	}
      
      }

      if( anu>0. )
      { // add nonlinear artificial dissipation --- do these scale right??
	for( int n=Rt.getBase(); n<=Rt.getBound(); n++ )
	{
	  ut(I1,I2,I3,n)+= anu*(1.+fabs(ux(I1,I2,I3,n))+fabs(uy(I1,I2,I3,n))+fabs(uz(I1,I2,I3,n)))
	    *(u(I1+1,I2,I3,n)+u(I1-1,I2,I3,n)
	      +u(I1,I2+1,I3,n)+u(I1,I2-1,I3,n)
	      +u(I1,I2,I3+1,n)+u(I1,I2,I3-1,n) -6.*u(I1,I2,I3,n));
	}
      }
    
      if( explicitMethod )
      {  // explicit, add in "fast" terms
	ut(I1,I2,I3,uc)-=ux(I1,I2,I3,pc)*rhoInverse;
	ut(I1,I2,I3,vc)-=uy(I1,I2,I3,pc)*rhoInverse;
	ut(I1,I2,I3,wc)-=uz(I1,I2,I3,pc)*rhoInverse;
	ut(I1,I2,I3,pc)+=(-gamma)*(u(I1,I2,I3,pc)+pressureLevel)*div;
      }
      else if( linearizeImplicitMethod )
      {
	const RealArray & rhoInverseDiff = evaluate( 1./rL()[grid](I1,I2,I3)- rhoInverse );
	ut(I1,I2,I3,uc)+=ux(I1,I2,I3,pc)*rhoInverseDiff;
	ut(I1,I2,I3,vc)+=uy(I1,I2,I3,pc)*rhoInverseDiff;
	ut(I1,I2,I3,wc)+=uz(I1,I2,I3,pc)*rhoInverseDiff;
	ut(I1,I2,I3,pc)+=gamma*(pL()[grid](I1,I2,I3)-u(I1,I2,I3,pc))*div;
      }
    }
  
    // add gravity if it is on.
    int axis;
    for( axis=0; axis<mg.numberOfDimensions(); axis++ )
    {
      if( gravity[axis]!=0. )
	ut(I1,I2,I3,uc+axis)+= gravity[axis];
    }
    

    // add 4th order dissipation 
    if( FALSE && parameters.dbase.get<real >("ad41")>0. )
    {
      real nu4=parameters.dbase.get<real >("ad41");                              // *********************************
      for( int n=0; n<numberOfComponents; n++ )    
	ut(I1,I2,I3,n)+= nu4*(-6.*u(I1,I2,I3,n)+4.*(u(I1-1,I2,I3,n)+u(I1+1,I2,I3,n))
			      -((u(I1-2,I2,I3,n)+u(I1+2,I2,I3,n))));
      if( mg.numberOfDimensions()>1 )
      {
	for( int n=0; n<numberOfComponents; n++ )    
	  ut(I1,I2,I3,n)+= nu4*(-6.*u(I1,I2,I3,n)+4.*(u(I1,I2-1,I3,n)+u(I1,I2+1,I3,n))
				-((u(I1,I2-2,I3,n)+u(I1,I2+2,I3,n))));
      }
      if( mg.numberOfDimensions()>2 )
      {
	for( int n=0; n<numberOfComponents; n++ )    
	  ut(I1,I2,I3,n)+= nu4*(-6.*u(I1,I2,I3,n)+4.*(u(I1,I2,I3-1,n)+u(I1,I2,I3+1,n))
				-((u(I1,I2,I3-2,n)+u(I1,I2,I3+2,n))));
      }
    }

    // ----- special boundary conditions  ------
    mg.update(MappedGrid::THEvertexBoundaryNormal);
  
    for( axis=0; axis<mg.numberOfDimensions(); axis++ )
    {
      for( int side=0; side<=1; side++ )
      {
	if( mg.boundaryCondition(side,axis)==AsfParameters::convectiveOutflow )
	{
	  printf("**** asf: apply convectiveOutflow BC ***** \n");
	
	  const realArray & normal = mg.vertexBoundaryNormal(side,axis);
	
	  real uNormal=.5;

	  getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
	  if( mg.numberOfDimensions()==1 )
	  {
	    for( int n=0; n<numberOfComponents; n++ )  
	      ut(I1,I2,I3,n)=(-uNormal)*normal(I1,I2,I3,0)*ux(I1,I2,I3,n);
	  }
	  else if( mg.numberOfDimensions()==2 )
	  {
	    for( int n=0; n<numberOfComponents; n++ )  
	      ut(I1,I2,I3,n)=(-uNormal)*(normal(I1,I2,I3,0)*ux(I1,I2,I3,n)+normal(I1,I2,I3,1)*uy(I1,I2,I3,n));
	  }
	  else if( mg.numberOfDimensions()==3 )
	  {
	    for( int n=0; n<numberOfComponents; n++ )  
	      ut(I1,I2,I3,n)=(-uNormal)*(normal(I1,I2,I3,0)*ux(I1,I2,I3,n)+normal(I1,I2,I3,1)*uy(I1,I2,I3,n)+
					 normal(I1,I2,I3,2)*uz(I1,I2,I3,n));
	  }
	}
      }
    }
#endif    
  }
  

  if( useOpt )  // ********* fix this ************************
  {
    // ----- special boundary conditions  ------

    bool isRectangular=false;  // do this for now so   -- fix this below --
     
    mg.update(MappedGrid::THEvertexBoundaryNormal);
    Range N = parameters.dbase.get<Range >("Rt");
    MappedGridOperators & op = *(v.getOperators());
  
    getLocalRealArray(u,uLocal);
    getLocalRealArray(ut,utLocal);
    
    for( int axis=0; axis<mg.numberOfDimensions(); axis++ )
    {
      for( int side=0; side<=1; side++ )
      {
	if( mg.boundaryCondition(side,axis)==AsfParameters::convectiveOutflow )
	{
	  if( debug() & 4 ) printF("**** asf: apply convectiveOutflow BC ***** \n");
	
	  getBoundaryIndex(mg.gridIndexRange(),side,axis,I1,I2,I3);
          int includeGhost=1;
          bool ok = ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);
	  if( !ok ) continue;

	  #ifdef USE_PPP
            const realSerialArray & normal = !isRectangular ? mg.vertexBoundaryNormalArray(side,axis) : uLocal; 
          #else
            const realArray & normal  = !isRectangular ? mg.vertexBoundaryNormal(side,axis) : uLocal;
          #endif
    
	  real uNormal=.5;


	  RealArray ux(I1,I2,I3,N);
	  if( mg.numberOfDimensions()==1 )
	  {
	    op.derivative(MappedGridOperators::xDerivative ,uLocal,ux ,I1,I2,I3,N);
	    for( int n=0; n<numberOfComponents; n++ )  
	      utLocal(I1,I2,I3,n)=(-uNormal)*normal(I1,I2,I3,0)*ux(I1,I2,I3,n);
	  }
	  else if( mg.numberOfDimensions()==2 )
	  {
	    RealArray uy(I1,I2,I3,N);
	    op.derivative(MappedGridOperators::xDerivative ,uLocal,ux ,I1,I2,I3,N);
	    op.derivative(MappedGridOperators::yDerivative ,uLocal,uy ,I1,I2,I3,N);
	    for( int n=0; n<numberOfComponents; n++ )  
	      utLocal(I1,I2,I3,n)=(-uNormal)*(normal(I1,I2,I3,0)*ux(I1,I2,I3,n)+normal(I1,I2,I3,1)*uy(I1,I2,I3,n));
	  }
	  else if( mg.numberOfDimensions()==3 )
	  {
	    RealArray uy(I1,I2,I3,N),uz(I1,I2,I3,N);
	    op.derivative(MappedGridOperators::xDerivative ,uLocal,ux ,I1,I2,I3,N);
	    op.derivative(MappedGridOperators::yDerivative ,uLocal,uy ,I1,I2,I3,N);
	    op.derivative(MappedGridOperators::zDerivative ,uLocal,uz ,I1,I2,I3,N);
	    for( int n=0; n<numberOfComponents; n++ )  
	      utLocal(I1,I2,I3,n)=(-uNormal)*(normal(I1,I2,I3,0)*ux(I1,I2,I3,n)+
                                              normal(I1,I2,I3,1)*uy(I1,I2,I3,n)+
		  			      normal(I1,I2,I3,2)*uz(I1,I2,I3,n));
	  }
	}
      }
    }
  }
  
  if( debug() & 8 )
  {
    display(ut,sPrintF("Cgasf:getUt:done: ut for grid=%i t=%9.3e",grid,t),parameters.dbase.get<FILE* >("debugFile")) ;
  }
  
  parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForGetUt"))+=getCPU()-cpu0;
  addForcing(dvdt,v,iparam,rparam,dvdtImplicit);

  return 0;
}

#undef U   
#undef UU  
#undef UX  
#undef UY  
#undef UZ  
#undef UXX 
#undef UXY 
#undef UXZ 
#undef UYY 
#undef UYZ 
#undef UZZ 





 

real Cgasf::
maxMachNumber( realMappedGridFunction & u )
// determine the maximum Mach number
{
  const int & rc = parameters.dbase.get<int >("rc");
  const int & uc = parameters.dbase.get<int >("uc");
  const int & vc = parameters.dbase.get<int >("vc");
  const int & wc = parameters.dbase.get<int >("wc");
  const int & pc = parameters.dbase.get<int >("pc");
  real & pressureLevel = parameters.dbase.get<real >("pressureLevel");
  real & gamma         = parameters.dbase.get<real >("gamma");
  

  Index I1,I2,I3;
  MappedGrid & mg = *u.getMappedGrid();
  getIndex(mg.gridIndexRange(),I1,I2,I3);
  
  getLocalRealArray(u,uLocal);
  getLocalIntArray(mg.mask(),maskLocal);

  int includeGhost=1;
  bool ok=ParallelUtility::getLocalArrayBounds(u,uLocal,I1,I2,I3,includeGhost);

  real machSq=0., minRho=REAL_MAX;
  if( ok )
  {
    if( mg.numberOfDimensions()==1 )
    {
      where( maskLocal(I1,I2,I3)>0 )
      {
	machSq=max( (SQR(uLocal(I1,I2,I3,uc)))
		    /(gamma*(uLocal(I1,I2,I3,pc)+pressureLevel)/uLocal(I1,I2,I3,rc)) );
	minRho=min(uLocal(I1,I2,I3,rc));
      }
    }
    else if( mg.numberOfDimensions()==2 )
    {
      where( maskLocal(I1,I2,I3)>0 )
      {
	machSq=max( (SQR(uLocal(I1,I2,I3,uc))+SQR(uLocal(I1,I2,I3,vc)))
		    /(gamma*(uLocal(I1,I2,I3,pc)+pressureLevel)/uLocal(I1,I2,I3,rc)) );
	minRho=min(uLocal(I1,I2,I3,rc));
      }
    }
    else
    {
      where( maskLocal(I1,I2,I3)>0 )
      {
	machSq=max( (SQR(uLocal(I1,I2,I3,uc))+SQR(uLocal(I1,I2,I3,vc))+SQR(uLocal(I1,I2,I3,wc)))
		    /(gamma*(uLocal(I1,I2,I3,pc)+pressureLevel)/uLocal(I1,I2,I3,rc)) );
	minRho=min(uLocal(I1,I2,I3,rc));
      }
    }
  }

  machSq=ParallelUtility::getMaxValue(machSq);
  minRho=ParallelUtility::getMinValue(minRho);
  
  if( minRho<1.e-2 )
  {
    cout << "maxMachNumber:ERROR min(rho) is small, = " << minRho << endl;
    u.display("Here is u");
    throw "error";
  }
  if( machSq<0. )
  {
    cout << "maxMachNumber:ERROR mach^2 < 0. = " << machSq << endl;
    printF(" gamma=%e, pressureLevel=%e\n",gamma,pressureLevel);
    
    display(u,"Here is u");
    throw "error";
  }
  
  return sqrt(machSq);
}





#undef RX

// These defines are for twilight-zone flow
#define R(t)   e   (mg,I1,I2,I3,rc,t)
#define RT(t)  e.t (mg,I1,I2,I3,rc,t)
#define RX(t)  e.x (mg,I1,I2,I3,rc,t)
#define RY(t)  e.y (mg,I1,I2,I3,rc,t)
#define RZ(t)  e.z (mg,I1,I2,I3,rc,t)
#define RXX(t) e.xx(mg,I1,I2,I3,rc,t)
#define RYY(t) e.yy(mg,I1,I2,I3,rc,t)
#define RZZ(t) e.zz(mg,I1,I2,I3,rc,t)

#define U(t)   e   (mg,I1,I2,I3,uc,t)
#define UT(t)  e.t (mg,I1,I2,I3,uc,t)
#define UX(t)  e.x (mg,I1,I2,I3,uc,t)
#define UY(t)  e.y (mg,I1,I2,I3,uc,t)
#define UZ(t)  e.z (mg,I1,I2,I3,uc,t)
#define UXX(t) e.xx(mg,I1,I2,I3,uc,t)
#define UXY(t) e.xy(mg,I1,I2,I3,uc,t)
#define UXZ(t) e.xz(mg,I1,I2,I3,uc,t)
#define UYY(t) e.yy(mg,I1,I2,I3,uc,t)
#define UYZ(t) e.yz(mg,I1,I2,I3,uc,t)
#define UZZ(t) e.zz(mg,I1,I2,I3,uc,t)

#define V(t)   e   (mg,I1,I2,I3,vc,t)
#define VT(t)  e.t (mg,I1,I2,I3,vc,t)
#define VX(t)  e.x (mg,I1,I2,I3,vc,t)
#define VY(t)  e.y (mg,I1,I2,I3,vc,t)
#define VZ(t)  e.z (mg,I1,I2,I3,vc,t)
#define VXX(t) e.xx(mg,I1,I2,I3,vc,t)
#define VXY(t) e.xy(mg,I1,I2,I3,vc,t)
#define VXZ(t) e.xz(mg,I1,I2,I3,vc,t)
#define VYY(t) e.yy(mg,I1,I2,I3,vc,t)
#define VYZ(t) e.yz(mg,I1,I2,I3,vc,t)
#define VZZ(t) e.zz(mg,I1,I2,I3,vc,t)

#define W(t)   e   (mg,I1,I2,I3,wc,t)
#define WT(t)  e.t (mg,I1,I2,I3,wc,t)
#define WX(t)  e.x (mg,I1,I2,I3,wc,t)
#define WY(t)  e.y (mg,I1,I2,I3,wc,t)
#define WZ(t)  e.z (mg,I1,I2,I3,wc,t)
#define WXX(t) e.xx(mg,I1,I2,I3,wc,t)
#define WXY(t) e.xy(mg,I1,I2,I3,wc,t)
#define WXZ(t) e.xz(mg,I1,I2,I3,wc,t)
#define WYY(t) e.yy(mg,I1,I2,I3,wc,t)
#define WYZ(t) e.yz(mg,I1,I2,I3,wc,t)
#define WZZ(t) e.zz(mg,I1,I2,I3,wc,t)

#define P(t)   (e  (mg,I1,I2,I3,pc,t)+pressureLevel)
#define PT(t)  e.t (mg,I1,I2,I3,pc,t)
#define PX(t)  e.x (mg,I1,I2,I3,pc,t)
#define PY(t)  e.y (mg,I1,I2,I3,pc,t)
#define PZ(t)  e.z (mg,I1,I2,I3,pc,t)
#define PXX(t) e.xx(mg,I1,I2,I3,pc,t)
#define PXY(t) e.xy(mg,I1,I2,I3,pc,t)
#define PXZ(t) e.xz(mg,I1,I2,I3,pc,t)
#define PYY(t) e.yy(mg,I1,I2,I3,pc,t)
#define PYZ(t) e.yz(mg,I1,I2,I3,pc,t)
#define PZZ(t) e.zz(mg,I1,I2,I3,pc,t)

#define T(t)   e   (mg,I1,I2,I3,tc,t)
#define TT(t)  e.t (mg,I1,I2,I3,tc,t)
#define TX(t)  e.x (mg,I1,I2,I3,tc,t)
#define TY(t)  e.y (mg,I1,I2,I3,tc,t)
#define TZ(t)  e.z (mg,I1,I2,I3,tc,t)
#define TXX(t) e.xx(mg,I1,I2,I3,tc,t)
#define TXY(t) e.xy(mg,I1,I2,I3,tc,t)
#define TXZ(t) e.xz(mg,I1,I2,I3,tc,t)
#define TYY(t) e.yy(mg,I1,I2,I3,tc,t)
#define TYZ(t) e.yz(mg,I1,I2,I3,tc,t)
#define TZZ(t) e.zz(mg,I1,I2,I3,tc,t)

#define S(t,s)   e   (mg,I1,I2,I3,s,t)
#define ST(t,s)  e.t (mg,I1,I2,I3,s,t)
#define SX(t,s)  e.x (mg,I1,I2,I3,s,t)
#define SY(t,s)  e.y (mg,I1,I2,I3,s,t)
#define SZ(t,s)  e.z (mg,I1,I2,I3,s,t)
#define SXX(t,s) e.xx(mg,I1,I2,I3,s,t)
#define SXY(t,s) e.xy(mg,I1,I2,I3,s,t)
#define SXZ(t,s) e.xz(mg,I1,I2,I3,s,t)
#define SYY(t,s) e.yy(mg,I1,I2,I3,s,t)
#define SYZ(t,s) e.yz(mg,I1,I2,I3,s,t)
#define SZZ(t,s) e.zz(mg,I1,I2,I3,s,t)

#define E(t)   e    (mg,I1,I2,I3,ec,t)
#define ET(t)  e.t (mg,I1,I2,I3,ec,t)
#define EX(t)  e.x (mg,I1,I2,I3,ec,t)
#define EXX(t) e.xx(mg,I1,I2,I3,ec,t)

void Cgasf::
addForcing(realMappedGridFunction & dvdt, const realMappedGridFunction & u,
	   int iparam[], real rparam[],
	   realMappedGridFunction & dvdtImplicit /* = Overture::nullRealMappedGridFunction() */,
           realMappedGridFunction *referenceFrameVelocity /* =NULL */ )
{
  real time0=getCPU();

  // add any user defined forcing:
  // userDefinedForcing( dvdt, u, iparam, rparam );
   // --- Add on any user defined forcing ---
  if( parameters.dbase.get<bool >("turnOnBodyForcing") )
  {
    OV_ABORT("ERROR: finish me");
  }
  

  // *wdh* 081207 MappedGrid & mg = *dvdt.getMappedGrid();
  MappedGrid & mg = *u.getMappedGrid();   // use this for moving grid cases since dvdt may not have the correct grid

  const int numberOfDimensions = mg.numberOfDimensions();
  // const real & t0=rparam[0];
  real t         =rparam[1];          // this is really tForce
  const real & tImplicit=rparam[2];
  const int & grid = iparam[0];
  AsfParameters & asfParameters = (AsfParameters &)parameters;
  const AsfParameters::AlgorithmVariation & algorithmVariation = 
           parameters.dbase.get<AsfParameters::AlgorithmVariation>("algorithmVariation");

  const Parameters::ImplicitMethod & implicitMethod = 
                   parameters.dbase.get<Parameters::ImplicitMethod >("implicitMethod");
  const Parameters::ImplicitOption & implicitOption = 
                   parameters.dbase.get<Parameters::ImplicitOption >("implicitOption");
  const int & linearizeImplicitMethod = parameters.dbase.get<int >("linearizeImplicitMethod");
  const int & explicitMethod = parameters.dbase.get<int >("explicitMethod");

  if( parameters.dbase.get<bool >("twilightZoneFlow") )
  {
    // const int & numberOfComponents = parameters.dbase.get<int >("numberOfComponents");
    const int & rc = parameters.dbase.get<int >("rc");
    const int & uc = parameters.dbase.get<int >("uc");
    const int & vc = parameters.dbase.get<int >("vc");
    const int & wc = parameters.dbase.get<int >("wc");
    const int & pc = parameters.dbase.get<int >("pc");
    const int & tc = parameters.dbase.get<int >("tc");
    const int & sc = parameters.dbase.get<int >("sc");
    const int & computeReactions = parameters.dbase.get<bool >("computeReactions");
    const int & numberOfSpecies = parameters.dbase.get<int >("numberOfSpecies");

    const real & mu = parameters.dbase.get<real >("mu");
    const real & gamma = parameters.dbase.get<real >("gamma");
    const real & kThermal = parameters.dbase.get<real >("kThermal");
    const real & Rg = parameters.dbase.get<real >("Rg");
    // const real & avr = parameters.dbase.get<real >("avr");
    const real & pressureLevel = parameters.dbase.get<real >("pressureLevel");
    const real & nuRho = parameters.dbase.get<real >("nuRho");
    // const real & nu = parameters.dbase.get<real >("nu");
    // const real & anu = parameters.dbase.get<real >("anu");
    // const real & advectionCoefficient = parameters.dbase.get<real >("advectionCoefficient");

    const real implicitFactor = (parameters.getGridIsImplicit(grid) 
				 && implicitMethod==Parameters::crankNicolson ) ? .5 : 1.;

    realArray & ut = dvdt;
    realArray & uti = dvdtImplicit;
	
    const real a43 = 4./3.;
    const real a13 = 1./3.;


    OGFunction & e = *(parameters.dbase.get<OGFunction* >("exactSolution"));


    getLocalRealArray(ut,utLocal);
    
    Index I1,I2,I3;
    getIndex(mg.extendedIndexRange(),I1,I2,I3);
    
    int includeGhost=1;
    bool ok=ParallelUtility::getLocalArrayBounds(ut,utLocal,I1,I2,I3,includeGhost);
    if( !ok ) return;

    getLocalRealArray(uti,utiLocal);

    // ut0 equal ut or uti (if implicit)
    const RealArray & ut0 = (parameters.getGridIsImplicit(grid) 
		       && implicitOption==Parameters::computeImplicitTermsSeparately) ? utiLocal : utLocal;

    const bool isRectangular = false; // ** do this for now ** mg.isRectangular();

    if( !isRectangular )
      mg.update(MappedGrid::THEcenter);

    realArray & x= mg.center();
    #ifdef USE_PPP
      realSerialArray xLocal; 
      if( !isRectangular ) 
        getLocalArrayWithGhostBoundaries(x,xLocal);
    #else
      const realSerialArray & xLocal = x;
    #endif

    if( mg.numberOfDimensions()==1 )
    {
      realSerialArray r0(I1,I2,I3),r0t(I1,I2,I3),r0x(I1,I2,I3);
      
      realSerialArray u0(I1,I2,I3),u0t(I1,I2,I3),u0x(I1,I2,I3);
      realSerialArray v0(I1,I2,I3),v0t(I1,I2,I3),v0x(I1,I2,I3);
      realSerialArray t0(I1,I2,I3),t0t(I1,I2,I3),t0x(I1,I2,I3);
      realSerialArray p0(I1,I2,I3),p0t(I1,I2,I3),p0x(I1,I2,I3);
	

      e.gd( r0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,rc,t);
      e.gd( r0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,rc,t);
      e.gd( r0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,rc,t);

      e.gd( u0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,uc,t);
      e.gd( u0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,uc,t);
      e.gd( u0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,uc,t);

      e.gd( v0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,vc,t);
      e.gd( v0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,vc,t);
      e.gd( v0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,vc,t);

      e.gd( p0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,pc,t);
      p0+=pressureLevel;
      e.gd( p0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,pc,t);
      e.gd( p0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,pc,t);

      e.gd( t0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,tc,t);
      e.gd( t0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,tc,t);
      e.gd( t0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,tc,t);

      RealArray r0i(I1,I2,I3); r0i=1./r0;

      if( algorithmVariation==AsfParameters::defaultAlgorithm )
      {
        realSerialArray r0xx(I1,I2,I3);
        e.gd( r0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,rc,t);
        utLocal(I1,I2,I3,rc)+=r0t +u0*r0x+r0*u0x - nuRho*r0xx;
      }
      
      utLocal(I1,I2,I3,uc)+=u0t +u0*u0x;
      utLocal(I1,I2,I3,pc)+=p0t +u0*p0x;
      utLocal(I1,I2,I3,tc)+=t0t +u0*t0x + (gamma-1.)*t0*u0x;
      if( mu>0. )
      { // note that we assume that mu>0 iff kThermal>0
	realSerialArray u0xx(I1,I2,I3);
	realSerialArray v0xx(I1,I2,I3);
	realSerialArray t0xx(I1,I2,I3);

	e.gd( u0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,uc,t);
	e.gd( v0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,vc,t);
	e.gd( t0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,tc,t);

        utLocal(I1,I2,I3,uc)-=(implicitFactor*mu*r0i)*(a43*u0xx); 
	RealArray phi(I1,I2,I3); phi=(4./3.)*( SQR(u0x) );
	utLocal(I1,I2,I3,pc)-= (implicitFactor*(gamma-1.)*kThermal*Rg)*t0xx+  (gamma-1.)*phi;
	utLocal(I1,I2,I3,tc)-= ((gamma-1.)*r0i)*( implicitFactor*kThermal*t0xx+ (1./Rg)*phi );

      }
      if( explicitMethod )
      {
        utLocal(I1,I2,I3,uc)+=p0x*r0i;
        utLocal(I1,I2,I3,pc)+=gamma*p0*u0x;
      }
      else if( linearizeImplicitMethod )
      { // linearize the implicit method
        getLocalRealArray(rL()[grid],rLLocal);
        getLocalRealArray(pL()[grid],pLLocal);

        RealArray rhoInverseDiff(I1,I2,I3);  rhoInverseDiff = r0i - 1./rLLocal(I1,I2,I3);
        utLocal(I1,I2,I3,uc)+=p0x*rhoInverseDiff;
        utLocal(I1,I2,I3,pc)+=gamma*(p0-pLLocal(I1,I2,I3)-pressureLevel)*u0x;

      }

      if( computeReactions )
      {
        realSerialArray s0(I1,I2,I3),s0t(I1,I2,I3),s0x(I1,I2,I3),s0xx(I1,I2,I3);
	for( int s=sc; s<sc+numberOfSpecies; s++ )
	{
        
	  e.gd( s0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,s,t);
	  e.gd( s0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,s,t);
	  e.gd( s0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,s,t);
	  e.gd( s0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,s,t);
	  
	  utLocal(I1,I2,I3,s)+=s0t + u0*s0x -mu*s0xx; // ********** this should not use mu *************
	}
      }


    }
    else if( mg.numberOfDimensions()==2 )
    {
      realSerialArray r0(I1,I2,I3),r0t(I1,I2,I3),r0x(I1,I2,I3),r0y(I1,I2,I3);
      realSerialArray u0(I1,I2,I3),u0t(I1,I2,I3),u0x(I1,I2,I3),u0y(I1,I2,I3);
      realSerialArray v0(I1,I2,I3),v0t(I1,I2,I3),v0x(I1,I2,I3),v0y(I1,I2,I3);
      realSerialArray t0(I1,I2,I3),t0t(I1,I2,I3),t0x(I1,I2,I3),t0y(I1,I2,I3);
      realSerialArray p0(I1,I2,I3),p0t(I1,I2,I3),p0x(I1,I2,I3),p0y(I1,I2,I3);
	

      e.gd( r0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,rc,t);
      e.gd( r0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,rc,t);
      e.gd( r0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,rc,t);
      e.gd( r0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,rc,t);

      e.gd( u0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,uc,t);
      e.gd( u0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,uc,t);
      e.gd( u0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,uc,t);
      e.gd( u0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,uc,t);

      e.gd( v0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,vc,t);
      e.gd( v0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,vc,t);
      e.gd( v0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,vc,t);
      e.gd( v0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,vc,t);

      e.gd( p0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,pc,t); 
      p0+=pressureLevel;
      e.gd( p0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,pc,t);
      e.gd( p0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,pc,t);
      e.gd( p0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,pc,t);

      e.gd( t0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,tc,t);
      e.gd( t0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,tc,t);
      e.gd( t0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,tc,t);
      e.gd( t0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,tc,t);

      RealArray r0i(I1,I2,I3); r0i=1./r0;
      RealArray div(I1,I2,I3); div=u0x+v0y;

      if( algorithmVariation==AsfParameters::defaultAlgorithm )
      {
        realSerialArray r0xx(I1,I2,I3),r0yy(I1,I2,I3);
        e.gd( r0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,rc,t);
        e.gd( r0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,rc,t);
        utLocal(I1,I2,I3,rc)+=r0t +u0*r0x+v0*r0y+r0*div -nuRho*(r0xx+r0yy);
      }
      
      utLocal(I1,I2,I3,uc)+=u0t +u0*u0x+v0*u0y;
      utLocal(I1,I2,I3,vc)+=v0t +u0*v0x+v0*v0y;
      // -- do we need only need to add forcing to p for explicit ??
      utLocal(I1,I2,I3,pc)+=p0t +u0*p0x+v0*p0y;
      utLocal(I1,I2,I3,tc)+=t0t +u0*t0x+v0*t0y + (gamma-1.)*t0*div;

      if( mu>0. )
      {
	realSerialArray u0xx(I1,I2,I3),u0xy(I1,I2,I3),u0yy(I1,I2,I3);
	realSerialArray v0xx(I1,I2,I3),v0xy(I1,I2,I3),v0yy(I1,I2,I3);
	realSerialArray t0xx(I1,I2,I3),               t0yy(I1,I2,I3);

	e.gd( u0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,uc,t);
	e.gd( u0xy,xLocal,numberOfDimensions,isRectangular,0,1,1,0,I1,I2,I3,uc,t);
	e.gd( u0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,uc,t);

	e.gd( v0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,vc,t);
	e.gd( v0xy,xLocal,numberOfDimensions,isRectangular,0,1,1,0,I1,I2,I3,vc,t);
	e.gd( v0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,vc,t);

	e.gd( t0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,tc,t);
	e.gd( t0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,tc,t);

        RealArray muOverRho(I1,I2,I3);  muOverRho= (implicitFactor*mu)*r0i;
        RealArray lapT(I1,I2,I3);       lapT = (implicitFactor*kThermal*(gamma-1))*(t0xx+t0yy);
	RealArray phi(I1,I2,I3);        phi = mu*( ( 4./3.)*( SQR(u0x)-u0x*v0y+SQR(v0y) ) +SQR(v0x+u0y) );

	ut0(I1,I2,I3,uc)-=muOverRho*(a43*u0xx+u0yy+a13*v0xy); 
	ut0(I1,I2,I3,vc)-=muOverRho*(v0xx+a43*v0yy+a13*u0xy); 
	ut0(I1,I2,I3,pc)-=Rg*lapT +(gamma-1.)*phi;
	ut0(I1,I2,I3,tc)-=r0i*( lapT +((gamma-1.)/Rg)*phi ); 

      }

      if( explicitMethod )
      {
        utLocal(I1,I2,I3,uc)+=p0x*r0i;
        utLocal(I1,I2,I3,vc)+=p0y*r0i;
        utLocal(I1,I2,I3,pc)+=gamma*p0*div;
      }
      else if( linearizeImplicitMethod )
      { // linearize the implicit method
        getLocalRealArray(rL()[grid],rLLocal);
        getLocalRealArray(pL()[grid],pLLocal);

        RealArray rhoInverseDiff(I1,I2,I3);  rhoInverseDiff = r0i - 1./rLLocal(I1,I2,I3);
        utLocal(I1,I2,I3,uc)+=p0x*rhoInverseDiff;
        utLocal(I1,I2,I3,vc)+=p0y*rhoInverseDiff;
        utLocal(I1,I2,I3,pc)+=gamma*(p0-pLLocal(I1,I2,I3)-pressureLevel)*div;
      }

    }
    else if( mg.numberOfDimensions()==3 )
    {
      if( false )
      {
#ifdef USE_PPP
        Overture::abort("error");
#else
	const RealArray & rho = R(t);
	const RealArray & u0  = U(t);
	const RealArray & u0x = UX(t);
	const RealArray & u0y = UY(t);
	const RealArray & u0z = UZ(t);

	const RealArray & v0  = V(t);
	const RealArray & v0x = VX(t);
	const RealArray & v0y = VY(t);
	const RealArray & v0z = VZ(t);

	const RealArray & p0  = P(t);
	const RealArray & p0x = PX(t);
	const RealArray & p0y = PY(t); 
	const RealArray & p0z = PZ(t); 
     
	const RealArray & te  = T(t);
	const RealArray & t0x = TX(t);
	const RealArray & t0y = TY(t);
	const RealArray & t0z = TZ(t);

	const RealArray & w0  = W(t);
	const RealArray & w0x = WX(t);
	const RealArray & w0y = WY(t); 
	const RealArray & w0z = WZ(t); 
     
	const RealArray & rhoInverse = evaluate(1./rho);
	const RealArray & div = evaluate(u0x+v0y+w0z);

	if( algorithmVariation==AsfParameters::densityFromGasLawAlgorithm )
	  ut(I1,I2,I3,rc)+=RT(t) +u0*RX(t)+v0*RY(t)+R(t)*(u0x+v0y) -nuRho*(RXX(t)+RYY(t));

	ut(I1,I2,I3,uc)+=UT(t) +u0*u0x +v0*u0y +w0*u0z;
	ut(I1,I2,I3,vc)+=VT(t) +u0*v0x +v0*v0y +w0*v0z;
	ut(I1,I2,I3,wc)+=WT(t) +u0*w0x +v0*w0y +w0*w0z;
	ut(I1,I2,I3,tc)+=TT(t) +u0*t0x +v0*t0y +w0*t0z + (gamma-1.)*te*div;
	ut(I1,I2,I3,pc)+=PT(t) +u0*p0x +v0*p0y +w0*p0z;
	if( mu>0. )
	{
	  const RealArray & muOverRho = evaluate( (implicitFactor*mu)*rhoInverse );
	
	  ut0(I1,I2,I3,uc)-=muOverRho*(a43*UXX(t)+UYY(t)+UZZ(t)+a13*(VXY(t)+WXZ(t)));
	  ut0(I1,I2,I3,vc)-=muOverRho*(VXX(t)+a43*VYY(t)+VZZ(t)+a13*(UXY(t)+WYZ(t)));
	  ut0(I1,I2,I3,wc)-=muOverRho*(WXX(t)+WYY(t)+a43*WZZ(t)+a13*(UXZ(t)+VYZ(t)));

	  const RealArray & phi= evaluate(
	    mu*( a43*( u0x*(u0x-v0y) + v0y*(v0y-w0z)+SQR(w0z) )
		 +   2.*( u0y*v0x+u0z*w0x + v0z*w0y)
		 + SQR(u0y)+SQR(u0z)+SQR(v0x)
		 + SQR(v0z)+SQR(w0x)+SQR(w0y) ) );
	
	  const RealArray & lapT = evaluate( (implicitFactor*(gamma-1.)*kThermal)*( TXX(t)+TYY(t)+TZZ(t) ) );

	  ut0(I1,I2,I3,pc)-=Rg*lapT +(gamma-1.)*phi;
	  ut0(I1,I2,I3,tc)-=rhoInverse*(lapT +((gamma-1.)/Rg)*phi );
	}
	if( parameters.dbase.get<int >("explicitMethod") )
	{
	  ut(I1,I2,I3,uc)+=p0x*rhoInverse;
	  ut(I1,I2,I3,vc)+=p0y*rhoInverse;
	  ut(I1,I2,I3,wc)+=p0z*rhoInverse;
	  ut(I1,I2,I3,pc)+=gamma*p0*div;
	}
	else if( parameters.dbase.get<int >("linearizeImplicitMethod") )
	{ // linearize the implicit method
	  const RealArray & rhoInverseDiff = evaluate( rhoInverse-1./rL()[grid](I1,I2,I3) );
	  ut(I1,I2,I3,uc)+=p0x*rhoInverseDiff;
	  ut(I1,I2,I3,vc)+=p0y*rhoInverseDiff;
	  ut(I1,I2,I3,wc)+=p0z*rhoInverseDiff;
	  ut(I1,I2,I3,pc)+=gamma*(p0-pL()[grid](I1,I2,I3)-pressureLevel)*div;
	}
#endif
      }
      else
      {
	realSerialArray r0(I1,I2,I3),r0t(I1,I2,I3),r0x(I1,I2,I3),r0y(I1,I2,I3),r0z(I1,I2,I3);
	realSerialArray u0(I1,I2,I3),u0t(I1,I2,I3),u0x(I1,I2,I3),u0y(I1,I2,I3),u0z(I1,I2,I3);
	realSerialArray v0(I1,I2,I3),v0t(I1,I2,I3),v0x(I1,I2,I3),v0y(I1,I2,I3),v0z(I1,I2,I3);
	realSerialArray w0(I1,I2,I3),w0t(I1,I2,I3),w0x(I1,I2,I3),w0y(I1,I2,I3),w0z(I1,I2,I3);
	realSerialArray t0(I1,I2,I3),t0t(I1,I2,I3),t0x(I1,I2,I3),t0y(I1,I2,I3),t0z(I1,I2,I3);
	realSerialArray p0(I1,I2,I3),p0t(I1,I2,I3),p0x(I1,I2,I3),p0y(I1,I2,I3),p0z(I1,I2,I3);
	

	e.gd( r0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,rc,t);
	e.gd( r0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,rc,t);
	e.gd( r0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,rc,t);
	e.gd( r0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,rc,t);
	e.gd( r0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,rc,t);

	e.gd( u0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,uc,t);
	e.gd( u0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,uc,t);
	e.gd( u0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,uc,t);
	e.gd( u0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,uc,t);
	e.gd( u0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,uc,t);

	e.gd( v0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,vc,t);
	e.gd( v0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,vc,t);
	e.gd( v0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,vc,t);
	e.gd( v0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,vc,t);
	e.gd( v0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,vc,t);

	e.gd( w0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,wc,t);
	e.gd( w0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,wc,t);
	e.gd( w0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,wc,t);
	e.gd( w0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,wc,t);
	e.gd( w0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,wc,t);

	e.gd( p0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,pc,t);
        p0+=pressureLevel;
	e.gd( p0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,pc,t);
	e.gd( p0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,pc,t);
	e.gd( p0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,pc,t);
	e.gd( p0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,pc,t);

	e.gd( t0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,tc,t);
	e.gd( t0t ,xLocal,numberOfDimensions,isRectangular,1,0,0,0,I1,I2,I3,tc,t);
	e.gd( t0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,tc,t);
	e.gd( t0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,tc,t);
	e.gd( t0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,tc,t);

	RealArray r0i(I1,I2,I3); r0i=1./r0;
	RealArray div(I1,I2,I3); div=u0x+v0y+w0z;

	if( algorithmVariation==AsfParameters::defaultAlgorithm )
	{
	  realSerialArray r0xx(I1,I2,I3),r0yy(I1,I2,I3),r0zz(I1,I2,I3);
	  e.gd( r0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,rc,t);
	  e.gd( r0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,rc,t);
	  e.gd( r0zz,xLocal,numberOfDimensions,isRectangular,0,0,0,2,I1,I2,I3,rc,t);
	  utLocal(I1,I2,I3,rc)+=r0t +u0*r0x+v0*r0y+w0*r0z+r0*div -nuRho*(r0xx+r0yy+r0zz);
	}
      
	utLocal(I1,I2,I3,uc)+=u0t +u0*u0x +v0*u0y +w0*u0z;
	utLocal(I1,I2,I3,vc)+=v0t +u0*v0x +v0*v0y +w0*v0z;
	utLocal(I1,I2,I3,wc)+=w0t +u0*w0x +v0*w0y +w0*w0z;
	utLocal(I1,I2,I3,tc)+=t0t +u0*t0x +v0*t0y +w0*t0z + (gamma-1.)*t0*div;
	utLocal(I1,I2,I3,pc)+=p0t +u0*p0x +v0*p0y +w0*p0z;
	if( mu>0. )
	{
	  realSerialArray u0xx(I1,I2,I3),u0xy(I1,I2,I3),u0yy(I1,I2,I3),u0xz(I1,I2,I3),u0yz(I1,I2,I3),u0zz(I1,I2,I3);
	  realSerialArray v0xx(I1,I2,I3),v0xy(I1,I2,I3),v0yy(I1,I2,I3),v0xz(I1,I2,I3),v0yz(I1,I2,I3),v0zz(I1,I2,I3);
	  realSerialArray w0xx(I1,I2,I3),w0xy(I1,I2,I3),w0yy(I1,I2,I3),w0xz(I1,I2,I3),w0yz(I1,I2,I3),w0zz(I1,I2,I3);
	  realSerialArray t0xx(I1,I2,I3),               t0yy(I1,I2,I3),               t0zz(I1,I2,I3);

	  e.gd( u0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,uc,t);
	  e.gd( u0xy,xLocal,numberOfDimensions,isRectangular,0,1,1,0,I1,I2,I3,uc,t);
	  e.gd( u0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,uc,t);
	  e.gd( u0xz,xLocal,numberOfDimensions,isRectangular,0,1,0,1,I1,I2,I3,uc,t);
	  e.gd( u0yz,xLocal,numberOfDimensions,isRectangular,0,0,1,1,I1,I2,I3,uc,t);
	  e.gd( u0zz,xLocal,numberOfDimensions,isRectangular,0,0,0,2,I1,I2,I3,uc,t);

	  e.gd( v0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,vc,t);
	  e.gd( v0xy,xLocal,numberOfDimensions,isRectangular,0,1,1,0,I1,I2,I3,vc,t);
	  e.gd( v0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,vc,t);
	  e.gd( v0xz,xLocal,numberOfDimensions,isRectangular,0,1,0,1,I1,I2,I3,vc,t);
	  e.gd( v0yz,xLocal,numberOfDimensions,isRectangular,0,0,1,1,I1,I2,I3,vc,t);
	  e.gd( v0zz,xLocal,numberOfDimensions,isRectangular,0,0,0,2,I1,I2,I3,vc,t);

	  e.gd( w0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,wc,t);
	  e.gd( w0xy,xLocal,numberOfDimensions,isRectangular,0,1,1,0,I1,I2,I3,wc,t);
	  e.gd( w0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,wc,t);
	  e.gd( w0xz,xLocal,numberOfDimensions,isRectangular,0,1,0,1,I1,I2,I3,wc,t);
	  e.gd( w0yz,xLocal,numberOfDimensions,isRectangular,0,0,1,1,I1,I2,I3,wc,t);
	  e.gd( w0zz,xLocal,numberOfDimensions,isRectangular,0,0,0,2,I1,I2,I3,wc,t);

	  e.gd( t0xx,xLocal,numberOfDimensions,isRectangular,0,2,0,0,I1,I2,I3,tc,t);
	  e.gd( t0yy,xLocal,numberOfDimensions,isRectangular,0,0,2,0,I1,I2,I3,tc,t);
	  e.gd( t0zz,xLocal,numberOfDimensions,isRectangular,0,0,0,2,I1,I2,I3,tc,t);

	  RealArray muOverRho(I1,I2,I3);  muOverRho= (implicitFactor*mu)*r0i;
	  RealArray lapT(I1,I2,I3);       lapT = (implicitFactor*kThermal*(gamma-1.))*(t0xx+t0yy+t0zz);
	  RealArray phi(I1,I2,I3);        
	  phi= mu*( a43*( u0x*(u0x-v0y) + v0y*(v0y-w0z)+SQR(w0z) )
		    +   2.*( u0y*v0x+u0z*w0x + v0z*w0y)
		    + SQR(u0y)+SQR(u0z)+SQR(v0x)
		    + SQR(v0z)+SQR(w0x)+SQR(w0y) );


	  ut0(I1,I2,I3,uc)-=muOverRho*(a43*u0xx+u0yy+u0zz+a13*(v0xy+w0xz));
	  ut0(I1,I2,I3,vc)-=muOverRho*(v0xx+a43*v0yy+v0zz+a13*(u0xy+w0yz));
	  ut0(I1,I2,I3,wc)-=muOverRho*(w0xx+w0yy+a43*w0zz+a13*(u0xz+v0yz));

	  ut0(I1,I2,I3,pc)-=Rg*lapT +(gamma-1.)*phi;
	  ut0(I1,I2,I3,tc)-=r0i*(lapT +((gamma-1.)/Rg)*phi );
	}
	if( explicitMethod )
	{
	  utLocal(I1,I2,I3,uc)+=p0x*r0i;
	  utLocal(I1,I2,I3,vc)+=p0y*r0i;
	  utLocal(I1,I2,I3,wc)+=p0z*r0i;
	  utLocal(I1,I2,I3,pc)+=gamma*p0*div;
	}
	else if( linearizeImplicitMethod )
	{ // linearize the implicit method
	  getLocalRealArray(rL()[grid],rLLocal);
	  getLocalRealArray(pL()[grid],pLLocal);

	  RealArray rhoInverseDiff(I1,I2,I3);  rhoInverseDiff = r0i - 1./rLLocal(I1,I2,I3);

	  utLocal(I1,I2,I3,uc)+=p0x*rhoInverseDiff;
	  utLocal(I1,I2,I3,vc)+=p0y*rhoInverseDiff;
	  utLocal(I1,I2,I3,wc)+=p0z*rhoInverseDiff;
	  utLocal(I1,I2,I3,pc)+=gamma*(p0-pLLocal(I1,I2,I3)-pressureLevel)*div;
	}
      }

    } // end if numberOfDimensions ==3 
    
  }
  parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForForcing"))+=getCPU()-time0;
}

void Cgasf::
addAllSpeedImplicitForcing( realMappedGridFunction & u0, const real t, const real deltaT, int grid )
// Add twilightzone forcing for implicit time-stepping if appropriate
{
  real time0=getCPU();

  const int & linearizeImplicitMethod = parameters.dbase.get<int >("linearizeImplicitMethod");

  // real time=getCPU();
  if( parameters.dbase.get<bool >("twilightZoneFlow") )
  {
    // const int & numberOfComponents = parameters.dbase.get<int >("numberOfComponents");
    const int & rc = parameters.dbase.get<int >("rc");
    const int & uc = parameters.dbase.get<int >("uc");
    const int & vc = parameters.dbase.get<int >("vc");
    const int & wc = parameters.dbase.get<int >("wc");
    const int & pc = parameters.dbase.get<int >("pc");
    const real & gamma = parameters.dbase.get<real >("gamma");
    const real & pressureLevel = parameters.dbase.get<real >("pressureLevel");

    const real & a0 = parameters.dbase.get<real >("a0");

    OGFunction & e = *(parameters.dbase.get<OGFunction* >("exactSolution"));

    MappedGrid & mg = *u0.getMappedGrid();
    const int numberOfDimensions = mg.numberOfDimensions();
    Index I1,I2,I3;
    getIndex(mg.gridIndexRange(),I1,I2,I3,1);  // include ghost points
    
    if( true )
    {
      getLocalRealArray(u0,u0Local);
      
      int includeGhost=1;
      bool ok=ParallelUtility::getLocalArrayBounds(u0,u0Local,I1,I2,I3,includeGhost);
      if( !ok ) return;


      const bool isRectangular = false; // ** do this for now ** mg.isRectangular();

      if( !isRectangular )
	mg.update(MappedGrid::THEcenter);

      realArray & x= mg.center();
      #ifdef USE_PPP
        realSerialArray xLocal; 
        if( !isRectangular ) 
          getLocalArrayWithGhostBoundaries(x,xLocal);
      #else
        const realSerialArray & xLocal = x;
      #endif

      realSerialArray r0i(I1,I2,I3),p0(I1,I2,I3);
      
      if( linearizeImplicitMethod )
      { // linearize the implicit method
	getLocalRealArray(rL()[grid],rLLocal);
	getLocalRealArray(pL()[grid],pLLocal);
        r0i(I1,I2,I3)=1./rLLocal(I1,I2,I3);
        p0(I1,I2,I3)=pLLocal(I1,I2,I3)+pressureLevel;
      }
      else
      { 
	e.gd( p0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,pc,t); 
	p0+=pressureLevel;
        realSerialArray r0(I1,I2,I3);
	e.gd( r0  ,xLocal,numberOfDimensions,isRectangular,0,0,0,0,I1,I2,I3,rc,t);
	r0i=1./r0;
      }
 
      
      if( mg.numberOfDimensions()==1 )
      {
	realSerialArray u0x(I1,I2,I3);
	realSerialArray p0x(I1,I2,I3);
	e.gd( u0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,uc,t);
	e.gd( p0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,pc,t);

	u0Local(I1,I2,I3,uc)+=(deltaT*a0)*p0x*r0i;
	u0Local(I1,I2,I3,pc)+=(deltaT*a0*gamma)*p0*u0x; //  ** /R(t);
      }
      else if( mg.numberOfDimensions()==2 )
      {
	realSerialArray u0x(I1,I2,I3),v0y(I1,I2,I3);
	realSerialArray p0x(I1,I2,I3),p0y(I1,I2,I3);

	e.gd( u0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,uc,t);
	e.gd( v0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,vc,t);

	e.gd( p0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,pc,t);
	e.gd( p0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,pc,t);

	u0Local(I1,I2,I3,uc)+=(deltaT*a0)*p0x*r0i;
	u0Local(I1,I2,I3,vc)+=(deltaT*a0)*p0y*r0i;
	u0Local(I1,I2,I3,pc)+=(deltaT*a0*gamma)*p0*(u0x+v0y); // *** /R(t);

      }
      else if( mg.numberOfDimensions()==3 )
      {
	realSerialArray u0x(I1,I2,I3),v0y(I1,I2,I3),w0z(I1,I2,I3);
	realSerialArray p0x(I1,I2,I3),p0y(I1,I2,I3),p0z(I1,I2,I3);

	e.gd( u0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,uc,t);
	e.gd( v0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,vc,t);
	e.gd( w0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,wc,t);

	e.gd( p0x ,xLocal,numberOfDimensions,isRectangular,0,1,0,0,I1,I2,I3,pc,t);
	e.gd( p0y ,xLocal,numberOfDimensions,isRectangular,0,0,1,0,I1,I2,I3,pc,t);
	e.gd( p0z ,xLocal,numberOfDimensions,isRectangular,0,0,0,1,I1,I2,I3,pc,t);

	u0Local(I1,I2,I3,uc)+=(deltaT*a0)*p0x*r0i;
	u0Local(I1,I2,I3,vc)+=(deltaT*a0)*p0y*r0i;
	u0Local(I1,I2,I3,wc)+=(deltaT*a0)*p0z*r0i;
	u0Local(I1,I2,I3,pc)+=(deltaT*a0*gamma)*p0*(u0x+v0y+w0z); // *** /R(t);
      }
    }
    else
    {
#ifdef USE_PPP      
      Overture::abort("error");
#else

      const RealArray & rho = parameters.dbase.get<int >("linearizeImplicitMethod") ? rL()[grid](I1,I2,I3) : R(t);
      const RealArray & rhoInverse = evaluate(1./rho);
      const RealArray & p0 = parameters.dbase.get<int >("linearizeImplicitMethod") ? 
	evaluate(pL()[grid](I1,I2,I3)+pressureLevel) : P(t);   // P(t) has the pressure level in it
  
      if( mg.numberOfDimensions()==1 )
      {
	u0(I1,I2,I3,uc)+=(deltaT*a0)*PX(t)*rhoInverse;
	u0(I1,I2,I3,pc)+=(deltaT*a0*gamma)*p0*UX(t); //  ** /R(t);
      }
      else if( mg.numberOfDimensions()==2 )
      {
	u0(I1,I2,I3,uc)+=(deltaT*a0)*PX(t)*rhoInverse;
	u0(I1,I2,I3,vc)+=(deltaT*a0)*PY(t)*rhoInverse;
	u0(I1,I2,I3,pc)+=(deltaT*a0*gamma)*p0*(UX(t)+VY(t)); // *** /R(t);

      }
      else if( mg.numberOfDimensions()==3 )
      {
	u0(I1,I2,I3,uc)+=(deltaT*a0)*PX(t)*rhoInverse;
	u0(I1,I2,I3,vc)+=(deltaT*a0)*PY(t)*rhoInverse;
	u0(I1,I2,I3,wc)+=(deltaT*a0)*PZ(t)*rhoInverse;
	u0(I1,I2,I3,pc)+=(deltaT*a0*gamma)*p0*(UX(t)+VY(t)+WZ(t)); // *** /R(t);
      }
#endif    
    }
  }
  
  parameters.dbase.get<RealArray>("timing")(parameters.dbase.get<int>("timeForForcing"))+=getCPU()-time0;
}







#undef R   
#undef RT  
#undef RX  
#undef RXX 
#undef U   
#undef UT  
#undef UX  
#undef UXX 
#undef E   
#undef ET  
#undef EX  
#undef EXX 
#undef P
#undef PT
#undef PX 
#undef PXX
