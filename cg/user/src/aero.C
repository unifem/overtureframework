//===============================================================================
// 
//  Compute/Plot some aero dynamic quantities for solutions in a show file.
//
// This program deomstrates how to read a show file generated by cgcns
// and access the solution values.
//==============================================================================
#include "Overture.h"
#include "Ogshow.h"  
#include "ShowFileReader.h"
#include "Integrate.h"
#include "CompositeGridOperators.h"
#include "PlotStuff.h"

#define ForBoundary(side,axis)   for( axis=0; axis<cg.numberOfDimensions(); axis++ ) \
                                 for( side=0; side<=1; side++ )

int
main(int argc, char *argv[])
{
  Overture::start(argc,argv);  // initialize Overture and A++/P++

  aString nameOfShowFile;
  cout << ">> Enter the name of the (old) show file:" << endl;
  cin >> nameOfShowFile;
  ShowFileReader showFileReader(nameOfShowFile);

  int numberOfFrames=showFileReader.getNumberOfFrames();
  int numberOfSolutions = max(1,numberOfFrames);
  int solutionNumber=numberOfFrames;

  CompositeGrid cg;
  realCompositeGridFunction u;

  PlotStuff ps;                      // create a PlotStuff object
  PlotStuffParameters psp;           // create an object that is used to pass parameters
    
  aString answer,answer2;
  aString menu[] = { "!Aero",
		    "get a solution",
                    "contour",
                    "stream lines",
                    "grid",
                    "select faces",
                    "enter rho, u0 and length",
                    "plot Cp(x)",
                    "plot Cp(y)",
                    "plot Cf(x)",
		    "compute torque",
                    "save Cp(x)",
                    "compute lift/drag",
		    "exit",
                    "" };
  const aString *headerComment;
  int numberOfHeaderComments;
  char buff[80];
  
  real time,reynoldsNumber,machNumber,nu;
  // Look for some parameters (these may or may not be in the show file)
  showFileReader.getGeneralParameter("reynoldsNumber",reynoldsNumber);
  showFileReader.getGeneralParameter("machNumber",machNumber);
  showFileReader.getGeneralParameter("nu",nu);

  printf("Values from the show file: nu=%e, Reynolds number=%e, Mach number=%e \n",nu,reynoldsNumber,machNumber);

  int numberOfFaces, numberOfGrids;
  IntegerArray integrateForceOnGridFace;
  IntegerArray boundary;
  Integrate integrate;
  int surfaceID=0;    // this number identifies the surface
  int side, axis, grid;
  aString line;
  real rho=1., u0=1., length=1., scale=1.;

  int it;
  for( it=0; ; it++)
  {

    if( it==0 )
      answer="get a solution";
    else
      ps.getMenuItem(menu,answer);

    if( answer=="get a solution" )
    {
      // In this case the user is asked to choose a solution to read in
      // Choosing a number that is too large will cause the last solution to be read 

      if( it>0 )
      {
        ps.inputString(line,sPrintF(buff,"Enter the solution number, [1,%i] \n",numberOfSolutions));
        sscanf(line,"%i",&solutionNumber);
      }
      
      showFileReader.getASolution(solutionNumber,cg,u);        // read in a grid and solution

      // read any header comments that go with this solution
      headerComment=showFileReader.getHeaderComments(numberOfHeaderComments);

      for( int i=0; i<numberOfHeaderComments; i++ )
        printf("Header comment: %s \n",(const char *)headerComment[i]);

      // Look for the variable "t" on the current frame which gives the current time
      HDF_DataBase & db = *showFileReader.getFrame();
      time=0.;
      db.get(time,"t");
      
      printf("Solution number = %i : time=%e\n",solutionNumber,time);

      numberOfGrids=cg.numberOfGrids();
      integrateForceOnGridFace.redim(2,3,numberOfGrids);
      integrateForceOnGridFace=FALSE;

      integrate.updateToMatchGrid(cg);
  
    }
    else if( answer=="contour" )
    {
      psp.set(GI_TOP_LABEL,sPrintF(buff,"solution number %i",solutionNumber));
      ps.erase();
      PlotIt::contour(ps,u,psp);  
    }   
    else if( answer=="stream lines" )
    {
      psp.set(GI_TOP_LABEL,sPrintF(buff,"solution number %i",solutionNumber));
      ps.erase();
      PlotIt::streamLines(ps,u,psp);  
    }   
    else if( answer=="grid" )
    {
      psp.set(GI_TOP_LABEL,sPrintF(buff,"grid"));
      ps.erase();
      PlotIt::plot(ps,cg,psp);  
    }   
    else if( answer=="select faces" )
    {
      int i, side=0, axis, grid=1;
      aString *menu2 = new aString[numberOfGrids*6+3];
      for(;;)
      {
	i=0;
	menu2[i++] = "!Select faces";
	
	for( grid=0; grid<numberOfGrids; grid++ )
	  ForBoundary(side,axis)
	    if( cg[grid].boundaryCondition()(side,axis)>0 )
	      menu2[i++]=sPrintF(buff,"(%i,%i,%i) = (%s,side,axis) %s",grid,side,axis,
                                 (const char*)cg[grid].mapping().getName(Mapping::mappingName),
				 integrateForceOnGridFace(side,axis,grid)==TRUE ? "(on)" : "(off)");
	menu2[i++]="done"; 
	menu2[i]="";   // null string terminates the menu

        ps.getMenuItem(menu2,answer2);

        if( answer2=="done" )
          break;
        if( sScanF(answer2,"(%i %i %i)",&grid,&side,&axis)==3 )
	{
          //	  printf("Toggled face: (grid=%i, side=%i, axis=%i)\n", grid,side, axis);
          integrateForceOnGridFace(side,axis,grid)=!integrateForceOnGridFace(side,axis,grid);
	}
	
        else
          cout << "ERROR: unknown response: " << answer2 << endl;
      }
      delete [] menu2;

      // count the number of active faces
      numberOfFaces=0;
      for( grid=0; grid<numberOfGrids; grid++ )
	ForBoundary(side,axis)
	  numberOfFaces += integrateForceOnGridFace(side,axis,grid);
      
      if (numberOfFaces>0)
      {
	boundary.redim(3,numberOfFaces);
	for( grid=0, i=0; grid<numberOfGrids; grid++ )
	  ForBoundary(side,axis)
	{
	  if (integrateForceOnGridFace(side,axis,grid))
	  {
	    boundary(0,i)=side;
	    boundary(1,i)=axis;
	    boundary(2,i)=grid;
	    i++;
	  }
	}
      }

      // tmp
      //        for (i=0; i<numberOfFaces; i++)
      //  	printf("#%i: side=%i, axis=%i, grid=%i\n", i, boundary(0,i), boundary(1,i), 
      //  	       boundary(2,i));

      integrate.defineSurface( surfaceID,numberOfFaces,boundary ); // define the surface
      
    }
    else if( answer=="enter rho, u0 and length" )
    {
      ps.inputString(line,sPrintF(buff,"Enter rho, u0 and length, (%e, %e, %e)\n",
				  rho, u0, length));
      if (line!="" )
      {
	sScanF(line,"%e %e %e",&rho, &u0, &length);
	scale=rho*u0*u0*length;
	if (scale==0.)
	{
	  printf("Warning: resetting scale=rho*u*u*length to 1.\n");
	}
      }
      printf("Scaling forces by rho*u^2*length = %e.\n", scale);
    }
    else if( answer=="plot Cp(x)" )
    {
      if (numberOfFaces <= 0)
      {
	printf("You must first select the faces where you want the pressure plotted\n");
	continue;
      }

      aString name[]={"-Cp","bbb"};  // add "bbb" to avoid compile error on gps
      ps.erase();
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

      for (int i=0; i<numberOfFaces; i++)
      {
	
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	
	MappedGrid & c = cg[grid];
	c.update(MappedGrid::THEvertex);
      
	const realArray & vertex = c.vertex();
      
	realArray x,p;
	Index I1,I2,I3;
	getBoundaryIndex(c.gridIndexRange(),side,axis,I1,I2,I3);

	const int pc=0;
	p.redim(I1,I2,I3);
	p(I1,I2,I3)=u[grid](I1,I2,I3,pc)/scale;
	Range I=I1.getLength()*I2.getLength()*I3.getLength();
	p.reshape(I);
      
	x.redim(I1,I2,I3);
	x(I1,I2,I3)=vertex(I1,I2,I3,axis1);
	x.reshape(I);

	if (i==numberOfFaces-1) // turn on the interactive mode for the last piece
	{
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
	}

	PlotIt::plot(ps, x,p,"Pressure coeff","x",name,psp );
      }
      
    }
    else if( answer=="save Cp(x)" )
    {
      if (numberOfFaces <= 0)
      {
	printf("You must first select the faces where you want the pressure to be saved\n");
	continue;
      }

      char filen[100];
      
      for (int i=0; i<numberOfFaces; i++)
      {
	sprintf(filen,"cp%i.ext", i);
	FILE *fi = fopen(filen,"w");

	printf("Opened the file %s\n", filen);
	
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	
	MappedGrid & c = cg[grid];
	c.update(MappedGrid::THEvertex);
      
	realArray & vertex = c.vertex();
      
	realArray x,p;
	Index I1,I2,I3;
	getBoundaryIndex(c.gridIndexRange(),side,axis,I1,I2,I3);

	const int pc=0;
	p.redim(I1,I2,I3);
	p(I1,I2,I3)=u[grid](I1,I2,I3,pc)/scale;
	Range I=I1.getLength()*I2.getLength()*I3.getLength();
	p.reshape(I);
      
	x.redim(I1,I2,I3);
	x(I1,I2,I3)=vertex(I1,I2,I3,axis1);
	x.reshape(I);

	for (int k=I.getBase(); k<=I.getBound(); k++)
	  fprintf(fi,"%e %e\n", x(k), p(k));

	fclose(fi);
      }
      printf("Done\n", filen);
      
    }
    else if( answer=="compute torque" )
    {
      if (numberOfFaces <= 0)
      {
	printf("You must first select the faces where you want the torque to be saved\n");
	continue;
      }
      
      const int pc=0, uc=1, vc=2;

      // force = tau.n = -p n_i + nu*( (d_j u_i) n_j + (d_i u_j)n_j )

      Range all;
      RealCompositeGridFunction torque(cg),force(cg,all,all,all,3);
      CompositeGridOperators op(cg);
      u.setOperators(op);
      
      Index I1,I2,I3;
      int i;
      
      // force
      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);

	cg[grid].update(MappedGrid::THEvertexBoundaryNormal);
	realArray & normal = cg[grid].vertexBoundaryNormal(side,axis);
      
	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
        realArray ux; ux = u[grid].x(I1,I2,I3,Range(uc,vc));
        realArray uy; uy = u[grid].y(I1,I2,I3,Range(uc,vc));
        // x-component (the normal is outward)
	force[grid](I1,I2,I3,0)=-(-u[grid](I1,I2,I3,pc)*normal(I1,I2,I3,axis1) +
	  nu*( 2.*ux(I1,I2,I3,uc) * normal(I1,I2,I3,axis1) + 
	       (uy(I1,I2,I3,uc) + ux(I1,I2,I3,vc)) * normal(I1,I2,I3,axis2) ) );
        // y-component	
	force[grid](I1,I2,I3,1)=-(-u[grid](I1,I2,I3,pc)*normal(I1,I2,I3,axis2) +
	  nu*( 2.*uy(I1,I2,I3,vc) * normal(I1,I2,I3,axis2) + 
	       (uy(I1,I2,I3,uc) + ux(I1,I2,I3,vc)) * normal(I1,I2,I3,axis1) ) );
	
      }
      // compute the torque

      real torqueSum=0;
	
      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	
	MappedGrid & c = cg[grid];
	c.update(MappedGrid::THEvertex);
	realArray & vertex = c.vertex();

	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
	Range I=I1.getLength()*I2.getLength()*I3.getLength();

	realArray localTorque,ds;
	real x0=0.25, y0=0.;

        // compute the arc length of each segment
	int is1, is2;
	if (axis == 0)
	{
	  is1=0;
	  is2=1;
	}
	else if (axis == 1)
	{
	  is1=1;
	  is2=0;
	}
	ds.redim(I1,I2,I3);
	ds(I1,I2,I3)= 0.5* sqrt(
	   (vertex(I1+is1,I2+is2,I3,axis1) - vertex(I1-is1,I2-is2,I3,axis1)) *
	   (vertex(I1+is1,I2+is2,I3,axis1) - vertex(I1-is1,I2-is2,I3,axis1)) +
	   (vertex(I1+is1,I2+is2,I3,axis2) - vertex(I1-is1,I2-is2,I3,axis2)) *
	   (vertex(I1+is1,I2+is2,I3,axis2) - vertex(I1-is1,I2-is2,I3,axis2)) );
	ds.reshape(I);

	torque[grid](I1,I2,I3) = ( force[grid](I1,I2,I3,axis1) * (vertex(I1,I2,I3,axis2)-y0) -
	  force[grid](I1,I2,I3,axis2) * (vertex(I1,I2,I3,axis1)-x0) ) / scale;

        // need to multiply by the arclength segment as well
	localTorque.redim(I1,I2,I3);
	localTorque(I1,I2,I3) = ( force[grid](I1,I2,I3,axis1) * (vertex(I1,I2,I3,axis2)-y0) -
	  force[grid](I1,I2,I3,axis2) * (vertex(I1,I2,I3,axis1)-x0) ) / scale;
	localTorque.reshape(I);

	for (int k=I.getBase(); k<=I.getBound(); k++)
	  torqueSum += localTorque(k)*ds(k);
	
      }

      real torqueInt = integrate.surfaceIntegral(torque,surfaceID);
      printf("\nOverture approx of Torque: %e\n", torqueInt);
      printf("Simple approx of Torque: %e\n", torqueSum);

    }
    else if( answer=="plot Cp(y)" )
    {
      if (numberOfFaces <= 0)
      {
	printf("You must first select the faces where you want the pressure plotted\n");
	continue;
      }

      aString name[]={"-Cp","bbb"};  //
      ps.erase();

      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

      for (int i=0; i<numberOfFaces; i++)
      {
	
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	
	MappedGrid & c = cg[grid];
	c.update(MappedGrid::THEvertex);
      
	realArray & vertex = c.vertex();
      
	realArray y,p;
	Index I1,I2,I3;
	getBoundaryIndex(c.gridIndexRange(),side,axis,I1,I2,I3);

	const int pc=0;
	p.redim(I1,I2,I3);
	p(I1,I2,I3)=u[grid](I1,I2,I3,pc)/scale;
	Range I=I1.getLength()*I2.getLength()*I3.getLength();
	p.reshape(I);
      
	y.redim(I1,I2,I3);
	y(I1,I2,I3)=vertex(I1,I2,I3,axis2);
	y.reshape(I);

	if (i==numberOfFaces-1) // turn on the interactive mode for the last piece
	{
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
	}
	

	PlotIt::plot(ps, y,p,"Pressure coeff","y",name,psp );
      }
      
    }
    else if( answer=="plot Cf(x)" )
    {
      if (numberOfFaces <= 0)
      {
	printf("You must first select the faces where you want the forces to be plotted\n");
	continue;
      }
      
      const int pc=0, uc=1, vc=2;

      // we should integrate the total stress over the body
      //   tau_ij  =  -p delta_ij + nu*( d_j u_i + d_i u_j )
      // force = tau.n = -p n_i + nu*( (d_j u_i) n_j + (d_i u_j)n_j )
      Range all;
      RealCompositeGridFunction f(cg),force(cg,all,all,all,3);
      CompositeGridOperators op(cg);
      u.setOperators(op);
      
      Index I1,I2,I3;
      int i;
      
      // force
      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	

	cg[grid].update(MappedGrid::THEvertexBoundaryNormal);
	realArray & normal = cg[grid].vertexBoundaryNormal(side,axis);
      
	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
        realArray ux; ux = u[grid].x(I1,I2,I3,Range(uc,vc));
        realArray uy; uy = u[grid].y(I1,I2,I3,Range(uc,vc));
        // x-component (the normal is inward(?))
	force[grid](I1,I2,I3,0)=-(-u[grid](I1,I2,I3,pc)*normal(I1,I2,I3,axis1) +
	  nu*( 2.*ux(I1,I2,I3,uc) * normal(I1,I2,I3,axis1) + 
	       (uy(I1,I2,I3,uc) + ux(I1,I2,I3,vc)) * normal(I1,I2,I3,axis2) ) );
        // y-component	
	force[grid](I1,I2,I3,1)=-(-u[grid](I1,I2,I3,pc)*normal(I1,I2,I3,axis2) +
	  nu*( 2.*uy(I1,I2,I3,vc) * normal(I1,I2,I3,axis2) + 
	       (uy(I1,I2,I3,uc) + ux(I1,I2,I3,vc)) * normal(I1,I2,I3,axis1) ) );
	
      }
      // plot shear stress
      aString name[]={"-Cf","bbb"};  //
      ps.erase();
      psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,TRUE);

      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	
	MappedGrid & c = cg[grid];
	c.update(MappedGrid::THEvertex);
	realArray & vertex = c.vertex();

	cg[grid].update(MappedGrid::THEvertexBoundaryNormal);
	realArray & normal = cg[grid].vertexBoundaryNormal(side,axis);
      
	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
	Range I=I1.getLength()*I2.getLength()*I3.getLength();

	realArray x,tau;
	x.redim(I1,I2,I3);
	x(I1,I2,I3)=vertex(I1,I2,I3,axis1);
	x.reshape(I);

	tau.redim(I1,I2,I3);
	tau(I1,I2,I3) = ( force[grid](I1,I2,I3,axis1) * normal(I1,I2,I3,axis2) -
	  force[grid](I1,I2,I3,axis2) * normal(I1,I2,I3,axis1) ) / scale;
	tau.reshape(I);

	if (i==numberOfFaces-1) // turn on the interactive mode for the last piece
	{
	  psp.set(GI_PLOT_THE_OBJECT_AND_EXIT,FALSE);
	}

	PlotIt::plot(ps, x,tau,"Skin friction coeff","x",name,psp );
      }

      

    }
    else if( answer=="compute lift/drag" )
    {
      if (numberOfFaces <= 0)
      {
	printf("You must first select the faces where you want the forces to be integrated\n");
	continue;
      }
      
      const int pc=0, uc=1, vc=2;

      // we should integrate the total stress over the body
      //   tau_ij  =  -p delta_ij + nu*( d_j u_i + d_i u_j )
      // force = tau.n = -p n_i + nu*( (d_j u_i) n_j + (d_i u_j)n_j )
      Range all;
      RealCompositeGridFunction f(cg),force(cg,all,all,all,3);
      CompositeGridOperators op(cg);
      u.setOperators(op);
      
      f=1;
      
      // compute the integral on a part of the boundary.
      
      real pIntegral = integrate.surfaceIntegral(f,surfaceID);        

      printf("circumference(p)=%e \n",pIntegral);

      // lift and drag
      //  ..integrate  tau*n
      Index I1,I2,I3;
      int i;
      
      // force
      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	

	cg[grid].update(MappedGrid::THEvertexBoundaryNormal);
	realArray & normal = cg[grid].vertexBoundaryNormal(side,axis);
      
	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
        realArray ux; ux = u[grid].x(I1,I2,I3,Range(uc,vc));
        realArray uy; uy = u[grid].y(I1,I2,I3,Range(uc,vc));
        // x-component (the normal is inward(?))
	force[grid](I1,I2,I3,0)=-(-u[grid](I1,I2,I3,pc)*normal(I1,I2,I3,axis1) +
	  nu*( 2.*ux(I1,I2,I3,uc) * normal(I1,I2,I3,axis1) + 
	       (uy(I1,I2,I3,uc) + ux(I1,I2,I3,vc)) * normal(I1,I2,I3,axis2) ) );
         // y-component	
	force[grid](I1,I2,I3,1)=-(-u[grid](I1,I2,I3,pc)*normal(I1,I2,I3,axis2) +
	  nu*( 2.*uy(I1,I2,I3,vc) * normal(I1,I2,I3,axis2) + 
	       (uy(I1,I2,I3,uc) + ux(I1,I2,I3,vc)) * normal(I1,I2,I3,axis1) ) );
	
      }
      // drag
      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	

	cg[grid].update(MappedGrid::THEvertexBoundaryNormal);
	realArray & normal = cg[grid].vertexBoundaryNormal(side,axis);
      
	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
        //  	f[grid](I1,I2,I3)=u[grid](I1,I2,I3,pc);
        //  	f[grid](I1,I2,I3)*=normal(I1,I2,I3,axis1);   // component 1 of the normal (x)

	f[grid](I1,I2,I3)=force[grid](I1,I2,I3,0);
      }
      
      real drag = integrate.surfaceIntegral(f,surfaceID);        

      // lift
      for (i=0; i<numberOfFaces; i++)
      {
	side = boundary(0,i);
	axis = boundary(1,i);
	grid = boundary(2,i);
	

	cg[grid].update(MappedGrid::THEvertexBoundaryNormal);
	realArray & normal = cg[grid].vertexBoundaryNormal(side,axis);
      
	getBoundaryIndex(cg[grid].gridIndexRange(),side,axis,I1,I2,I3);
        //  	f[grid](I1,I2,I3)=u[grid](I1,I2,I3,pc);
        //  	f[grid](I1,I2,I3)*=normal(I1,I2,I3,axis2);   // component 2 of the normal (y)

	f[grid](I1,I2,I3)=force[grid](I1,I2,I3,1);
      }
      
      real lift = integrate.surfaceIntegral(f,surfaceID);        

      // scale lift and drag by rho*U^2 * L 
      // L=arclength
      
      printf("lift=%e, C_L=%8.6f, drag=%e, C_D=%8.6f \n",lift,lift/scale, drag,drag/scale);

    }
    else if( answer=="exit" )
    {
      break;
    }

  }

  Overture::finish();      
  return 0;
}


