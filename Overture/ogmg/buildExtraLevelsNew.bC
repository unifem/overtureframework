#include "Ogmg.h"
#include "display.h"
#include "Ogen.h"
#include "ParallelUtility.h"
#include "ParallelGridUtility.h"
#include "InterpolationData.h"
#include "CanInterpolate.h"
#include "LoadBalancer.h"
#include <algorithm>

int checkGrid( CompositeGrid & cg, GenericGraphicsInterface *ps =0, int debug=0 );

int 
displayMaskLaTeX( const intArray & mask, 
		  const aString & label =nullString,
		  FILE *file = NULL ,
		  const DisplayParameters *displayParameters = NULL );

#define  FOR_3(i1,i2,i3,I1,I2,I3)\
  I1Base=I1.getBase(); I2Base=I2.getBase(); I3Base=I3.getBase();\
  I1Bound=I1.getBound(); I2Bound=I2.getBound(); I3Bound=I3.getBound();\
  for( i3=I3Base; i3<=I3Bound; i3++ )  \
  for( i2=I2Base; i2<=I2Bound; i2++ )  \
  for( i1=I1Base; i1<=I1Bound; i1++ )

#define  FOR_3D(i1,i2,i3,I1,I2,I3)\
  int I1Base,I2Base,I3Base;\
  int I1Bound,I2Bound,I3Bound;\
  I1Base=I1.getBase(); I2Base=I2.getBase(); I3Base=I3.getBase();\
  I1Bound=I1.getBound(); I2Bound=I2.getBound(); I3Bound=I3.getBound();\
  for( i3=I3Base; i3<=I3Bound; i3++ )  \
  for( i2=I2Base; i2<=I2Bound; i2++ )  \
  for( i1=I1Base; i1<=I1Bound; i1++ )

// ========================================================================================
/// \brief: Limit the bounds of Iv to lie within the bounds of the array mask
// ========================================================================================
bool 
getLocalBounds( const intSerialArray & mask, Index Iv[3] )
{
  bool ok=true;
  for( int axis=0; axis<3; axis++ )
  {
    int ia=max( mask.getBase(axis) ,Iv[axis].getBase()  );  // *note* -1
    int ib=min( mask.getBound(axis),Iv[axis].getBound() );  // *note* +1

    if( ib>=ia )
    {
      Iv[axis]= Range(ia,ib);
    }
    else
    {
      return false;
    }
  }

  return true;
}


// ========================================================================================
// class use to sort the interpolationPoint array
// 
// In 2d: we sort into ascending order of a(i,0) and secondarily in ascending order of a(i,1)
//   i.e. we sort on  a(i,1)+n*a(i,0) where n=a.getLength(0)
// In 3d: we also sort thirdly on a(i,2)
// ========================================================================================
namespace{
  struct SortCmp2d {
    SortCmp2d(const IntegerArray &a_) : a(a_) { n=a.getLength(0); }
    bool operator() ( int i, int j )
      { return a(i,1)+n*a(i,0) < a(j,1)+n*a(j,0); }
    const IntegerArray &a;
    int n;
  };
  struct SortCmp3d {
  SortCmp3d(const IntegerArray &a_) : a(a_) { n=a.getLength(0); n2=n*n; }
    bool operator() ( int i, int j )
      { return a(i,2)+n*a(i,1)+n2*a(i,0) < a(j,2)+n*a(j,1)+n2*a(j,0); }
    const IntegerArray &a;
    int n,n2;
  };
}

// moved to ParallelGridUtility:
// namespace
// {
// void
// sortLocalInterpolationPoints( CompositeGrid & cg )
// // ============================================================================================
// //  /Description:
// //     Sort the local interpolation points by donor grid and build the interpolationStartEndIndex
// //
// // ============================================================================================
// {
//   const int numberOfComponentGrids=cg.numberOfComponentGrids();
//   const int numberOfDimensions=cg.numberOfDimensions();

//   if( Ogmg::debug & 4 )
//     printF(" ---> sortLocalInterpolationPoints numberOfComponentGrids=%i <---- \n",numberOfComponentGrids);

// //   interpolationStartEndIndex.redim(4,numberOfComponentGrids,numberOfComponentGrids);
// //   interpolationStartEndIndex = -1;

//   IntegerArray & interpolationStartEndIndex = cg.interpolationStartEndIndex;
//   interpolationStartEndIndex=-1;

//   IntegerArray gridStart(numberOfComponentGrids), ng(numberOfComponentGrids);
//   for( int grid=0; grid<numberOfComponentGrids; grid++ )
//   {
//     const int nig=cg->numberOfInterpolationPointsLocal(grid);

//     if( nig > 0 )
//     {
//       intSerialArray & interpoleeGrid             = cg->interpoleeGridLocal[grid]; 
//       intSerialArray & interpolationPoint         = cg->interpolationPointLocal[grid];
//       intSerialArray & interpoleeLocation         = cg->interpoleeLocationLocal[grid];
//       intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid];
//       realSerialArray & interpolationCoordinates  = cg->interpolationCoordinatesLocal[grid];


//       int *interpoleeLocationp = interpoleeLocation.Array_Descriptor.Array_View_Pointer1;
//       const int interpoleeLocationDim0=interpoleeLocation.getRawDataSize(0);
// #define INTERPOLEELOCATION(i0,i1) interpoleeLocationp[i0+interpoleeLocationDim0*(i1)]
	  
//       int *interpolationPointp = interpolationPoint.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationPointDim0=interpolationPoint.getRawDataSize(0);
// #define INTERPOLATIONPOINT(i0,i1) interpolationPointp[i0+interpolationPointDim0*(i1)]
	  
//       real *interpolationCoordinatesp = interpolationCoordinates.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationCoordinatesDim0=interpolationCoordinates.getRawDataSize(0);
// #define INTERPOLATIONCOORDINATES(i0,i1) interpolationCoordinatesp[i0+interpolationCoordinatesDim0*(i1)]
	  
//       int * interpoleeGridp = interpoleeGrid.Array_Descriptor.Array_View_Pointer0;
// #define INTERPOLEEGRID(i0) interpoleeGridp[i0]

//       int * variableInterpolationWidthp = variableInterpolationWidth.Array_Descriptor.Array_View_Pointer0;
// #define VARIABLEINTERPOLATIONWIDTH(i0) variableInterpolationWidthp[i0]

	  
//       // temp arrays to hold sorted arrays:
//       intSerialArray interpoleeGrid1(nig);
//       intSerialArray interpolationPoint1(nig,numberOfDimensions);
//       intSerialArray interpoleeLocation1(nig, numberOfDimensions);
//       intSerialArray variableInterpolationWidth1(nig);
//       realSerialArray interpolationCoordinates1(nig,numberOfDimensions);

//       int *interpoleeLocation1p = interpoleeLocation1.Array_Descriptor.Array_View_Pointer1;
//       const int interpoleeLocation1Dim0=interpoleeLocation1.getRawDataSize(0);
// #define INTERPOLEELOCATION1(i0,i1) interpoleeLocation1p[i0+interpoleeLocation1Dim0*(i1)]
	  
//       int *interpolationPoint1p = interpolationPoint1.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationPoint1Dim0=interpolationPoint1.getRawDataSize(0);
// #define INTERPOLATIONPOINT1(i0,i1) interpolationPoint1p[i0+interpolationPoint1Dim0*(i1)]
	  
//       real *interpolationCoordinates1p = interpolationCoordinates1.Array_Descriptor.Array_View_Pointer1;
//       const int interpolationCoordinates1Dim0=interpolationCoordinates1.getRawDataSize(0);
// #define INTERPOLATIONCOORDINATES1(i0,i1) interpolationCoordinates1p[i0+interpolationCoordinates1Dim0*(i1)]
	  
//       int * interpoleeGrid1p = interpoleeGrid1.Array_Descriptor.Array_View_Pointer0;
// #define INTERPOLEEGRID1(i0) interpoleeGrid1p[i0]

//       int * variableInterpolationWidth1p = variableInterpolationWidth1.Array_Descriptor.Array_View_Pointer0;
// #define VARIABLEINTERPOLATIONWIDTH1(i0) variableInterpolationWidth1p[i0]

//       int * ngp = ng.Array_Descriptor.Array_View_Pointer0;
// #define NG(i0) ngp[i0]

//       int * gridStartp = gridStart.Array_Descriptor.Array_View_Pointer0;
// #define GRIDSTART(i0) gridStartp[i0]
  
//       if( false )
//       {
//         printF(" grid=%i, nig=%i\n",grid,nig);
// 	::display(interpolationPoint,"interpolationPoint");
// 	::display(interpoleeGrid,"interpoleeGrid");
//       }
      

//       // order the interpolation points by interpolee grid.
//       ng=0;
//       const int ia=interpolationPoint.getBase(0), ib=interpolationPoint.getBound(0);
//       assert( ia==0 );
//       for( int i=ia; i<=ib; i++ )
// 	NG(INTERPOLEEGRID(i))++;

//       //	  ng.display("NG");

//       GRIDSTART(0)=0;
//       int grid2;
//       for( grid2=1; grid2<numberOfComponentGrids; grid2++ )
// 	GRIDSTART(grid2)=GRIDSTART(grid2-1)+NG(grid2-1);
	  
//       //	  gridStart.display("GRIDSTART");
//       // ***** we need to assign the interpolationStartEndIndex 
//       // **** this needs to be set on multigridLevel[0] too ********
	  
//       // for now we assume that the interpolation is implicit on coarser levels *** fix this ***
	  
//       //kkc left over from ogmg	  cg1.interpolationIsAllExplicit()=false;
//       //kkc left over from ogmg	  cg1.interpolationIsAllImplicit()=true;

//       //kkc left over from ogmg :
//       for( grid2=0; grid2<numberOfComponentGrids; grid2++ )
//       {
// 	//interpolationStartEndIndex(0,grid,grid2)=-1;
// 	//interpolationStartEndIndex(1,grid,grid2)=-1;
// 	//interpolationStartEndIndex(2,grid,grid2)=-1;
// 	//interpolationStartEndIndex(3,grid,grid2)=-1;
	
// 	if( NG(grid2)>0 )
// 	{
// 	  interpolationStartEndIndex(0,grid,grid2)=GRIDSTART(grid2);              // start value
// 	  interpolationStartEndIndex(1,grid,grid2)=GRIDSTART(grid2)+NG(grid2)-1;  // end value
// 	  if( true || cg.interpolationIsImplicit(grid,grid2,0) )
// 	    interpolationStartEndIndex(2,grid,grid2)= interpolationStartEndIndex(1,grid,grid2);
// 	  // fix this: put any implicit points first
// 	  // 	   else if( ngi(grid2)>0 )
// 	  // 	     interpolationStartEndIndex(2,grid,grid2)=GRIDSTART(grid2)+ngi(grid2)-1; // end value for implicit pts.
// 	}
//       }
	  
//       if( numberOfDimensions==2 )
//       {
// 	for( int i=ia; i<=ib; i++ )
// 	{
// 	  grid2=INTERPOLEEGRID(i);
// 	  int j=GRIDSTART(grid2);

// 	  INTERPOLEEGRID1(j)=grid2;
// 	  INTERPOLATIONPOINT1(j,0)=INTERPOLATIONPOINT(i,0);
// 	  INTERPOLATIONPOINT1(j,1)=INTERPOLATIONPOINT(i,1);
// 	  INTERPOLEELOCATION1(j,0)=INTERPOLEELOCATION(i,0);
// 	  INTERPOLEELOCATION1(j,1)=INTERPOLEELOCATION(i,1);
// 	  INTERPOLATIONCOORDINATES1(j,0)=INTERPOLATIONCOORDINATES(i,0);
// 	  INTERPOLATIONCOORDINATES1(j,1)=INTERPOLATIONCOORDINATES(i,1);
// 	  VARIABLEINTERPOLATIONWIDTH1(j)=VARIABLEINTERPOLATIONWIDTH(i);
		  
// 	  GRIDSTART(grid2)++;
// 	}
//       }
//       else
//       {
// 	for( int i=ia; i<=ib; i++ )
// 	{
// 	  grid2=INTERPOLEEGRID(i);
// 	  int j=GRIDSTART(grid2);
// 	  INTERPOLEEGRID1(j)=grid2;
// 	  INTERPOLATIONPOINT1(j,0)=INTERPOLATIONPOINT(i,0);
// 	  INTERPOLATIONPOINT1(j,1)=INTERPOLATIONPOINT(i,1);
// 	  INTERPOLATIONPOINT1(j,2)=INTERPOLATIONPOINT(i,2);
// 	  INTERPOLEELOCATION1(j,0)=INTERPOLEELOCATION(i,0);
// 	  INTERPOLEELOCATION1(j,1)=INTERPOLEELOCATION(i,1);
// 	  INTERPOLEELOCATION1(j,2)=INTERPOLEELOCATION(i,2);
// 	  INTERPOLATIONCOORDINATES1(j,0)=INTERPOLATIONCOORDINATES(i,0);
// 	  INTERPOLATIONCOORDINATES1(j,1)=INTERPOLATIONCOORDINATES(i,1);
// 	  INTERPOLATIONCOORDINATES1(j,2)=INTERPOLATIONCOORDINATES(i,2);
// 	  VARIABLEINTERPOLATIONWIDTH1(j)=VARIABLEINTERPOLATIONWIDTH(i);
		  
// 	  GRIDSTART(grid2)++;
// 	}
//       }
	  
//       //      interpoleeLocation1.display("IL after");

//       interpoleeGrid.reference(interpoleeGrid1);
//       interpolationPoint.reference(interpolationPoint1);
//       interpoleeLocation.reference(interpoleeLocation1);
//       variableInterpolationWidth.reference(variableInterpolationWidth1);
//       interpolationCoordinates.reference(interpolationCoordinates1);
      

//     } // if nig>0
    
//   }
//   //  interpolationStartEndIndex.display("ISTARTEND");
	  
// }
// }


//=======================================================================
// Mark coarse grid mask at interp points outside bc=0 boundaries 
//=======================================================================
#beginMacro markCoarseMaskAtBoundaries()

 // We are going to mark new interpolation points as those with mask==0 but neighbours mask>0
 // We do not want the ghost values to play a role in this marking so set mask==0 at ghost points.
 //        set mask==0 at on both ghost lines outside bc!=0 boundaries
 // ****** set mask==0 at 2nd ghost line outside interp boundaries.!
for( int axis=0; axis<numberOfDimensions; axis++ )
{
  for( int side=Start; side<=End; side++ )
  {
    if( bcLocal1(side,axis)==0 )
    {
      // *new* way : explicitly mark ghost points  -- now we don't need extra ghost points
      if( orderOfAccuracy==2 )
      {
	// If the point on the boundary is a discretization point then we need to mark the
	// the first ghost line as interpolation 
	// const IntegerArray & gir = c.gridIndexRange();
	const IntegerArray & gir = gidLocal1;

	getBoundaryIndex(gidLocal1,side,axis,I1,I2,I3); // boundary

	int i1,i2,i3;
	is1=is2=is3=0;
	isv[axis]=1-2*side;
	FOR_3(i1,i2,i3,I1,I2,I3)
	{
	  if( MASK1(i1,i2,i3)>0 )
	    MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
	  else
	    MASK1(i1-is1,i2-is2,i3-is3)=0;
	}

	// **** Now mark corners and edges **** 030829
	//
	//      |
	//      +
	//      |       bc=0 
	//      +--+--+--+--+--+
	//   X  I  I  I  I
	//
	//      Some points are marked twice
	// (we cannot include this in the above loop since the mask is zero at ghost points)

	const int axisp1 = (axis+1) % numberOfDimensions;
	if( true)
	{
	  for( int side2=0; side2<=1; side2++ )
	  {
	    // corner in 2D, or edge 3D   ----------------------- CHECK ME 091204 -------------------------
	    if( bcLocal1(side2,axisp1)>=0 ) // *wdh* 100101 -- do not set internal parallel sides 
	    {
	      Iv[axisp1]= gidLocal1(side2,axisp1); 
	      isv[axisp1]=1-2*side2;
	      FOR_3(i1,i2,i3,I1,I2,I3)
	      {
		if( MASK1(i1,i2,i3)>0 )
		  MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
		else
		  MASK1(i1-is1,i2-is2,i3-is3)=0;
	      }
	    }
		
	    if( numberOfDimensions==3 )
	    {
	      // corners in 3D
	      const int axisp2=(axis+2) % numberOfDimensions;
	      for( int side3=0; side3<=1; side3++ )
	      {
		if( bcLocal1(side3,axisp2)>=0 ) // *wdh* 100101 -- do not set internal parallel sides
		{
		  Iv[axisp2]= gidLocal1(side3,axisp2);
		  isv[axisp2]=1-2*side3;
		  FOR_3(i1,i2,i3,I1,I2,I3)
		  {
		    if( MASK1(i1,i2,i3)>0 )
		      MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
		    else
		      MASK1(i1-is1,i2-is2,i3-is3)=0;
		  }
		}
	      }
	    }
	  }
	} // end if false
	      
	if( numberOfDimensions==3 )
	{
	  // other edge in 3D
	  Iv[axisp1]=Range(gidLocal1(0,axisp1),gidLocal1(1,axisp1)); // reset
	  isv[axisp1]=0;
		    
	  const int axisp2=(axis+2) % numberOfDimensions;
	  for( int side3=0; side3<=1; side3++ )
	  {
	    if( bcLocal1(side3,axisp2)>=0 ) // *wdh* 100101 -- do not set internal parallel sides
	    {
	      Iv[axisp2]= gidLocal1(side3,axisp2);
	      isv[axisp2]=1-2*side3;
	      FOR_3(i1,i2,i3,I1,I2,I3)
	      {
		if( MASK1(i1,i2,i3)>0 )
		  MASK1(i1-is1,i2-is2,i3-is3)=MappedGrid::ISinterpolationPoint;
		else
		  MASK1(i1-is1,i2-is2,i3-is3)=0;
	      }
	    }
	  }
		
	}
      }
      else if( orderOfAccuracy==4 )
      {
	// If the point on the 1st ghost line is a discretization point then we need to mark the
	// the second ghost line as interpolation 
	getGhostIndex(gidLocal1,side,axis,I1,I2,I3,1,2); // ghost line 1, 2 extra
	getGhostIndex(gidLocal1,side,axis,Ig1,Ig2,Ig3,2,2);  // ghost line 2, 2 extra

	where( mask1(I1,I2,I3)!=0 )
	{
	  mask1(Ig1,Ig2,Ig3)=MappedGrid::ISinterpolationPoint;
	}
	otherwise()
	{
	  mask1(Ig1,Ig2,Ig3)=0;
	}

	// *wdh* added 030614

	// If a point on the boundary is interpolation then we need to mark the first ghost line
	// as interpolation
	getBoundaryIndex(gidLocal1,side,axis,I1,I2,I3,2); // boundary, 1 or 2 extra
	getGhostIndex(gidLocal1,side,axis,Ig1,Ig2,Ig3,1,2);  // ghost line, 1 or 2 extra
	      
	where( mask1(I1,I2,I3)<0 )
	{
	  mask1(Ig1,Ig2,Ig3)=MappedGrid::ISinterpolationPoint;
	}

      }

    }
    else  // mg1.bc !=0 : 
    {
      if( false )
      {
	// --- needs to be fixed for parallel ghost --
	// this not needed in parallel I think 
	getGhostIndex(gidLocal1,side,axis,I1,I2,I3,2,2); // ghost line 2, 2 extra
	mask1(I1,I2,I3)=0;

	getGhostIndex(gidLocal1,side,axis,I1,I2,I3,1,2); // ghost line 1, 2 extra
	mask1(I1,I2,I3)=0;
      }
	    
    }
  }
 } // end for axis 
#endMacro


// ====================================================================================
// Macro: Evaluate the x-coordinates of the interpolation points
//   IA(i,0:3) (input) : index locations of interp points
// ====================================================================================
#beginMacro getInterpolationPointPositions(ni)

if( ni>0 )
  xa.redim(ni,numberOfDimensions);

xap = xa.Array_Descriptor.Array_View_Pointer1;
xaDim0=xa.getRawDataSize(0);

if( isRectangular )
{
  if( numberOfDimensions==2 )
  {
    for( int i=0; i<ni; i++ )
    {
      int i1=IA(i,0); i2=IA(i,1); i3=IA(i,2); 
      XA(i,0)=CENTER10(i1,i2,i3);
      XA(i,1)=CENTER11(i1,i2,i3);
    }
  }
  else
  {
    for( int i=0; i<ni; i++ )
    {
      int i1=IA(i,0); i2=IA(i,1); i3=IA(i,2); 
      XA(i,0)=CENTER10(i1,i2,i3);
      XA(i,1)=CENTER11(i1,i2,i3);
      XA(i,2)=CENTER12(i1,i2,i3);
    }
  }
}
else
{ 
  // curvilinear case 
#ifdef USE_PPP
  // in parallel we cannot rely on the center1 array being on this processor
  RealArray ra;
  if( ni>0 )
    ra.redim(ni,numberOfDimensions);

  real *rap = ra.Array_Descriptor.Array_View_Pointer1;
  const int raDim0=ra.getRawDataSize(0);
#define RA(i0,i1) rap[i0+xaDim0*(i1)]

  const IntegerArray & gid1 = mg1.gridIndexRange();
  const RealArray & dr1 = mg1.gridSpacing();
  for( int i=0; i<ni; i++ )
  {
    for( int axis=0; axis<numberOfDimensions; axis++ )
      RA(i,axis)=(IA(i,axis)-gid1(0,axis))*dr1(axis);   // r-coordinates of the point 
  }
  Mapping & map1 = mg1.mapping().getMapping();
  map1.mapS(ra,xa);
	
#else
  for( int i=0; i<ni; i++ )
  {
    int i1=IA(i,0); i2=IA(i,1); i3=IA(i,2);
    for( int axis=0; axis<numberOfDimensions; axis++ )
      XA(i,axis)=CENTER(i1,i2,i3,axis);
  }
#endif

}

if( debug & 4 )
{
  fprintf(pDebugFile,"\n ** level=%i grid=%i : Here are the x-coords of the interp points to be found\n",
	  level,grid);
  for( int i=0; i<ni; i++ )
  {
    fprintf(pDebugFile," pt i=%5i (%5i,%5i,%5i) x=(%9.2e,%9.2e,%9.2e)\n",i,IA(i,0),IA(i,1),IA(i,2),XA(i,0),XA(i,1),
	    (numberOfDimensions==2 ? 0. : XA(i,2)));
  }
}
#endMacro

// =======================================================================================
//  Macro: Evaluate the "r" coordinates of a list of points
//  ib(i,*) (input) : list of points 
//  xa(i,*) (input) : x-coords of the points  
// =======================================================================================
#beginMacro getExtraInterpCoords(numberOfExtraInterpolationPoints)
if( numberOfExtraInterpolationPoints>0 )
  r.redim(numberOfExtraInterpolationPoints,3);

rp = r.Array_Descriptor.Array_View_Pointer1;
rDim0=r.getRawDataSize(0);

Range Ri=numberOfExtraInterpolationPoints, all;

if( numberOfExtraInterpolationPoints>0 )
  getInterpolationCoordinatesNew(cg0,cg1,ib(Ri,all),xa, grid,gridsToCheck, r,
				 isRectangular,iv0,dx0,xab0,iv1,dx1,xab1,ipd,ia,donorDist);
else
{
  // assert( ib.getLength(0)==0 );
  ib.redim(0);
  getInterpolationCoordinatesNew(cg0,cg1,ib,xa, grid,gridsToCheck, r,
				 isRectangular,iv0,dx0,xab0,iv1,dx1,xab1, ipd,ia,donorDist);
}

if( false )
{
  // check with old "new" version

  RealArray r2;
  
  if( numberOfExtraInterpolationPoints>0 )
    r2.redim(numberOfExtraInterpolationPoints,3);

  Range Ri=numberOfExtraInterpolationPoints, all;

  if( numberOfExtraInterpolationPoints>0 )
    getInterpolationCoordinatesNewOld(cg0,cg1,ib(Ri,all),xa, grid,gridsToCheck, r2,
				      isRectangular,iv0,dx0,xab0,iv1,dx1,xab1,ipd);
  else
  {
    // assert( ib.getLength(0)==0 );
    ib.redim(0);
    getInterpolationCoordinatesNewOld(cg0,cg1,ib,xa, grid,gridsToCheck, r2,
				      isRectangular,iv0,dx0,xab0,iv1,dx1,xab1, ipd);
  }

  if( numberOfExtraInterpolationPoints>0 )
  {
    real maxDiff=max(fabs(r(Ri,Rx)-r2(Ri,Rx)));
    printf("Ogmg::buildExtraLevelsNew::getExtraInterpCoords: myid=%i : NEW-OLD = %9.3e\n",myid,maxDiff);
  }
  

}

#endMacro


//\begin{>>OgmgInclude.tex}{\subsection{buildExtraLevels}}
int Ogmg::
buildExtraLevelsNew(CompositeGrid & mg)
// ========================================================================================
//     *** NEW parallel version *** 091203 
//  /Description: 
//       Build extra multigrid levels. This routine will create coarser levels automatically.
// The tricky part is to determine how to interpolate on the new coarser levels.
// After a grid is coarsened it may no longer have enough interpolation points. We add new interpolation
// points to fill in the gaps. The width of the interpolation stencil is reduced, on a point by point
// basis, if necessary.
//
// /mg (input/output): 
//\end{OgmgInclude.tex} 
// =========================================================================================
{
  real time0=getCPU();
  const int np= max(1,Communication_Manager::numberOfProcessors());
  CompositeGrid & mgcg = multigridCompositeGrid();
  
  int debugSave=debug;

  // debug=7;  // ***
  int debugb=debug; // 7; // debug

  // printF("\n ********************** buildExtraLevels debugb=%i **************************\n",debugb);

  // --- The CompositeGrid mg is supplied by the USER and we do not want to change it.
  //      Instead we build another copy, mgcg that will contain the extra multigrid levels.


  if( parameters.saveGridCheckFile && myid==0 )
  {
    printF(" buildExtraLevelsNew: parameters.saveGridCheckFile=%i\n",(int)parameters.saveGridCheckFile);
    // save a check file containing information about the coarse grid levels
    if( gridCheckFile==NULL )
    {
      aString name="ogmg";
      if( numberOfInstances>1 )
      {
	// Give different names to the grid check file if we have more than 1 instance of Ogmg:
	sPrintF(name,"ogmg%i",numberOfInstances);
      }
      aString gridCheckFileName;
      sPrintF(gridCheckFileName,"%s.%s.coarseGrids.NP%i.check",(const char*)name,(const char*)gridName,np);
      gridCheckFile = fopen((const char*)gridCheckFileName,"w" );     
      printF("Saving the check file %s\n",(const char*)gridCheckFileName);
    }
  }

  // *NOTE* For moving grid do the following; otherwise the statement "mgcg=mg" seems to over-write
  //    the MappedGrids in the version of "mg" that was used in the previous call!
  // mgcg.destroy(CompositeGrid::EVERYTHING);  // trouble with this
  if( mgcg.numberOfComponentGrids()>0 )
  {
    for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
    {
      mgcg[grid].breakReference();
    }
  }
  

  int grid;
  if( false )
  {
    
    mgcg=mg;  // deep copy for now *******************************************************************************

  }
  else if( true )
  {
    // mgcg.reference(mg);  // problems with this, mg seems to get changed below

    // mgcg.destroy(CompositeGrid::EVERYTHING);  // *wdh* 040831 -- added to fix bug with moving grids ---
    
    mgcg=mg;
    // now reference the grids so we don't keep two copies of the big arrays.
    
    for( grid=0; grid<mg.numberOfComponentGrids(); grid++ )
    {
      mgcg[grid].reference(mg[grid]);
    }
  
    // we could also reference interpolation arrays.

    mgcg.updateReferences();

    if( false )
    {
      mg.interpolationStartEndIndex.display("buildExtraLevels: mg.interpolationStartEndIndex");
      mgcg.interpolationStartEndIndex.display("buildExtraLevels: mgcg.interpolationStartEndIndex");
    }
    
  }
  else
  { 
    // we need to reference MappedGrids and Interpolation info.


    // this does not work
    // mgcg.setNumberOfDimensionsAndGrids(mg.numberOfDimensions(),mg.numberOfComponentGrids());

    for( grid=0; grid<mg.numberOfComponentGrids(); grid++ )
    {
      // mgcg[grid].reference(mg[grid].mapping());
      // mgcg[grid].reference(mg[grid]);
      mgcg.add(mg[grid]);           // add will make a reference
    }
    mgcg.updateReferences();
    // ** mgcg.update(MappedGrid::THEcenter);
  
    // mgcg.update(CompositeGrid::THElists | CompositeGrid::THEmultigridLevel);
    // mgcg.update(CompositeGrid::THElists | CompositeGrid::THEmultigridLevel);
  }
  mgcg.update(CompositeGrid::THEmultigridLevel);


  if( false )
    mgcg.multigridLevel[0].interpolationStartEndIndex.display("buildExtraLevels: after mgcg.update(CompositeGrid::THEmultigridLevel): mgcg.multigridLevel[0].interpolationStartEndIndex");
  
  // ***** fix this in CompositeGrid ****
  mgcg.multigridLevel[0].interpolationStartEndIndex=mgcg.interpolationStartEndIndex;
  

  const int numberOfDimensions = mgcg.numberOfDimensions();
  IntegerArray factor(3);
  factor=2;

  const int level0=mg.numberOfMultigridLevels()-1;
  int l, level;
  Range Rx=mgcg.numberOfDimensions();

  for( grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
  {
    for( int axis=0; axis<numberOfDimensions; axis++ )
    {
      for( int side=Start; side<=End; side++ )
      {
	if( mgcg[grid].boundaryCondition()(side,axis) > 0 && mgcg[grid].numberOfGhostPoints()(side,axis)<2 )
	{
	  printF("Ogmg::buildExtraLevels:ERROR: The grid must be made with numberOfGhostPoints>=2 "
                  "on all physical boundaries\n");
          Overture::abort();
	}
      }
    }
  }



  // --- determine the maximum number of levels we can add. For now we must be able to coarsen by
  //     a factor of two along each axis.

  IntegerArray maxLevels(mgcg.numberOfComponentGrids()); // number of levels we can add to each grid
  maxLevels=0;
  const int minimumNumberOfPointsOnCoarseGrid=orderOfAccuracy/2;
  for( grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
  {
    const IntegerArray & gridIndexRange = mgcg.multigridLevel[level0][grid].gridIndexRange();

    // display((gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)),"gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)");

    for( int m=0; m<parameters.maximumNumberOfExtraLevels; m++ )
    {
      const int pow2 = (int)pow(2,m+1);

      // printF("pow2 = %i\n",pow2);
      
//       display(((gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)) % pow2),
//            "(gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)) % pow2 )");
      
      bool powerOfTwo=TRUE;
      for( int axis=0; axis<numberOfDimensions; axis++ )
      {
	if( (((gridIndexRange(End,axis)-gridIndexRange(Start,axis)) % pow2 )!=0)  || // not divisible by 2
	    (((gridIndexRange(End,axis)-gridIndexRange(Start,axis))/pow2) 
                            <=minimumNumberOfPointsOnCoarseGrid ) )// at least this many points on coarse grid
	{
	  powerOfTwo=FALSE;
          break;
	}
      }
      if( !powerOfTwo )
        break;

// A++ bug:
//       if( (max( (gridIndexRange(End,Rx)-gridIndexRange(Start,Rx)) % pow2 )!=0)  || // divisible by 2
//           (min( (gridIndexRange(End,Rx)-gridIndexRange(Start,Rx))/pow2) <2 ) ) // at least 1 points on coarse grid
//       {
// 	// this grid cannot be coarsened anymore
// 	break;
//       }
      maxLevels(grid)=m+1;
    }
    
  }
  // display(maxLevels,"Maximum number of extra levels per grid");
  if( debugb & 2 )
  {
    for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
    {
      printF("Ogmg:INFO: %i multigrid levels could be built on grid %i (%s)\n",maxLevels(grid),grid,
	     (const char*)mgcg[grid].getName());
    }
  }
  
  numberOfExtraLevels=min(maxLevels);

  if( debugb & 2 )
  {
    printF("**** Ogmg::buildExtraLevels: this grid supports %i extra MG levels (numberOfExtraLevels). *****\n"
           "**** At most %i levels will be made (maximumNumberOfExtraLevels).                         *****\n",
         numberOfExtraLevels, parameters.maximumNumberOfExtraLevels);
    fPrintF(debugFile,
           "**** Ogmg::buildExtraLevels: this grid supports %i extra MG levels (numberOfExtraLevels). *****\n"
           "**** At most %i levels will be made (maximumNumberOfExtraLevels).                         *****\n",
         numberOfExtraLevels, parameters.maximumNumberOfExtraLevels);
  }
  
  // --- Here we add the grids for the extra levels
  for( l=level0; l<level0+numberOfExtraLevels; l++ )
  {
    level=l+1;
    for( grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
      mgcg.addMultigridCoarsening(factor,level,grid);
  }
  
  // mgcg.update(CompositeGrid::THElists | CompositeGrid::THEmultigridLevel);
  // mgcg.update();
    //  Tell the CompositeGrid that the interpolation data have been computed:

  // *wdh* 061123
  // mgcg.makeCompleteMultigridLevels();
  

// *wdh* 061123  
  bool newWay=true;  // *wdh* 061123  -- make sure the interp data lists are consistent between mgcg and levels
  if( newWay )
  {
    // update the MG level and make all interpolation arrays the correct length
    if( mgcg.numberOfBaseGrids()>1 )
    {
      // trouble here if there are no interp pts: (--fix this---)
      mgcg.update( CompositeGrid::THEmultigridLevel | 
		   CompositeGrid::THEinterpolationPoint       |
		   CompositeGrid::THEinterpoleeGrid           |
		   CompositeGrid::THEinterpoleeLocation       |
		   CompositeGrid::THEinterpolationCoordinates);

      if( debug & 2 )
      {
	printF("@@@ Ogmg:BuildExtraLevels: after adding extra grids for MG levels : mgcg.numberOfGrids()=%i, "
	       "mgcg.numberOfComponentGrids()=%i, "
	       "mgcg.interpolationPoint.getLength=%i\n",
	       mgcg.numberOfGrids(),mgcg.numberOfComponentGrids(),mgcg.interpolationPoint.getLength());
      }
    }
    else
    {
      mgcg.update( CompositeGrid::THEmultigridLevel );
    }
    
  }
  else
  {
    mgcg.update( CompositeGrid::THEmultigridLevel);
  }
  
  // Assign work-loads and load balance the CompositeGrid and all multigrid levels.
  loadBalance( mg, mgcg );
  

//   bool loadBalanceGrids=false;
//   #ifdef USE_PPP
//     loadBalanceGrids=true;
//   #endif
//   if( loadBalanceGrids )
//   {
//     // From GridCollection.C : 

//     if( parameters.loadBalancer==NULL )
//     {
//       parameters.loadBalancer = new LoadBalancer;
//       // NOTE: when there is only 1 grid then the default load-balancer will always use all-to-all
//       parameters.loadBalancer->setLoadBalancer(LoadBalancer::KernighanLin);
//     }
    
//     // --- Make the master gridDistributionList (GDL) be consistent with the MG level GDL's -- *wdh* 2013/08/29 
//     GridDistributionList & masterGDL = mgcg->gridDistributionList;
//     masterGDL.resize(mgcg.numberOfGrids(),GridDistribution());

//     LoadBalancer & loadBalancer = *parameters.loadBalancer; // could there already be a load balancer with cg ? 

//     // Level 0 : set gridDistribution equal to those in the incoming CompositeGrid
//     int level=0;
//     CompositeGrid & cg = mgcg.multigridLevel[level];
//     GridDistributionList & gridDistributionList = cg->gridDistributionList;
//     gridDistributionList.resize(cg.numberOfComponentGrids());
//     for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
//     {
//       gridDistributionList[grid]=mg->gridDistributionList[grid];
//     }
    
//     // load balance levels 1...
//     for( int l=1; l<mgcg.numberOfMultigridLevels(); l++ )
//     {
//       int level=l;
//       CompositeGrid & cg = mgcg.multigridLevel[level];

//       GridDistributionList & gridDistributionList = cg->gridDistributionList;
//       // GridDistributionList gridDistributionList;
    
//       // work-loads per grid are based on the number of grid points by default:
//       loadBalancer.assignWorkLoads( cg,gridDistributionList );

//       loadBalancer.determineLoadBalance( gridDistributionList );

//       // From GenericGridCollection.C: get: 
//       // Assign parallel distribution (if the info is there)
//       for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
//       {
// 	int pStart=-1,pEnd=0;
// 	gridDistributionList[grid].getProcessorRange(pStart,pEnd);
// 	if( Ogmg::debug & 2  )
// 	{
// 	  printF("Ogmg:buildExtraLevelsNew:assignLoadBalance: assign level=%i grid=%i to processors=[%i,%i]\n",
// 		 level,grid,pStart,pEnd);
// 	}
// 	if( false )
//           printF(" level=%i grid=%i gridNumber=%i componentGridNumber=%i\n",level,grid,cg.gridNumber(grid),
// 		 cg.componentGridNumber(grid));
	  
// 	cg[grid].specifyProcesses(Range(pStart,pEnd));

//         // Also set the distribution in the master GDL:
//         const int masterGridNumber = cg.gridNumber(grid); // here is the grid number in the master list of grids
//         masterGDL[masterGridNumber]=gridDistributionList[grid]; 
	
//       } // end for grid

//     } // end for l 



//   }


  mgcg.update( MappedGrid::THEmask ); // ********** no need to build center for rectangular grids
  // mgcg.update( MappedGrid::THEmask | MappedGrid::THEcenter | CompositeGrid::THEinterpolationPoint );

  if( np >1 )
  { // display the parallel distribution
    mgcg.displayDistribution("Top-level mgcg grid",infoFile);
    if( false )
    {
      for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
      {
	intArray & mask = mgcg[grid].mask();
	intSerialArray maskLocal; getLocalArrayWithGhostBoundaries(mask,maskLocal);
	printf("mgcg: myid=%i grid=%i maskLocal=[%i,%i][%i,%i]\n",myid,grid,maskLocal.getBase(0),maskLocal.getBound(0),
	       maskLocal.getBase(1),maskLocal.getBound(1));
      }
    }
    
    for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
      mgcg.multigridLevel[l].displayDistribution(sPrintF("multigrid level %i",l),infoFile);
  }

  if( true )
  {
    // For coarser level grids we do NOT share the vertex array in the grid with the mapping grid
    // used by the inverse (Otherwise the mapping inverse may get an extremely coarse grid) *wdh* 100424
    for( int level=1; level<mgcg.numberOfMultigridLevels(); level++ )
    {
      CompositeGrid & cg = mgcg.multigridLevel[level]; 
      for( int grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      {
	cg[grid].setShareGridWithMapping(false);
      }
    }
  }

  if( mgcg.numberOfComponentGrids()<=1 ||
      mgcg.numberOfMultigridLevels()==1 )
  {
    // ****** return here if there is only one component grid  or one MG level ******

    if( FALSE && level0==0 )
    {
      // now test out the validity of the newly created levels.
      for( l=level0; l<level0+numberOfExtraLevels; l++ )
      {
	level=l+1;
	printf("\n\n **************** check extra level %i ******************* \n\n",level);
	checkGrid( mgcg.multigridLevel[level],ps,debugb );
      }
    }


    tm[timeForBuildExtraLevels]+=getCPU()-time0;
    return 0;
  }
  
  Range Rg=mgcg.numberOfComponentGrids();

  // update interpolation data on multigrid level 0  -- why is this needed ?
  if( newWay )
  {

    //    CompositeGrid & cg = mgcg.multigridLevel[0];
    //     ::display(mgcg.numberOfInterpolationPoints,"buildExtra: mgcg.numberOfInterpolationPoints");
    //     ::display(cg.numberOfInterpolationPoints,"buildExtra: cg.numberOfInterpolationPoints (level=0)");
    //     for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    //     {
    //       ::display(cg.interpoleeGrid[grid],"cg.interpoleeGrid[grid]");
    //       ::display(cg.variableInterpolationWidth[grid],"cg.variableInterpolationWidth[grid]");
    //       ::display(cg.interpolationPoint[grid],"cg.interpolationPoint[grid]");        
    //       ::display(cg.interpoleeLocation[grid],"cg.interpoleeLocation[grid]");        
    //       ::display(cg.interpolationCoordinates[grid],"cg.interpolationCoordinates[grid]");  
    //     }
  }
  else // try turning this off 061123
  {
    CompositeGrid & cg = mgcg.multigridLevel[0];

    //     ::display(mgcg.numberOfInterpolationPoints,"buildExtra: mgcg.numberOfInterpolationPoints");
    //     ::display(cg.numberOfInterpolationPoints,"buildExtra: cg.numberOfInterpolationPoints (level=0)");
      

    cg.numberOfInterpolationPoints(Rg)=mgcg.numberOfInterpolationPoints(Rg);
  
    cg.update(
      CompositeGrid::THEinterpolationPoint       |
      CompositeGrid::THEinterpoleeGrid           |
      CompositeGrid::THEinterpoleeLocation       |
      CompositeGrid::THEinterpolationCoordinates ,
      CompositeGrid::COMPUTEnothing);

    for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
    {
      cg.interpoleeGrid[grid]            =mgcg.interpoleeGrid[grid];
      cg.variableInterpolationWidth[grid]=mgcg.variableInterpolationWidth[grid];
      cg.interpolationPoint[grid]        =mgcg.interpolationPoint[grid];
      cg.interpoleeLocation[grid]        =mgcg.interpoleeLocation[grid];
      cg.interpolationCoordinates[grid]  =mgcg.interpolationCoordinates[grid];
    }

    //  Tell the CompositeGrid that the interpolation data have been computed:
    mgcg->computedGeometry |=
      CompositeGrid::THEmask                     |
      CompositeGrid::THEinterpolationCoordinates |
      CompositeGrid::THEinterpolationPoint       |
      CompositeGrid::THEinterpoleeLocation       |
      CompositeGrid::THEinterpoleeGrid;

    cg->computedGeometry |=
      CompositeGrid::THEmask                     |
      CompositeGrid::THEinterpolationCoordinates |
      CompositeGrid::THEinterpolationPoint       |
      CompositeGrid::THEinterpoleeLocation       |
      CompositeGrid::THEinterpoleeGrid;

    // we also need to mark each MappedGrid (or else we lose the mask if we put/get to a file)
    for( grid=0; grid<cg.numberOfComponentGrids(); grid++ )
      cg[grid]->computedGeometry |= MappedGrid::THEmask;     // added 030829 *wdh*
  }
  
  // mgcg.update();
  // display(mgcg.interpolationPoint[0],"mgcg.interpolationPoint[0]");
  // displayMask(mgcg.multigridLevel[0][0].mask(),"mgcg.multigridLevel[0][0].mask");
  // display(mgcg.multigridLevel[0].interpolationPoint[0],"mgcg.multigridLevel[level].interpolationPoint[0]");
  
  
   CompositeGrid & cg00 = mgcg.multigridLevel[0];
   // cg00.update();
   if( debugb & 8 )
   {
     for( grid=0; grid<cg00.numberOfComponentGrids(); grid++ )
     {
       display(mgcg.variableInterpolationWidth[grid],"mgcg.variableInterpolationWidth[grid]",debugFile);
       display(cg00.variableInterpolationWidth[grid],"cg00.variableInterpolationWidth[grid]",debugFile);
     }
   }
   
   
  intSerialArray *iaA = new intSerialArray [mgcg.numberOfComponentGrids()];                 
  intSerialArray *interpoleeGridA = new intSerialArray [mgcg.numberOfComponentGrids()];     
  intSerialArray *interpolationPointA = new intSerialArray [mgcg.numberOfComponentGrids()]; 
  intSerialArray *interpoleeLocationA = new intSerialArray [mgcg.numberOfComponentGrids()]; 
  intSerialArray *variableInterpolationWidthA = new intSerialArray [mgcg.numberOfComponentGrids()]; 
  realSerialArray *interpolationCoordinatesA = new realSerialArray [mgcg.numberOfComponentGrids()]; 


  Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
  Index Jv[3], &J1=Jv[0], &J2=Jv[1], &J3=Jv[2];

  Index Igv[3], &Ig1=Igv[0], &Ig2=Igv[1], &Ig3=Igv[2];

  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];
  int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
  int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
  int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
  int isv[3], &is1=isv[0], &is2=isv[1], &is3=isv[2];
  int I1Base,I2Base,I3Base;
  int I1Bound,I2Bound,I3Bound;

  Range all;

  // --------------------------------------------------------------------------------
  // ---- Now update the mask and interpolation equations for the extra levels. -----
  // --------------------------------------------------------------------------------

  real timeForBuildMask=0., timeForBuildInterpolation=0., timeForValidStencil=0.;

  intSerialArray *pMask1=NULL;

  const int numberOfComponentGrids = mgcg.numberOfComponentGrids();

  // allocate space for local index arrays on the fine and coarse grid 
  IntegerArray *pGridIndexRange0     = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pDimension0          = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pIndexRange0         = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pExtendedIndexRange0 = new IntegerArray [numberOfComponentGrids];
  IntegerArray *pBoundaryCondition0  = new IntegerArray [numberOfComponentGrids];

  IntegerArray *pGridIndexRange1     = new IntegerArray [numberOfComponentGrids];
  IntegerArray *pDimension1          = new IntegerArray [numberOfComponentGrids];
  // IntegerArray *pIndexRange1         = new IntegerArray [numberOfComponentGrids];
  IntegerArray *pExtendedIndexRange1 = new IntegerArray [numberOfComponentGrids];
  IntegerArray *pBoundaryCondition1  = new IntegerArray [numberOfComponentGrids];

  for( int grid=0; grid<mgcg.numberOfComponentGrids(); grid++ )
  {
    pGridIndexRange0[grid].redim(2,3);     pGridIndexRange0[grid]=0;
    // pDimension0[grid].redim(2,3);          pDimension0[grid]=0;
    // pIndexRange0[grid].redim(2,3);         pIndexRange0[grid]=0;
    // pExtendedIndexRange0[grid].redim(2,3); pExtendedIndexRange0[grid]=0;
    pBoundaryCondition0[grid].redim(2,3);  pBoundaryCondition0[grid]=0;

    pGridIndexRange1[grid].redim(2,3);     pGridIndexRange1[grid]=0;
    pDimension1[grid].redim(2,3);          pDimension1[grid]=0;
    // pIndexRange1[grid].redim(2,3);         pIndexRange1[grid]=0;
    pExtendedIndexRange1[grid].redim(2,3); pExtendedIndexRange1[grid]=0;
    pBoundaryCondition1[grid].redim(2,3);  pBoundaryCondition1[grid]=0;
    
  }
  
  // NOTE: we must update the boundingBox here since may require communication.
  // NOTE: for some reason we should use the bounding box in mgcg.multigridLevel[0], otherwise
  //  there is an error in computing the box.
  // mgcg.update(MappedGrid::THEboundingBox);  // for donor searches *wdh* 2012/06/07

  // Note: creating the bounding box does NOT require the vertex array for Cartesian grids
  mgcg.multigridLevel[0].update(MappedGrid::THEboundingBox);  // for donor searches *wdh* 2012/06/07
  //   if( true )
  //   {
  //     printF("***mgcg.multigridLevel[0] AFTER update THEboundingBox \n");
  //     for( int grid=0; grid<mgcg.multigridLevel[0].numberOfComponentGrids(); grid++ )
  //       mgcg.multigridLevel[0][grid].displayComputedGeometry();
  //   }

  // ------------------------------------------------------------------------------------------------
  // ------------------------------- START LOOP OVER LEVELS -----------------------------------------
  // ------------------------------------------------------------------------------------------------
  const int lastLevel=level0+numberOfExtraLevels;
  for( l=level0; l<lastLevel; l++ )
  {
    CompositeGrid & cg0 = l==0 ? mgcg : mgcg.multigridLevel[l];  // finer grid  ***********

    level=l+1;
    CompositeGrid & cg1 = mgcg.multigridLevel[level]; // coarser grid
    
    // cg1.update(MappedGrid::THEmask | MappedGrid::THEcenter);   // *********
    cg1.update(MappedGrid::THEmask );
    
    cg1->multigridLevelNumber=0; // *wdh* 091207  -- this is needed for cgCanInterp
	

    IntegerArray numberOfInterpolationPoints(cg1.numberOfComponentGrids());
    numberOfInterpolationPoints=0;
    
    
    if( debugb & 2 )
    {
      printF("=========================== build level %i ================================\n",level);
      fprintf(pDebugFile,"\n=========================== build level %i ================================\n",level);
    }

    if( pMask1==NULL )
      pMask1= new intSerialArray [cg1.numberOfComponentGrids()];

    real timea=getCPU();
    for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
    {

      const IntegerArray & coarseningRatio = mgcg.multigridCoarseningRatio(Range(0,2),grid,level0);
      int cf[3], &cf1=cf[0], &cf2=cf[1], &cf3=cf[2];
      cf1=coarseningRatio(axis1);  // coarsening factor
      cf2=coarseningRatio(axis2);
      cf3=coarseningRatio(axis3);  
      assert(cf1==2 && (cf2==2 || numberOfDimensions<2) && (cf3==2 || numberOfDimensions<3));

      MappedGrid & mg0 = cg0[grid];
      intArray & mask0g = mg0.mask();

      MappedGrid & mg1 = cg1[grid];
      intArray & mask1g = mg1.mask();

      #ifdef USE_PPP
        intSerialArray mask0; getLocalArrayWithGhostBoundaries(mask0g,mask0);
        intSerialArray mask1s; getLocalArrayWithGhostBoundaries(mask1g,mask1s);
      #else
        intSerialArray & mask0 = mask0g;
        intSerialArray & mask1s = mask1g;
      #endif

      // --- NOTE: mask0g and mask1g may have different parallel distributions ---
      //       -> Thus the local masks : mask0 and mask1 may not overlap as in serial
      //       -> Therefore we make a temporary local coarse mask to match the local fine mask 

      //  Here is a local coarse mask that is a coarsening of the local fine mask
      intSerialArray & mask1 = pMask1[grid];

      mask1.redim(0);

      int extra=0;
      // getIndex(mg0.extendedIndexRange(),I1,I2,I3,extra); // what should this be ??
      getIndex(mg0.gridIndexRange(),I1,I2,I3,extra); // what should this be ??
      int includeGhost=0;  // include ghost or not???
      bool ok = ParallelUtility::getLocalArrayBounds(mask0g,mask0,I1,I2,I3,includeGhost);

      bool thisProcessorHasPoints=ok;
//       if( !ok ) 
//       {
//         fprintf(pDebugFile,"\n ==== Start coarse grid=%i level=%i ======\n"
//             		   "  *** this processor has no points on the mask ***\n",grid,level);
// 	continue;   // there must be no communication after this point
//       }

      assert( (numberOfDimensions==2 && cf[2]==1) || numberOfDimensions==3 );

      halfWidth1 = mg1.discretizationWidth(axis1)/2;
      halfWidth2 = numberOfDimensions>1 ? mg1.discretizationWidth(axis2)/2 : 0;
      halfWidth3 = numberOfDimensions>2 ? mg1.discretizationWidth(axis3)/2 : 0;
      const int hw[3] = { halfWidth1,halfWidth2,halfWidth3};  
    
      // -----------------------------------------------------------------------------------------
      // ------------------------- check the number of parallel ghost ----------------------------
      // For the algorithm we use: to mark extra interp points:  (hw=stencil half-width)
      //   The coarse grid mask needs hw parallel ghost, hw=(dw-1)/2, hw=(1,2) (2nd, 4th order), 
      //   THUS the fine grid needs 2*hw parallel ghost hw=(2,4) for (2nd, 4th order)
      //
      // NOTE: We could avoid this restriction by extra communication to mark the coarse grid mask
      //    values that we need. 
      // ----------------------------------------------------------------------------------------

      // Coarse mask: To mark point i with extra interp pts we need hw points to the right
      //              To mark point j with extra interp pts we need hw points to the left 
      //                   i   j 
      //     p=0   0   0   0   1   1   1   1   : eir marks which points belong to which processor
      //    ---+---+---+---+---+---+---+---+---+---+
      //    ---+---+---+---+---+---+
      //               +---+---+---+---+---+---+---+---+---+---
      // THUS we need 2*hw points off overlap on the fine mask 

      const int numParallelGhostNeeded=2*hw[0];
      for( int axis=0; axis<numberOfDimensions; axis++ )
      {
	if( mask0g.getGhostBoundaryWidth(axis)<numParallelGhostNeeded )
	{
	  printF("Ogmg::buildExtraLevels: ERROR: the number of parallel ghost points must be at least %i if the "
                 "discretization width=%i.\n"
                 "  mask0g.getGhostBoundaryWidth(%i) = %i,\n"
                 "  You should set the number of parallel ghost to %i or use the option -numParallelGhost=%i .\n",
		 numParallelGhostNeeded,mg1.discretizationWidth(axis),
                 axis,mask0g.getGhostBoundaryWidth(axis),
                 numParallelGhostNeeded,numParallelGhostNeeded);
	  OV_ABORT("ERROR");
	}
      }

      for( int axis=0; axis<numberOfDimensions; axis++ )
      {
	if( mg1.numberOfGhostPoints(0,axis)<hw[axis] ||
            mg1.numberOfGhostPoints(1,axis)<hw[axis] )
	{
	  printF("Ogmg::ERROR: the number of ghost points must be at least %i if the discretization width =%i\n",
		 hw[axis],mg1.discretizationWidth(axis));
	  OV_ABORT("ERROR");
	}
      }


      // -----------------------------------------
      // -------- Define index ranges ------------
      // -----------------------------------------

      // ---- NOTE:  ------------------
      //    eirLocal1 : partitions coarse grid points into non-overlapping sets
      //    Thus a given coarse point (i1,i2,i3) should belong to ONE AND ONLY ONE processor according to eir1Local

      const IntegerArray & gid0 = mg0.gridIndexRange();
      const IntegerArray & bc0 = mg0.boundaryCondition();

      const IntegerArray & ir1 = mg1.indexRange();
      const IntegerArray & gid1 = mg1.gridIndexRange();
      const IntegerArray & bc1 = mg1.boundaryCondition();

      const IntegerArray & extendedIndexRange = mg1.extendedIndexRange();

      // Determine local index bounds and boundary conditions

      IntegerArray & gidLocal0 =     pGridIndexRange0[grid];
      // IntegerArray & dimLocal0 =          pDimension0[grid];
      // IntegerArray &  irLocal0 =         pIndexRange0[grid];
      // IntegerArray & eirLocal0 = pExtendedIndexRange0[grid];
      IntegerArray &  bcLocal0 =  pBoundaryCondition0[grid];

      IntegerArray & gidLocal1 =     pGridIndexRange1[grid];
      IntegerArray & dimLocal1 =          pDimension1[grid];
      // IntegerArray &  irLocal1 =         pIndexRange1[grid];
      IntegerArray & eirLocal1 = pExtendedIndexRange1[grid];
      IntegerArray &  bcLocal1 =  pBoundaryCondition1[grid];

      const int numGhost=2; // fix me -- what should this be ? 
      for( int axis=0; axis<numberOfDimensions; axis++ )
      {
        //          p=0              p=1
        //  ...+--+--+--+--+--+  +--+--+--+--+  fine
        //                    n n+1
        //  ...   +-----+-----+     +-----+---   coarse (case I: m==n)
        //                    m     m+1 
        //     +-----+-----+     +-----+-----+--  coarse (case II, m<n)
        //                 m     m+1
	if( mask0.getLength(axis)==0 )
	{
	  // no points on this processor
          thisProcessorHasPoints=false;
	  for( int side=0; side<=1; side++ )
	  {
	    gidLocal0(side,axis) = -side;
	    bcLocal0(side,axis)  = 0;

	    gidLocal1(side,axis) = -side;
	    dimLocal1(side,axis) = -side;
	    bcLocal1(side,axis)  = 0;
	    // irLocal1(side,axis)  = -side;
	    eirLocal1(side,axis) = -side;
	  }
	  continue;
	}

	if( mask0g.getLocalBase(axis) == mask0g.getBase(axis) ) 
	{
	  gidLocal0(0,axis) = gid0(0,axis); 
          bcLocal0(0,axis)  = bc0(0,axis);

	  gidLocal1(0,axis) = gid1(0,axis); 
          dimLocal1(0,axis) = gidLocal1(0,axis)-numGhost;
          bcLocal1(0,axis)  = bc1(0,axis);
	  // irLocal1(0,axis)  = ir1(0,axis); 
          eirLocal1(0,axis) = extendedIndexRange(0,axis);
	}
	else
	{ // this side is an internal parallel boundary
          // choose gidLocal0 to match the coarse grid pt 
          int ia =  mask0g.getLocalBase(axis)+mask0g.getGhostBoundaryWidth(axis); // index-bound, no ghost
	  int ja = (ia-gid0(0,axis)+cf[axis]-1)/cf[axis]+gid1(0,axis);   // coarse grid pt >=ia 
          int ia0 = (ja-gid1(0,axis))*cf[axis]+gid0(0,axis);  // fine grid pt that matches ja 
	  
// 	     gidLocal0(0,axis) = ia0-cf[axis];  // needs to match gidLocal1 below
//           bcLocal0(0,axis)  = -1; // parallel boundary gets a periodic BC

//           gidLocal1(0,axis) = ja-1;    // what should this be ? 
//           dimLocal1(0,axis) = gidLocal1(0,axis)-hw[axis];
//           bcLocal1(0,axis)  = -1; // parallel boundary gets a periodic BC
// 	  // irLocal1(0,axis)  = ja;
//           eirLocal1(0,axis) = ja; // ja-1; // ja; *wdh* 2012/06/10

          // ------ *wdh* 2012/06/10 -- fix for fourth-order 
	  gidLocal0(0,axis) = ia0-cf[axis]*hw[axis];  // needs to match gidLocal1 below
          bcLocal0(0,axis)  = -1; // parallel boundary gets a periodic BC

          // We need to mark extra interp points on line ja, thus  gidLocal1 must be offset by hw:
          gidLocal1(0,axis) = ja-hw[axis];    
          dimLocal1(0,axis) = gidLocal1(0,axis)-hw[axis];
          bcLocal1(0,axis)  = -1; // parallel boundary gets a periodic BC
	  // irLocal1(0,axis)  = ja;
          eirLocal1(0,axis) = ja; // ja-1; // ja; *wdh* 2012/06/10

	}
        // --- side=1 ---
	if( mask0g.getLocalBound(axis) == mask0g.getBound(axis) ) 
	{
	  gidLocal0(1,axis) = gid0(1,axis); 
          bcLocal0(1,axis)  = bc0(1,axis);

	  // irLocal1(1,axis)  = ir1(1,axis); 
	  gidLocal1(1,axis) = gid1(1,axis); 
	  dimLocal1(1,axis) = gidLocal1(1,axis)+hw[axis]; 
          bcLocal1(1,axis)  = bc1(1,axis);
          eirLocal1(1,axis) = extendedIndexRange(1,axis);
	}
	else
	{ // this side is an internal parallel boundary
          int ia = mask0g.getLocalBound(axis)-mask0g.getGhostBoundaryWidth(axis);  // last pt (no parallel ghost)
	  int ja = (ia-gid0(0,axis))/cf[axis]+gid1(0,axis);   // coarse grid pt <=ia 
          int ia0 = (ja-gid1(0,axis))*cf[axis]+gid0(0,axis);  // fine grid pt that matches ja 

// 	  gidLocal0(1,axis) = ia0+cf[axis];  // needs to match gidLocal1 below
//           bcLocal0(1,axis)  = -1;  // parallel boundary gets a periodic BC

//           gidLocal1(1,axis) = ja+1;  // what should this be ? 
//           dimLocal1(1,axis) = gidLocal1(1,axis)+hw[axis];
//           bcLocal1(1,axis)  = -1;  // parallel boundary gets a periodic BC
// 	  // irLocal1(1,axis)  = ja;
//           eirLocal1(1,axis) = ja; // ja+1;  // =ja; *wdh* 2012/06/10 

          // ------ *wdh* 2012/06/10 -- fix for fourth-order 

 	  gidLocal0(1,axis) = ia0+cf[axis]*hw[axis];  // needs to match gidLocal1 below
	  bcLocal0(1,axis)  = -1;  // parallel boundary gets a periodic BC

          // We need to mark extra interp points on line ja, thus  gidLocal1 must be offset by hw:
	  gidLocal1(1,axis) = ja+hw[axis];  
	  dimLocal1(1,axis) = gidLocal1(1,axis)+hw[axis];
	  bcLocal1(1,axis)  = -1;  // parallel boundary gets a periodic BC
 	  // irLocal1(1,axis)  = ja;
	  eirLocal1(1,axis) = ja; // ja+1;  // =ja; *wdh* 2012/06/10 

	} 
	
      } // end for axis
      
      if( !thisProcessorHasPoints )
      {
	if( debug & 2 )
	  fprintf(pDebugFile,"\n ==== Start coarse grid=%i level=%i ======\n"
		  "  *** this processor has no points on the mask ***\n",grid,level);
	continue;   // there must be no communication after this point
      }
      
      if( debug & 2 )
      {
	const IntegerArray & dim0 = mg0.dimension();
	const IntegerArray & dim1 = mg1.dimension();
	fprintf(pDebugFile,
		"\n ==== Start coarse grid=%i level=%i ======\n"
                " Global bounds:\n"
		"  fine  : gid=[%i,%i][%i,%i][%i,%i] dim=[%i,%i][%i,%i][%i,%i]\n"
		"  coarse: gid=[%i,%i][%i,%i][%i,%i] dim=[%i,%i][%i,%i][%i,%i]\n"
		" Local bounds: \n"
		"  fine  : gid=[%i,%i][%i,%i][%i,%i] mask0=[%i,%i][%i,%i][%i,%i] \n"
		"  coarse: gid=[%i,%i][%i,%i][%i,%i] dim=[%i,%i][%i,%i][%i,%i] eir=[%i,%i][%i,%i][%i,%i]\n",
                grid,level,
                gid0(0,0),gid0(1,0),gid0(0,1),gid0(1,1),gid0(0,2),gid0(1,2),
                dim0(0,0),dim0(1,0),dim0(0,1),dim0(1,1),dim0(0,2),dim0(1,2),
                gid1(0,0),gid1(1,0),gid1(0,1),gid1(1,1),gid1(0,2),gid1(1,2),
                dim1(0,0),dim1(1,0),dim1(0,1),dim1(1,1),dim1(0,2),dim1(1,2),
                gidLocal0(0,0),gidLocal0(1,0),gidLocal0(0,1),gidLocal0(1,1),gidLocal0(0,2),gidLocal0(1,2),
                mask0.getBase(0),mask0.getBound(0),
                mask0.getBase(1),mask0.getBound(1),
                mask0.getBase(2),mask0.getBound(2),
                gidLocal1(0,0),gidLocal1(1,0),gidLocal1(0,1),gidLocal1(1,1),gidLocal1(0,2),gidLocal1(1,2),
                dimLocal1(0,0),dimLocal1(1,0),dimLocal1(0,1),dimLocal1(1,1),dimLocal1(0,2),dimLocal1(1,2),
                eirLocal1(0,0),eirLocal1(1,0),eirLocal1(0,1),eirLocal1(1,1),eirLocal1(0,2),eirLocal1(1,2));
      }
      
//       J3=0;
//       for( int axis=0; axis<numberOfDimensions; axis++ )
//       {
//         int ia=Iv[axis].getBase(), ib=Iv[axis].getBound();

//         assert(  gid0(0,axis)==0 && gid1(0,axis)==0 );  // we probably assume this elsewhere in the code *************

//         assert( gid0(0,axis)==gid1(0,axis) ); // Do we need this ? 
// 	int ja = (ia-cf[axis]+1-gid0(0,axis))/cf[axis]+gid1(0,axis) -numGhost;  // coarse grid pt <= ia 
//         int jb = (ib+cf[axis]-1-gid0(0,axis))/cf[axis]+gid1(0,axis) +numGhost;  // coarse grid pt >= ib 
// 	Jv[axis]=Range(ja,jb);
//       }
      

      getIndex(dimLocal1,J1,J2,J3);
      mask1.redim(J1,J2,J3);


      int * mask0p = mask0.Array_Descriptor.Array_View_Pointer2;
      const int mask0Dim0=mask0.getRawDataSize(0);
      const int mask0Dim1=mask0.getRawDataSize(1);
#define MASK0(i0,i1,i2) mask0p[i0+mask0Dim0*(i1+mask0Dim1*(i2))]	
      
      int * mask1p = mask1.Array_Descriptor.Array_View_Pointer2;
      const int mask1Dim0=mask1.getRawDataSize(0);
      const int mask1Dim1=mask1.getRawDataSize(1);
#define MASK1(i0,i1,i2) mask1p[i0+mask1Dim0*(i1+mask1Dim1*(i2))]	
      
//        printF("------------mg0 from level %i, mg1 from level %i\n",l,level);
//        ::display(mgcg[grid].boundaryCondition(),"mgcg[grid].boundaryCondition()");
//        ::display(mg0.boundaryCondition(),"mg0.boundaryCondition()");
//        ::display(mg1.boundaryCondition(),"mg1.boundaryCondition()");
      

      if( debugb & 4 )
      {
        displayMask(mask0,sPrintF(buff,"Ogmg::buildExtraLevels: mask0 from level %i grid %i ",level-1,grid),pDebugFile);
	if( debugb & 16 )
 	  displayMask(mask1,sPrintF("Ogmg::buildExtraLevels: mask1 for level %i (BEFORE)",level),pDebugFile);

        fflush(pDebugFile);
      }
      if( debugb & 16 )
      {
        Index J1,J2,J3;
        getIndex(mg0.gridIndexRange(),J1,J2,J3);   // Index's for coarse grid, one ghost line.
        displayMaskLaTeX(mask0g(J1,J2,J3),sPrintF(buff,"Ogmg::buildExtraLevels: mask0 from level %i grid %i ",
                    level-1,grid),debugFile);

        getIndex(mg1.gridIndexRange(),J1,J2,J3);   // Index's for coarse grid, one ghost line.
        displayMaskLaTeX(mask1g(J1,J2,J3),sPrintF("Ogmg::buildExtraLevels: mask1 for level %i (BEFORE)",level),debugFile);
      }
      
      
      // **** here I need 2 ghost lines **** is this really necessary ??
      // *wdh* const int nGhostCoarse = orderOfAccuracy/4;
      const int nGhostCoarse = 0; // try this *wdh* 100111
      const int nGhostFine   = nGhostCoarse*2;

      // *** wdh 091204 ?? should we assign more pts in the periodic direction now ???

      getIndex(gidLocal0,I1,I2,I3,nGhostFine);   // Index's for fine grid -- include ghost lines
      I1=IndexBB(I1,cf[0]);  I2=IndexBB(I2,cf[1]);  I3=IndexBB(I3,cf[2]);  // set stride
  
      getIndex(gidLocal1,J1,J2,J3,nGhostCoarse);   // Index's for coarse grid, one ghost line.


      // ***************************************************************
      // ******** Copy fine mask to coarse mask ************************
      // ***************************************************************

      mask1=0;
      mask1(J1,J2,J3)=mask0(I1,I2,I3);


      if( debugb & 4 )
        displayMask(mask1,"Ogmg::buildExtraLevels: After initial copy: mask1=mask0 (stride 2)",pDebugFile);
      if( debugb & 16 )
      {
        displayMaskLaTeX(mask1g(J1,J2,J3),"Ogmg::buildExtraLevels: After initial copy: mask1=mask0 (stride 2)",debugFile);
      }
      

      // -----------------------------------------------------------
      // --- Mark mask at interp points outside bc=0 boundaries ----
      // -----------------------------------------------------------

      markCoarseMaskAtBoundaries();

      
      if( debugb & 4 )
        displayMask(mask1,sPrintF(buff,"Ogmg::buildExtraLevels: mask1 for level %i grid %i"
             " (Before marking extra interp)",level,grid),pDebugFile);


      // ***********************************************************
      // ***  mark any extra interpolation points on coarse grid  **
      // ***********************************************************
      // Mark a point with mask==0 but with a neighbour mask>0
      // The number of neighbours we check depends on how wide the discretization width is.

      getIndex(gidLocal1,I1,I2,I3); 

      const int * peir = &eirLocal1(0,0);
      #define eir(side,axis) peir[(side)+2*(axis)]

      if( debugb & 4 )
	fprintf(pDebugFile,">>>>level=%i grid=%i isPeriodic=%i,%i,%i I1=[%i,%i] I2=[%i,%i] I2=[%i,%i] "
                "hw=[%i,%i,%i] eir=[%i,%i][%i,%i][%i,%i]\n",
		level,grid,mg1.isPeriodic(0),mg1.isPeriodic(1),mg1.isPeriodic(2),
                I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound(),
                halfWidth1,halfWidth2,halfWidth3,
                eir(0,0),eir(1,0),eir(0,1),eir(1,1),eir(0,2),eir(1,2));
      
      // NOTE: We should not count "interp" points at periodic images 
      FOR_3D(i1,i2,i3,I1,I2,I3)
      {
	if( MASK1(i1,i2,i3)>0 ) // discretization point
	{
	  for( int m3=-halfWidth3; m3<=halfWidth3; m3++ )      
	  {
	    for( int m2=-halfWidth2; m2<=halfWidth2; m2++ )
	    {
	      for( int m1=-halfWidth1; m1<=halfWidth1; m1++ )
	      {
		if( MASK1(i1+m1,i2+m2,i3+m3)==0 )
		{
                  j1=i1+m1;
		  j2=i2+m2;
		  j3=i3+m3;
		  if( j1>=eir(0,0) && j1<=eir(1,0) &&
                      j2>=eir(0,1) && j2<=eir(1,1) &&
                      j3>=eir(0,2) && j3<=eir(1,2) )
		  {
		    MASK1(i1+m1,i2+m2,i3+m3)= MappedGrid::ISinterpolationPoint;
		  }
		}
	      }
	    }
	  }
	}
      }
      
      
      // ******** communication here :  THIS DOES NOT WORK IN PARALLEL
      // mg1.mask().periodicUpdate(); // *wdh* 021006 needed for stir.mg.hdf for example

      if( debugb & 4 )
        displayMask(pMask1[grid],sPrintF(buff,"Ogmg::buildExtraLevels: mask1 for level %i grid %i"
           " (AFTER marking extra interp)",level,grid),
                    pDebugFile);
    
      if( debugb & 16 )
      {
        Index J1,J2,J3;
        getIndex(mg1.gridIndexRange(),J1,J2,J3);   // Index's for coarse grid, one ghost line.
        intArray & mask1g = mg1.mask();
        displayMaskLaTeX(mask1g(J1,J2,J3),
              sPrintF(buff,"Ogmg::buildExtraLevels: mask1 for level %i grid %i (AFTER)",level,grid),debugFile);
      }
    
      
    } // end for grid 


    // -------------------------------------------------------------
    // ---- copy local mask1's into the mask1g distributed array ---
    // -------------------------------------------------------------
    for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
    {

      MappedGrid & mg0 = cg0[grid];
      intArray & mask0g = mg0.mask();
      MappedGrid & mg1 = cg1[grid];
      intArray & mask1g = mg1.mask();
      #ifdef USE_PPP
        intSerialArray mask0; getLocalArrayWithGhostBoundaries(mask0g,mask0);
        intSerialArray & mask1 = pMask1[grid];
      #else
        intSerialArray & mask0 = mask0g;
        intSerialArray & mask1 = mask1g;
      #endif
      const IntegerArray & eirLocal1 = pExtendedIndexRange1[grid];

      //  mask1SerialProcessorSet : list of processors where the local mask1's are found, this happens
      //                            to be the same as the list of processors for mask0g:
      const intSerialArray & mask1SerialProcessorSet = mask0g.getPartition().getProcessorSet();

      // Jv : copy these points from mask1 
      // Iv : total set of points we mean to fill in mask1g 
    
      const IntegerArray & egid = extendedGridIndexRange(mg1);
      getIndex(egid,I1,I2,I3);
      bool thisProcessorHasPoints = eirLocal1(0,0) <= eirLocal1(1,0);
      if( thisProcessorHasPoints )
      {
	getIndex(eirLocal1,J1,J2,J3);
      }
      else
      {
	J1=all; J2=all; J3=all;
      }
	
      CopyArray::copyArray( mask1,Jv,mask1SerialProcessorSet, mask1g, Iv );

      mg1.mask().periodicUpdate();
      mask1g.updateGhostBoundaries();  

      if( debug & 4 )
      {
	intSerialArray mask1Local; getLocalArrayWithGhostBoundaries(mask1g,mask1Local);
	displayMask(mask1Local,sPrintF("Ogmg::buildExtraLevels: level=%i, grid=%i, mask1Local "
				       "after serial-to-distributed copy",level,grid),pDebugFile);
      }
    } // end for grid



    if( false )
    {
      OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
    }
      

    real timeb=getCPU();
    timeForBuildMask+=timeb-timea;

    // ***********************************************************************
    // The coarse grid mask has now been defined and all interpolation points 
    // have been marked on the coarse grid.
    // Determine the interpolation information for each interpolation point.
    // ***********************************************************************


    realSerialArray r(1,3),x(1,3);
    real *xp = x.Array_Descriptor.Array_View_Pointer1;
    const int xDim0=x.getRawDataSize(0);
#define X(i0,i1) xp[i0+xDim0*(i1)]
    real *rp = r.Array_Descriptor.Array_View_Pointer1;
    int rDim0=r.getRawDataSize(0);
#define R(i0,i1) rp[i0+rDim0*(i1)]

    r=-1.; x=0.;

    // arrays for rectangular grids:
    real dx0[3],xab0[2][3];
    real dx1[3],xab1[2][3];
    int iv0[3], iv1[3];
#define CENTER00(i0,i1,i2) (xab0[0][0]+dx0[0]*(i0-iv0[0]))
#define CENTER01(i0,i1,i2) (xab0[0][1]+dx0[1]*(i1-iv0[1]))
#define CENTER02(i0,i1,i2) (xab0[0][2]+dx0[2]*(i2-iv0[2]))

#define CENTER10(i0,i1,i2) (xab1[0][0]+dx1[0]*(i0-iv1[0]))
#define CENTER11(i0,i1,i2) (xab1[0][1]+dx1[1]*(i1-iv1[1]))
#define CENTER12(i0,i1,i2) (xab1[0][2]+dx1[2]*(i2-iv1[2]))

    for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
    {
      // only create the center (vertices) for non-rectangular grids
      if( !cg1[grid].isRectangular() )
      {
        if( l==level0 ) cg0[grid].update(MappedGrid::THEvertex | MappedGrid::THEcenter );	
        cg1[grid].update(MappedGrid::THEvertex | MappedGrid::THEcenter );
      }
    }
    
    // ---- Get a copy of the interpolation data arrays from the fine grid that live on this processor:
    InterpolationData *interpData=NULL;
    ParallelGridUtility::getLocalInterpolationData( cg0, interpData );

    for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
    {

      // const IntegerArray & numberOfInterpolationPoints0 =cg0.numberOfInterpolationPoints;
      InterpolationData & ipd = interpData[grid];
      
      #ifdef USE_PPP
        const int numberOfInterpolationPoints0 = ipd.numberOfInterpolationPoints;  // number of fine grid interp pts on this proc.
        intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
        intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
        realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
      #else
        const int numberOfInterpolationPoints0 =cg0.numberOfInterpolationPoints(grid);
        const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
        const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
        const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
      #endif    

      const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;
#define ig0(i0) interpoleeGrid0p[i0]

      const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
      const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);
#define ip0(i0,i1) interpolationPoint0p[i0+interpolationPoint0Dim0*(i1)]

      const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
      const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);
#define ci0(i0,i1) interpolationCoordinates0p[i0+interpolationCoordinates0Dim0*(i1)]

      MappedGrid & mg0 = cg0[grid];
      intArray & mask0g = mg0.mask();

      MappedGrid & mg1 = cg1[grid];
      MappedGrid & c = mg1;
      const bool isRectangular=mg1.isRectangular();

      intArray & mask1g = mg1.mask();

      #ifdef USE_PPP
        intSerialArray mask0; getLocalArrayWithGhostBoundaries(mask0g,mask0);
        intSerialArray & mask1 = pMask1[grid];
        // intSerialArray mask1; getLocalArrayWithGhostBoundaries(mask1g,mask1);
        realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
      #else
        intSerialArray & mask0 = mask0g;
        intSerialArray & mask1 = mask1g;
        const realArray & center = mg1.center();
      #endif

      int * mask1p = mask1.Array_Descriptor.Array_View_Pointer2;
      const int mask1Dim0=mask1.getRawDataSize(0);
      const int mask1Dim1=mask1.getRawDataSize(1);

      real *centerp;
      int centerDim0,centerDim1,centerDim2;
      if( !isRectangular )
      {
	centerp = center.Array_Descriptor.Array_View_Pointer3;
	centerDim0=center.getRawDataSize(0);
	centerDim1=center.getRawDataSize(1);
	centerDim2=center.getRawDataSize(2);
      }
      
#define CENTER(i0,i1,i2,i3) centerp[i0+centerDim0*(i1+centerDim1*(i2+centerDim2*(i3)))]	

      if( isRectangular )
      {
	mg0.getRectangularGridParameters( dx0, xab0 );
	mg1.getRectangularGridParameters( dx1, xab1 );
	iv0[0]=mg0.gridIndexRange(0,0);
	iv0[1]=mg0.gridIndexRange(0,1);
	iv0[2]=mg0.gridIndexRange(0,2);
	iv1[0]=mg1.gridIndexRange(0,0);
	iv1[1]=mg1.gridIndexRange(0,1);
	iv1[2]=mg1.gridIndexRange(0,2);
	if( mg1.isAllCellCentered() )
	{
	  xab0[0][0]+=dx0[0]*.5;
	  xab0[0][1]+=dx0[1]*.5;
	  xab0[0][2]+=dx0[2]*.5;

	  xab1[0][0]+=dx1[0]*.5;
	  xab1[0][1]+=dx1[1]*.5;
	  xab1[0][2]+=dx1[2]*.5;
	}     
      }
      
      const IntegerArray & gidLocal0 =     pGridIndexRange0[grid];
      // const IntegerArray & dimLocal0 =          pDimension0[grid];
      // const IntegerArray &  irLocal0 =         pIndexRange0[grid];
      // const IntegerArray & eirLocal0 = pExtendedIndexRange0[grid];
      const IntegerArray &  bcLocal0 =  pBoundaryCondition0[grid];

      const IntegerArray & gidLocal1 =     pGridIndexRange1[grid];
      const IntegerArray & dimLocal1 =          pDimension1[grid];
      // const IntegerArray &  irLocal1 =         pIndexRange1[grid];
      const IntegerArray & eirLocal1 = pExtendedIndexRange1[grid];
      const IntegerArray &  bcLocal1 =  pBoundaryCondition1[grid];


      const int *peir = &eirLocal1(0,0);
      #define eir(side,axis) peir[(side)+2*(axis)]


      const int *pir = mg0.indexRange().getDataPointer();  // this is used for offsets
#define INDEXRANGE(side,axis) pir[(side)+2*(axis)]

      bool thisProcessorHasPoints = eirLocal1(0,0) <= eirLocal1(1,0);

      intSerialArray inverseGrid;
      if( thisProcessorHasPoints )
      {
        // *wdh* 2012/07/07 -- add one more for 4th order (avoid ABR on line 2035, INVERSEGRID(j1,j2,j3)==-1 )
        const int extrai = orderOfAccuracy==2 ? 1 : 2;
	getIndex(eirLocal1,I1,I2,I3,extrai);   
	// *wdh* 2012/07/07 getIndex(eirLocal1,I1,I2,I3,1); 
	inverseGrid.redim(I1,I2,I3);  // allocate here to include extra on periodic edges 030617
      
	// const int extra=orderOfAccuracy==2 ? 1 : 0; // need one extra (ellipsoid)
	const int extra=0;  // *wdh* turn off 030830 -- no longer needed after other changes.
	getIndex(eirLocal1,I1,I2,I3,extra);   
      }
      else
      {
	// If there are no points on the mask on this processor then: 
	assert( numberOfInterpolationPoints0==0 );
      }
      

      //        printF(">>>>> grid=%i gid=%i %i eir+1=%i %i \n",grid,c.gridIndexRange(0,0),c.gridIndexRange(1,0),
      //  	     I1.getBase(),I1.getBound());

      // We should not count "interp" points at periodic images *wdh* 021006
      // This is needed after we added the mask.periodicUpdate above
      if( false )
      { // *wdh* 091204 -- turn off for now --
	for( int axis=0; axis<c.numberOfDimensions(); axis++ )
	{
	  if( c.isPeriodic(axis) )
	    Iv[axis]=Range(INDEXRANGE(0,axis),INDEXRANGE(1,axis));
	}
      }
      
      // printF("*** I1,I2,I3 for counting interp: [%i,%i][%i,%i][%i,%i]\n",
      //      I1.getBase(),I1.getBound(),I2.getBase(),I2.getBound(),I3.getBase(),I3.getBound());
      

      // ****** set mask==0 at 2nd ghost line outside interp boundaries.!

      // ------------------------------------------
      // -- make a list of interpolation points. --
      // ------------------------------------------

      int maxNumberOfInterpolationPoints=numberOfInterpolationPoints0*2+100;
      Range R; 
      // NOTE:  ia(i,.) holds ALL interp. pts on the coarse grid 
      //  (i.e. pts that coincide and do not coincide with fine grid interp. pts)
      //
      //  ia(i,0:2) = (i1,i2,i3) : interpolation point on the coarse grid
      //  ia(i,3) = interpolation quality, current best quality (*new* 2012/06/03)
      //  ia(i,4) = interpolation quality of the new possible donor grid 
      const int iaNumberOfComponents=5;
      intSerialArray & ia =iaA[grid];
      realSerialArray donorDist;     // holds the distance to the current donor -- for choosing closest donor
      if( thisProcessorHasPoints )
      {
        R=maxNumberOfInterpolationPoints;
	ia.redim(R,iaNumberOfComponents);
        donorDist.redim(R,2);
      }
      else
      {
	ia.redim(0);
      }
      
      int *iap = ia.Array_Descriptor.Array_View_Pointer1;
      const int iaDim0=ia.getRawDataSize(0);
#define IA(i0,i1) iap[i0+iaDim0*(i1)]

      int i=0;
      if( thisProcessorHasPoints )
      {
	FOR_3(i1,i2,i3,I1,I2,I3)
	{
	  if( MASK1(i1,i2,i3) & MappedGrid::ISinterpolationPoint )
	  {                                
	    IA(i,0)=i1;
	    IA(i,1)=i2;
	    IA(i,2)=i3;
            // initialize quality: 
	    IA(i,3)=canNotInterpolate;         // interp. quality (current best donor)
	    IA(i,4)=canInterpolateQuality1;    // interp. coordinates quality (i.e. quality of "r" coords)
	    donorDist(i,0)=REAL_MAX;           // distance to current best donor
	    donorDist(i,1)=REAL_MAX;           // holds distance to potential new donor
	    
            MASK1(i1,i2,i3) = -(i+1);        // mask holds the index "i" 

	    i++;

	  }
	}
      }
      assert( i<=maxNumberOfInterpolationPoints );
      
      int ni=i;
      numberOfInterpolationPoints(grid)=ni;
      if( debugb & 4 )
      {
        fprintf(pDebugFile,"*** grid=%i level=%i : find interp pts on mask1 : numberOfInterpolationPoints =%i \n",grid,level,ni);
        fprintf(pDebugFile," mask0=[%i,%i][%i,%i][%i,%i]\n",
		mask0.getBase(0),mask0.getBound(0),
		mask0.getBase(1),mask0.getBound(1),
		mask0.getBase(2),mask0.getBound(2));
	for( int i=interpolationPoint0.getBase(0); i<=interpolationPoint0.getBound(0); i++ )
	{
	  int ip3 = numberOfDimensions==2 ? 0 : ip0(i,2); 
          fprintf(pDebugFile," fine-grid interp: i=%i ip=(%i,%i,%i) mask0(ip)=%i\n",i,
		  ip0(i,0),ip0(i,1),ip3, mask0(ip0(i,0),ip0(i,1),ip3));
          fflush(pDebugFile);
	}
	
      }
      
      R=ni;

      // -- make a CanInterpolate query list for all interp points --
      int numberToCheck=numberOfInterpolationPoints(grid);
      using namespace CanInterpolate;
      // Allocate space for queries: 
      CanInterpolateQueryData *cid = new CanInterpolateQueryData[max(1,numberToCheck)];


      int * inverseGridp = inverseGrid.Array_Descriptor.Array_View_Pointer2;
      const int inverseGridDim0=inverseGrid.getRawDataSize(0);
      const int inverseGridDim1=inverseGrid.getRawDataSize(1);
#define INVERSEGRID(i0,i1,i2) inverseGridp[i0+inverseGridDim0*(i1+inverseGridDim1*(i2))]	

//       realSerialArray inverseCoordinates;
       if( thisProcessorHasPoints )
       {
 	inverseGrid=-1;
// 	inverseCoordinates.redim(I1,I2,I3,Rx);
       }
      
//       real * inverseCoordinatesp = inverseCoordinates.Array_Descriptor.Array_View_Pointer3;
//       const int inverseCoordinatesDim0=inverseCoordinates.getRawDataSize(0);
//       const int inverseCoordinatesDim1=inverseCoordinates.getRawDataSize(1);
//       const int inverseCoordinatesDim2=inverseCoordinates.getRawDataSize(2);
// #define INVERSECOORDINATES(i0,i1,i2,i3) inverseCoordinatesp[i0+inverseCoordinatesDim0*(i1+inverseCoordinatesDim1*(i2+inverseCoordinatesDim2*(i3)))]	


      // -----------------------------------------------------------------------------------------------
      // --- Fill in all coarse grid interpolation points that match a fine grid interpolation point ---
      //     These points are assumed to be valid interpolation points. 
      // -----------------------------------------------------------------------------------------------

      i3=0;// assumes base 0 ---- fix ---
      j3=0;
      k3=0;
      const int ni0=ni;
      ni=0; // reset -- we will recount
      for( int i=interpolationPoint0.getBase(0); i<=interpolationPoint0.getBound(0); i++ )  // finer grid interp pts
      {
        for( int axis=0; axis<numberOfDimensions; axis++ )
	{
  	  iv[axis]=ip0(i,axis);
          jv[axis]=(iv[axis] - INDEXRANGE(0,axis))/2;  // ******************* 2 should be  cf
	}
        if( (i1%2)==0 && (i2%2)==0 && (i3%2)==0 )  // ******************* %2 should be % cf
	{  // fine grid interp pt matches coarse grid interp pt.

	  assert( MASK1(j1,j2,j3) & MappedGrid::ISinterpolationPoint );

          // - fprintf(pDebugFile," grid=%i add interp pt i=%i (%i,%i,%i)\n",grid,ni,j1,j2,j3);
          ni++;
          assert( ig0(i)>=0 );
	  INVERSEGRID(j1,j2,j3)=ig0(i);
//           for( int axis=0; axis<numberOfDimensions; axis++ )
// 	    INVERSECOORDINATES(j1,j2,j3,axis)=ci0(i,axis); 

	  const int ii= -MASK1(j1,j2,j3)-1;
	  assert( ii>=0 && ii<ni0 );
          cid[ii].donor=ig0(i);
	  for( int axis=0; axis<numberOfDimensions; axis++ )
	    cid[ii].rv[axis]=ci0(i,axis);   // coarse grid interp. coord's are the same as the fine grid interp. coord's

	}
	
      }

      // -------------------------------------------------------------------------------------------
      // Make a list of extra interpolation points that do not coincide with fine grid pts: 
      //  -  For each coarse grid interp point that matches a fine grid interp point (and has already
      //     been marked), mark any neighbours that are interpolation points and are not marked yet.
      // --------------------------------------------------------------------------------------------

      int jb=0;  // counts new interpolation points
      // Note: in parallel we could have the case when numberOfInterpolationPoints0==0 but there are extra interp pts.
      //       This can happen when the fine grid interp pts are in the parallel ghost boundary
      int maxNumberOfExtraInterpolationPoints=numberOfInterpolationPoints0*numberOfDimensions+100;
                   
      // ---- ib(i,.) : list of `extra' coarse grid interp. pts that we need to find donors for ---
      // 
      // ib(i,0) = i : fine grid interpolation pt, ip0(i,axis), near the coarse grid point 
      // ib(i,1:3) = (j1,j2,j3) : coarse grid point
      // ib(i,4) = ii - points into IA and XA arrays
      // ib(i,5) = grid2 : donor (maybe a guess)
      IntegerArray ib;
      if( thisProcessorHasPoints )
	ib.redim(maxNumberOfExtraInterpolationPoints,6);
      int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
      int ibDim0=ib.getRawDataSize(0);
#define IB(i0,i1) ibp[i0+ibDim0*(i1)]

      IntegerArray gridsToCheck(cg1.numberOfComponentGrids());
      gridsToCheck=0;
      
      for( int i=interpolationPoint0.getBase(0); i<=interpolationPoint0.getBound(0); i++ )
      {
        for( int axis=0; axis<numberOfDimensions; axis++ )
	{
  	  iv[axis]=ip0(i,axis);
          // kv[axis]=(iv[axis] - INDEXRANGE(0,axis))/2;  // wrong if negative
          kv[axis]=(iv[axis] - INDEXRANGE(0,axis) + 8 )/2 -4;
	}
        if( (i1%2)==0 && (i2%2)==0 && (i3%2)==0 
	    && orderOfAccuracy==2 ) // ******************************* 030202
	{  // fine grid interp pt matches coarse grid interp pt.
	}
	else
	{

          // assert( numberOfDimensions<3 );
          const int m3Start=numberOfDimensions<3 ? 0 : -1;
          const int m3End  =numberOfDimensions<3 ? 0 : +1;
          for( int m3=m3Start; m3<=m3End; m3++ )
	  {
	    j3=k3+m3;
	    for( int m2=-1; m2<=1; m2++ )
	    {
	      j2=k2+m2;
	      for( int m1=-1; m1<=1; m1++ )
	      {
		j1=k1+m1;

		
		if( (MASK1(j1,j2,j3) & MappedGrid::ISinterpolationPoint) && INVERSEGRID(j1,j2,j3)==-1 )
		{
                  // this neighbour has not been marked yet.
                  // skip points outside (these could be periodic images of interp points) *wdh* 021006
                  if( j1<eir(0,0) || j1>eir(1,0) ) continue;
                  if( j2<eir(0,1) || j2>eir(1,1) ) continue;
                  if( numberOfDimensions==3 && (j3<eir(0,2) || j3>eir(1,2)) ) continue;
		  
		  // fprintf(pDebugFile," grid=%i ni=%i i=(%i,%i,%i) k=(%i,%i,%i) check j=(%i,%i,%i) mask1(j)=%i "
                  //           "inverseGrid=%i eir=[%i,%i][%i,%i][%i,%i]\n",
                  //        grid,ni,i1,i2,i3,k1,k2,k3,j1,j2,j3,MASK1(j1,j2,j3),INVERSEGRID(j1,j2,j3),
                  //        eir(0,0),eir(1,0),eir(0,1),eir(1,1),eir(0,2),eir(1,2));

                  // - fprintf(pDebugFile," grid=%i add interp pt i=%i (%i,%i,%i)\n",grid,ni,j1,j2,j3);


		  ni++;

                  // by default we choose the same interpolee grid as point i  -- this may
                  // be changed later
                  assert( ig0(i)>=0 );
                  int grid2=ig0(i); // **** this is a first guess , could try to take closest one 
                  
		  INVERSEGRID(j1,j2,j3)=grid2;
                  gridsToCheck(grid2)=1;

                  IB(jb,0)=i;    // fine grid interp. pt : ip0(i,axis)
                  IB(jb,1)=j1;   // coarse grid point 
                  IB(jb,2)=j2;
                  IB(jb,3)=j3;
                  int ii= -MASK1(j1,j2,j3)-1;
                  assert( ii>=0 && ii<ni0 );
                  IB(jb,4)=ii;    // points into IA and XA arrays
                  IB(jb,5)=grid2; // guess at donor

                  // initialize quality for these points that do not coincide with a fine grid interp. pt.
                  // These values are later set in getInterpolationCoordinatesNew
		  IA(ii,3)=canNotInterpolate;    // interp. quality (current best donor)
		  IA(ii,4)=canNotInterpolate;    // interp. coordinates quality (i.e. quality of "r" coords)

		  if( debugb & 4 ) 
		  {
		    fprintf(pDebugFile,"Extra interp: grid=%i: pt jb=%i i=%i fine=(%i,%i,%i) "
                            "coarse=(%i,%i,%i) ii=%i donor-guess=%i\n",grid,jb,i,i1,i2,i3,j1,j2,j3,ii,grid2);
		  }

		  jb++;
		  if( jb>=maxNumberOfExtraInterpolationPoints )
		  {
                    maxNumberOfExtraInterpolationPoints=int(maxNumberOfExtraInterpolationPoints*1.5+1);
		    
                    fprintf(pDebugFile,"myid=%i: INFO: increasing maxNumberOfExtraInterpolationPoints to %i\n",
			   myid,maxNumberOfExtraInterpolationPoints);
		    ib.resize(maxNumberOfExtraInterpolationPoints,ib.getLength(1));
		  }
		  
		} // end if (MASK1
		// j1-=m1;
	      } // end for m1
	      // j2-=m2;
	    }
	    // j3-=m3;
	  } // end for m3
	}
	
      }  // end for i
      


      // *wdh* 100101
      if( ni<numberOfInterpolationPoints(grid) )
      {
	// In some cases in parallel not all interp pts on the coarse grid will be marked
        // (when consecutive fine grid interp pts lie on parallel ghost pts)
        // c.f. -g=cic.bbmg2, -n8 
        Index J1=Range(eir(0,0),eir(1,0));
        Index J2=Range(eir(0,1),eir(1,1));
        Index J3=Range(eir(0,2),eir(1,2));
	
	FOR_3(j1,j2,j3,J1,J2,J3)
	{
	  if( MASK1(j1,j2,j3) & MappedGrid::ISinterpolationPoint  && INVERSEGRID(j1,j2,j3)==-1 )
	  {

            // - fprintf(pDebugFile," grid=%i add interp pt i=%i (%i,%i,%i)  (EXTRA)\n",grid,ni,j1,j2,j3);

	    ni++;

	    // We need to make a guess for the donor grid: 
                  
	    int grid2 = (grid+1) % numberOfComponentGrids;  // do this for now ---
	    INVERSEGRID(j1,j2,j3)=grid2;
	    gridsToCheck(grid2)=1;

            // **FIX ME**
            int i=-1;  // this is usually the number of the fine grid interpolation point **do better here**
	    IB(jb,0)=i;  // index into original interpolation point arrays  **** fix me *** *************************
	    IB(jb,1)=j1;
	    IB(jb,2)=j2;
	    IB(jb,3)=j3;
	    int ii= -MASK1(j1,j2,j3)-1;
	    assert( ii>=0 && ii<ni0 );
	    IB(jb,4)=ii;  // points into IA and XA arrays		  
            IB(jb,5)=grid2;

	    // initialize quality for these points that do not coincide with a fine grid interp. pt.
	    // These values are later set in getInterpolationCoordinatesNew
	    IA(ii,3)=canNotInterpolate;    // interp. quality (current best donor)
	    IA(ii,4)=canNotInterpolate;    // interp. coordinates quality (i.e. quality of "r" coords)

	    jb++;
	    if( jb>=maxNumberOfExtraInterpolationPoints )
	    {
	      maxNumberOfExtraInterpolationPoints=int(maxNumberOfExtraInterpolationPoints*1.5+1);
		    
	      fprintf(pDebugFile,"myid=%i: INFO: increasing maxNumberOfExtraInterpolationPoints to %i\n",
		     myid,maxNumberOfExtraInterpolationPoints);
	      ib.resize(maxNumberOfExtraInterpolationPoints,ib.getLength(1));
	    }
             
	  }
	} // end FOR_3
	
      }
      
      const int numberOfExtraInterpolationPoints=jb;

      if( debugb & 8 )
        display(inverseGrid,sPrintF(buff,"After initial setting of inverseGrid: level=%i grid=%i",level,grid),pDebugFile);

      if( debugb & 4 )
      {
        fprintf(pDebugFile," *** number of interpolation points assigned, ni=%i, level=%i grid=%i "
		"numberOfInterpolationPoints=%i, numExtra=%i\n",ni,level,grid,numberOfInterpolationPoints(grid),
               numberOfExtraInterpolationPoints );
	fflush(pDebugFile);
      }
      
      if( ni!=numberOfInterpolationPoints(grid) )
      {
	printf("buildExtraLevels:ERROR: myid=%i level=%i grid=%i : ni=%i is NOT equal to numberOfInterpolationPoints(grid)=%i\n",
	       myid,level,grid,ni,numberOfInterpolationPoints(grid));
	fflush(0);
	assert( ni==numberOfInterpolationPoints(grid) );
      }
      

      // --- Evaluate the x coordinates of the interpolation points ---
      // xa(i,0:nd-1) : x-coordinates of the interp. pts, i=0,1,...,ni-1 
      RealArray xa;
      real *xap=NULL;
      int xaDim0=0;
      #define XA(i0,i1) xap[i0+xaDim0*(i1)]

      getInterpolationPointPositions(ni);


      // ------------------------------------------------------------------------
      // --- Compute the interpolation coords for all points
      // ------------------------------------------------------------------------

      intSerialArray & interpoleeGrid = interpoleeGridA[grid];                  interpoleeGrid.redim(R);
      intSerialArray & interpolationPoint = interpolationPointA[grid];          interpolationPoint.redim(R,Rx);
      intSerialArray & interpoleeLocation = interpoleeLocationA[grid];          interpoleeLocation.redim(R,Rx);
      realSerialArray & interpolationCoordinates = interpolationCoordinatesA[grid]; interpolationCoordinates.redim(R,Rx);

      intSerialArray & variableInterpolationWidth = variableInterpolationWidthA[grid]; 
      variableInterpolationWidth.redim(R);
      variableInterpolationWidth=0;
      
      if( parameters.coarseGridInterpolationWidth>0 || orderOfAccuracy==4 )
      {
        // Interpolate to lower order accuracy for fourth-order discretizations -- this assumes the averaged operator
        // on the coarse grid is only second-order anyway.
        Range Rx=mgcg.numberOfDimensions();

        const int defaultInterpWidth = orderOfAccuracy==2 ? 3 : 3;
	
        int interpWidth = (parameters.coarseGridInterpolationWidth<0 ? defaultInterpWidth : 
                           parameters.coarseGridInterpolationWidth);

         //      Need to set: mgcg.interpolationWidth(Rx,grid,grid2,l)
  	mgcg.interpolationWidth(Rx,all,all,level)=interpWidth; 
  	cg1.interpolationWidth(Rx,all,all,all)=interpWidth; 

      }
      
      // NOTE: checkCanInterpolate will use cg.interpolationWidth and interpolationOverlap 
      // temporarily change these for the canInterpolate function:
      int donor=0;
      const int widthOld = cg1.interpolationWidth(0,grid,donor,0);
      const real ovOld =  cg1.interpolationOverlap(0,grid,donor,0);
      
      // Can we be sure that cgCanInterpolate is consistent with getInterpolationStencil??
      // cgCanInterpolate:         ia=rr-ov,      ib=rr+ov+1  -> width = 2*ov+1 -> ov=(width-1)/2
      // getInterpolationStencil : ia=rr-.5*iw+1  ib=rr+.5*iw -> ov=.5*iw-1 = .5*(width-2)
      // Ogen: changeParameters: ov = .5*(iw-2) for implicit interp

      int interpolationWidth=3;  // *********** fix me 

      Range Rx=numberOfDimensions;
	
      real ov=max(0., (interpolationWidth-2.)/2. ) ; // Is this correct?
      cg1.interpolationWidth(Rx,all,all,all)=interpolationWidth;  // target interp. width
      cg1.interpolationOverlap(Rx,all,all,all)=ov;

      if( debugb & 8 )
      {
	::display(cg1.interpolationWidth,"cg1.interpolationWidth",pDebugFile);
	::display(cg1.interpolationOverlap,"cg1.interpolationOverlap",pDebugFile);
      }


      // fill in the query data:
      for( int i=0; i<numberToCheck; i++ )
      {
	i1=IA(i,0); i2=IA(i,1); i3=IA(i,2);
	assert( MASK1(i1,i2,i3) & MappedGrid::ISinterpolationPoint );


	cid[i].id=i; cid[i].i=i; 
	cid[i].grid=grid; 
	cid[i].donor=inverseGrid(i1,i2,i3);
        
	// for( int axis=0; axis<numberOfDimensions; axis++ )
	//   cid[i].rv[axis]=inverseCoordinates(i1,i2,i3,axis);
	  
	if( debugb & 4 ) 
	{
	  fprintf(pDebugFile,"grid=%i: pt i=%i : find a valid interp stencil for i=(%i,%i,%i), donor guess=%i, "
		  " ri=(%4.2f,%4.2f,%4.2f)..\n",grid,i,i1,i2,i3,inverseGrid(i1,i2,i3),
                  cid[i].rv[0],cid[i].rv[1],cid[i].rv[2]);
	}
      }

      // -----------------------------------------------------------------------
      // --- get the interpolation coords for the extra interpolation points ---
      // -----------------------------------------------------------------------
      getExtraInterpCoords(numberOfExtraInterpolationPoints);

      for( int i=0; i<numberOfExtraInterpolationPoints; i++ )
      {
	int ii=IB(i,4);
	for( int axis=0; axis<numberOfDimensions; axis++ )
	  cid[ii].rv[axis]=R(i,axis);

      }

      // *wdh* 11/06/12 - for testing check for nan's
      if( false ) 
      {
	for( int i=0; i<numberOfExtraInterpolationPoints; i++ )
	{
	  int ii=IB(i,4);
	  if( cid[ii].rv[0] != cid[ii].rv[0] || cid[ii].rv[1] != cid[ii].rv[1]  )
	  {
            printf("Ogmg:buildExtraLevelsNew:extraInterp:ERROR: myid=%i grid=%i i=%i ii=%i (<numberToCheck=%i) donor=%i, "
		   "cid[ii].rv=[%e,%e,%e] ! nan's ?? \n",
		   myid,grid,i,ii,numberToCheck,inverseGrid(i1,i2,i3),cid[ii].rv[0],cid[ii].rv[1],cid[ii].rv[2]);
	  }
	}
      }
      
      

      if( debugb & 8 )
	display(inverseGrid,sPrintF(buff,"inverseGrid after getInterpolationCoordinates, level=%i grid=%i",level,grid),pDebugFile);

      // ****************************************************
      // ***** Find a valid stencil to interpolate from *****
      // ****************************************************

      // Allocate space for results
      CanInterpolateResultData *cir =new CanInterpolateResultData[max(1,numberToCheck)];

      int pointsRemain = numberToCheck>0;
      pointsRemain = ParallelUtility::getMaxValue(pointsRemain);


      int interpolationStage=-1;
      // =====================================================================================
      // ====== Loop here for checking different donor grids until we find a good donor ======
      // =====================================================================================
      while( pointsRemain )
      {
	interpolationStage++;

        if( debug & 4 )
	  fprintf(pDebugFile,"\n--- Interpolation stage %i : numberToCheck=%i (level=%i, grid=%i) ---\n",
                  interpolationStage,numberToCheck,level,grid);
	

	real timea=getCPU();

	
        // NOTES: 
	//  - canInterpolate will find any valid interpolation by default (i.e. backup results too)
	//  - this function also computes the interpolation stencil

	// *wdh* 091118 : now we can allow interpolation from ghost points.
	int numberOfValidGhostPoints=0; // do this for now 
	const int numValidGhost = numberOfValidGhostPoints>0 ? numberOfValidGhostPoints : 0;
	CanInterpolate::canInterpolate( cg1, numberToCheck,cid, cir, numValidGhost );

	if( debug & 4 )
	{
	  if( numberToCheck>0 )
	  {
	    fprintf(pDebugFile,"  --- buildExtraLevels: stage=%i : after CanInterpolate, level=%i grid=%i : \n",
		    interpolationStage,level,grid);
	    for( int i=0; i<numberToCheck; i++ )
	    {
              const int ii=cid[i].i;
	      fprintf(pDebugFile,"  pt i=%i (ii=%i) (%i,%i,%i) interpolates=%i width=%i from donor=%i il=(%i,%i,%i) "
		      " r=(%8.2e,%8.2e,%8.2e)\n",
		      i,ii,IA(ii,0),IA(ii,1),IA(ii,2),int(cir[i].width>0),
		      cir[i].width,cid[i].donor,cir[i].il[0],cir[i].il[1],cir[i].il[2],
		      cid[i].rv[0],cid[i].rv[1],cid[i].rv[2]);
	    }
	  }
	}
    
	// *************** Assign points that could be interpolated  *****************
        //                 and compress the cid[] list for any remaining points
	int numNotFound=0;
	for( int i=0; i<numberToCheck; i++ )
	{
	  bool validDonorFound=false;
	  int width = cir[i].width;   // interpolation width (=0 if invalid)
	  if( width>0 ) 
	  {
	    // -- valid interpolation ---
            // -- Use these coordinates if the quality is better than the current best quality --

            const int ii=cid[i].i; // index into IA arrays

            const int currentQuality=IA(ii,3);   // current best donor quality
	    
            int newQuality=-1;
	    if( width>=3 )
              newQuality=canInterpolateQuality1;     // best quality, interpolates to correct order
	    else if( width==2 )
	      newQuality=canInterpolateQuality2;     // 2nd best best quality, interpolates to correct order minus 1
            else
	    {
	      assert( width==1 );
              newQuality=canInterpolateQuality3;     // 3rd best quality, interpolates to correct order minus 2
	    }
	    
            real & currentDonorDist = donorDist(ii,0);
	    const real newDonorDist = donorDist(ii,1);

            // The interpolation coordinates used for this point may have been extrapolated in which case
            // the interpolation may not be as good. The quality is taken as the worst of these two values.
            int interpCoordsQuality=IA(ii,4);
	    newQuality = max( newQuality, interpCoordsQuality );

	    if( ( (newQuality < currentQuality) && newDonorDist <= currentDonorDist ) ||
                ( (newQuality <= currentQuality) && newDonorDist < currentDonorDist )   )
	    {
	      // accept this point as the current best quality
              IA(ii,3)=newQuality;  // save current quality

              currentDonorDist = newDonorDist; // update distance 
	      
	      for( int axis=0; axis<numberOfDimensions; axis++ )
	      {
		interpolationPoint(ii,axis)      =IA(ii,axis);
		interpolationCoordinates(ii,axis)=cid[i].rv[axis];
		interpoleeLocation(ii,axis)      =cir[i].il[axis];
	      }
              assert( cid[i].donor>=0 && cid[i].donor<numberOfComponentGrids );  // *wdh* 2013/09/16
	      
	      interpoleeGrid(ii)= cid[i].donor;
	      variableInterpolationWidth(ii)=width;
	    
	      if( newQuality==canInterpolateQuality1 || newQuality==canInterpolateQuality2 )
	      {
		// accept this point
		validDonorFound=true;
	      }
	      if( debug & 4 )
	      {
                fprintf(pDebugFile,"  ... pt=(%i,%i,%i), donor found, quality=(%i,%i) (stage %i) "
			"width=%i for i=%i grid=%i, donor=%i. dist=%8.2e %s. \n",IA(ii,0),IA(ii,1),IA(ii,2),IA(ii,3),IA(ii,4),
			interpolationStage,width,cid[i].i,grid,cid[i].donor, currentDonorDist,
                        (validDonorFound ? "done" : "keep looking.."));
	      }

	    }

	  }

          if( !validDonorFound )
	  {
	    // --- keep a list of points we could not interpolate from, or for which we want better quality ---
            //      : save info in cid

            int ii=cid[i].i;  // index into original IA, XA list
	    int & j=numNotFound;

            // ---------------------------------
	    // --- look for a new donor grid ---
            // ---------------------------------
            const int oldDonor=cid[i].donor;

            // Look from donors starting from the highest priority grid:
            int newDonor=-1;
            if( interpolationStage==0 )
	    { // First time thru start by checking the highest priority grid: (this may be changed below)
              newDonor= numberOfComponentGrids-1;
	    }
	    else
	    { // After the first pass check the last donor checked minus one:
              newDonor=oldDonor-1;  
	    }
	    
            // We need the last donor checked for this point


            // -- Check the distance from the interp pt to the bounding box of the mapping and only
            //    use this as a new potential donor if we are inside or close enough.

	    real distToBox=0.;  // holds distance to the bounding-box of the new donor mapping ( 0. = inside)
            while( newDonor>=0 )  // loop to look for the next potential donor.
	    {
	      while( (newDonor==oldDonor || newDonor==grid) && newDonor>=0 ) // skip old-donor and target grid
	      {
                newDonor--;
	      }
	      if( newDonor < 0 ) break;

              // -- Q. which bounding box should we use ?
              // Use the fine grid BB : compute once, but more expensive to compute and may miss extended ghost points
	      // mgcg[newDonor].update(MappedGrid::THEboundingBox);  // ************* FIX ME *********************
	      // const RealArray & boundingBox = mgcg[newDonor].boundingBox(); 
              const RealArray & boundingBox = mgcg.multigridLevel[0][newDonor].boundingBox(); 

              // -- coarse grids do not have a valid bounding box:
	      // cg0[newDonor].update(MappedGrid::THEboundingBox);  // ************* FIX ME *********************
	      // const RealArray & boundingBox = cg0[newDonor].boundingBox(); 

              // This one is not valid yet:
	      // cg1[newDonor].update(MappedGrid::THEboundingBox);  // ************* FIX ME *********************
	      // const RealArray & boundingBox = cg1[newDonor].boundingBox(); 
              // We could use the one in the mapping so we don't need to recompute it ? But doesn't include ghost!
              // const RealArray & boundingBox = mgcg[newDonor].mapping().getMapping().getBoundingBox();

	      // Check this donor grid if:
	      //    1. We are inside the boundingBox
	      //    2. We are outside the BB but at a distance that is less than the current donorDist

	      //Note the square of the dist from a point x outside the box is just the sum of the 
	      // squares of the distances to the the planes that bound the box
	      //         |        |
	      // ________|________|_______
	      //         |        |
	      //     x   |  Box   |
	      //  _______|________|______
	      //         |        |
	      //     x   |   x    |
	      // 
	      distToBox=0.; // distance is zero if inside, otherwise the distance to the bounding box
	      for( int axis=0; axis<numberOfDimensions; axis++ )
	      {
		real xx = XA(ii,axis);
		if( xx<boundingBox(0,axis) )
		{
		  distToBox += SQR(xx-boundingBox(0,axis));
		}
		else if( xx>boundingBox(1,axis) ) 
		{
		  distToBox += SQR(xx-boundingBox(1,axis));
		}
	      }
	      if( distToBox==0. ) 
	      {
		break;  // we are inside the bounding box, check this donor grid.
	      }
	      else
	      {
		// point is outside the box:
		distToBox=sqrt(distToBox);
		if( distToBox < donorDist(ii,0) )
		{
                  // The distance to the box is less than the current best distance between interp. pt. and donor pt.
                  // We should thus check this box:
                  break;
		}
	      }
              
              // keep looking for a valid new donor:
              newDonor--;

	    }  // end while newDonor >= 0 

            // Note: if newDonor<0 then are no more donor grids to check for this point. 
            // We will use the current best guess for the donor, and the point will not be added to the list below.
            if( newDonor>=0 )
	    {
	      cid[i].donor=newDonor;

	      if( i!=j )
	      {
		cid[j]=cid[i]; // deep copy 
	      }
	    
	      numNotFound++;

	      if( debug & 4 )
	      {
   	        const int ii=cid[i].i; // index into IA arrays
		if( width>0 )
		{
		  if( oldDonor==interpoleeGrid(ii) )
		  {
		    fprintf(pDebugFile,"  ... pt=(%i,%i,%i) donor=%i found but poor quality=(%i,%i) (stage %i) "
			    "width=%i for i=%i grid=%i, new-donor-to-check=%i (distToBox=%8.2e) dist-to-donor=%8.2e, Keep looking... \n",
			    IA(ii,0),IA(ii,1),IA(ii,2),oldDonor,IA(ii,3),IA(ii,4),
			    interpolationStage,width,cid[i].i,grid,newDonor,distToBox,donorDist(ii,0));
		  }
		  else
		  {
		    fprintf(pDebugFile,"  ... pt=(%i,%i,%i) possible donor=%i (dist=%8.2e) but NOT better than donor=%i, current-quality=(%i,%i) (stage %i) "
			    "width=%i for i=%i grid=%i, new-donor-to-check=%i (distToBox=%8.2e) dist-to-donor=%8.2e, Keep looking... \n",
			    IA(ii,0),IA(ii,1),IA(ii,2),oldDonor,donorDist(ii,1),interpoleeGrid(ii),IA(ii,3),IA(ii,4),
			    interpolationStage,width,cid[i].i,grid,newDonor,distToBox,donorDist(ii,0));
		  }
		  
		}
		else
		{
		  fprintf(pDebugFile,"  ... pt=(%i,%i,%i) donor NOT found (stage %i) width=0 for i=%i grid=%i, donor=%i, current-donor=%i"
			  " new-donor=%i (distToBox=%8.2e) current-quality=%i. current-dist=%8.2e. Keep looking... \n",
			  IA(ii,0),IA(ii,1),IA(ii,2),interpolationStage,cid[i].i,grid,oldDonor,interpoleeGrid(ii),
                          newDonor,distToBox,IA(ii,3),donorDist(ii,0));
		}
	      
	      }
	    }
	    
	  }
	  
	}

	numberToCheck=numNotFound;
        pointsRemain = ParallelUtility::getMaxValue(numberToCheck);
	if( pointsRemain && debug & 4 )
	  fprintf(pDebugFile," myid=%i : After CanInterpolate for interpolationStage=%i, numNotFound=%i. (numberOfComponentGrids=%i)\n",
		  myid,interpolationStage,numberToCheck,numberOfComponentGrids);

	if( interpolationStage==(numberOfComponentGrids-2) )
	{
	  break;
	}
	

	if( pointsRemain )
	{
	  // ---- Recompute the ib array ----

	  if( numberToCheck>0 )
            ib.resize(numberToCheck,ib.getLength(1));
          else
            ib.redim(0);
          // re-compute macro parameters: 
	  ibp = ib.Array_Descriptor.Array_View_Pointer1;
          ibDim0=ib.getRawDataSize(0);
          gridsToCheck=0;

          for(int i=0; i<numberToCheck; i++ ) 
	  {
            IB(i,0)=-1;  // index into fine grid interp. arrays, -1 means there is none

            int ii=cid[i].i;  // index into original IA list
            IB(i,4)=ii;       
            IB(i,3)=0;
            for( int axis=0; axis<numberOfDimensions; axis++ )
	    {
	      IB(i,axis+1)=IA(ii,axis);
	    }
	    IB(i,5)=cid[i].donor;

            const int newDonor=cid[i].donor;
	    gridsToCheck(newDonor)=1;

	  }
	  
          // -- Get the "r" coordinates of the remaining points ---

          getExtraInterpCoords(numberToCheck);

	  // fill in the query data r-coords:
 	  for( int i=0; i<numberToCheck; i++ )
 	  {
	    if( debug & 2  )
	    { // sanity check: 
	      int ii=cid[i].i;
	      i1=IA(ii,0); i2=IA(ii,1); i3=IA(ii,2);
	      assert( MASK1(i1,i2,i3) & MappedGrid::ISinterpolationPoint );
	    }
	    
 	    for( int axis=0; axis<numberOfDimensions; axis++ )
 	      cid[i].rv[axis]=R(i,axis); // inverseCoordinates(i1,i2,i3,axis);
	  
 	  }
	  
	}
    
// 	if( interpolationStage>numberOfComponentGrids )
// 	{
//           printF("buildExtraLevels:ERROR: interpolationStage>numberOfComponentGrids=%i -- "
//                 "this should probably not happen.\n",numberOfComponentGrids);
//           OV_ABORT("error");
// 	}
	

      } // end while pointsRemain
      
      if( interpolationStage==(numberOfComponentGrids-2) && pointsRemain ) // *wdh* 2013/09/17 fixed -1 -> -2
      {
	if( debug & 4 )
	{
          fprintf(pDebugFile,"\n ===== WARNING: %i points have poor quality donors. ==== \n",numberToCheck);
	}
	bool ok=true;
	for(int i=0; i<numberToCheck; i++ ) 
	{
           int ii=cid[i].i;
	   if( IA(ii,3)==canNotInterpolate )
	   {
             int i1=IA(ii,0), i2=IA(ii,1), i3=IA(ii,2);
             if( debug & 4 )
	       fprintf(pDebugFile,"level=%i, grid=%i, Unable to interpolate pt ii=%i iv=(%i,%i,%i) mask1=%i\n",level,grid,ii,i1,i2,i3,
		    MASK1(i1,i2,i3));

             // --- look for a neighbour that can interpolate and use the same donor ---
             int quality=canNotInterpolate; // look for best quality neighbour
             int neighbourIndex=-1;         // save IA index of best neighbour here 
             const int width=1, width3=numberOfDimensions==2 ? 0 : width;
	     for( int j3=i3-width3; j3<=i3+width3; j3++ )
	     {
	       for( int j2=i2-width ; j2<=i2+width ; j2++ )
	       {
		 for( int j1=i1-width ; j1<=i1+width ; j1++ )
		 {
		   if( debug & 4 )
		     fprintf(pDebugFile," jv=(%i,%i,%i) mask1=%i : ",j1,j2,j3,MASK1(j1,j2,j3));
		   if( (j1!=i1 || j2!=i2 || j3!=i3) && MASK1(j1,j2,j3)<0 )
		   {
		     int jj= -MASK1(j1,j2,j3)-1;
		     assert( jj>=0 && jj<ni0 );
		     if( debug & 4 )
		       fprintf(pDebugFile," canInterp=%i (0=best,%i=no), donor=%i il=(%i,%i) r=(%e,%e)",IA(jj,3),(int)canNotInterpolate,
			      interpoleeGrid(jj),
			      interpoleeLocation(jj,0),interpoleeLocation(jj,1),
			      interpolationCoordinates(jj,0),interpolationCoordinates(jj,1));

		     int newQuality=IA(jj,3);
		     if( newQuality<quality )
		     {
		       quality=newQuality;
                       neighbourIndex=jj;
		     }
		     
		   }
		   if( debug & 4 ) fprintf(pDebugFile,"\n");
		 }
	       }
	     }
	     if( quality!=canNotInterpolate )
	     {
               // --- use the donor from a neighbour ---
               // For now just use the same interp. coords -- we could do better

               if( debug & 4 ) fprintf(pDebugFile,"Use donor from neighbour with index jj=%i, quality=%i\n",neighbourIndex,quality);

	       IA(ii,3)=canInterpolateQualityVeryBad; // mark this point as canInterpolate but with poor quality

	       for( int axis=0; axis<numberOfDimensions; axis++ )
	       {
		 interpolationPoint(ii,axis)      =IA(ii,axis);
		 interpolationCoordinates(ii,axis)=interpolationCoordinates(neighbourIndex,axis);
		 interpoleeLocation(ii,axis)      =interpoleeLocation(neighbourIndex,axis);
	       }
	       interpoleeGrid(ii)=interpoleeGrid(neighbourIndex);
	       variableInterpolationWidth(ii)=variableInterpolationWidth(neighbourIndex);

	     }
	   } // end if IA(ii,3)==canNotInterpolate
	   
	   if( IA(ii,3)==canNotInterpolate )
	     ok=false;

	}
	if( !ok )
	{
          // *FIX ME* -- as a backup we could just interpolate from the a nearby point on the same grid?

	  printf("Ogmg::buildExtraLevels:ERROR: unable to find donors for some coarse grid points!\n");
	  printf("      level=%i, grid=%i, number not found=%i!\n",level,grid,numberToCheck);
	  printf("myid=%i : grid=%i numberOfInterpolationPoints=%i\n",myid,grid,numberOfInterpolationPoints(grid));
	  ::display(interpolationPoint,"interpolationPoint");
	  ::display(interpoleeGrid,"interpoleeGrid");

	  OV_ABORT("ERROR");
	}
	
      }

      delete [] cid;
      delete [] cir;
      

      timeForValidStencil+=getCPU()-timea;
      
      if( debugb & 4 )
      {
	display(interpoleeLocation,sPrintF(buff,"interpoleeLocation, level=%i grid=%i",level,grid),pDebugFile);
	display(interpolationCoordinates,sPrintF(buff,"interpolationCoordinates, level=%i grid=%i",level,grid),pDebugFile);
	display(variableInterpolationWidth,sPrintF(buff,"variableInterpolationWidth, level=%i grid=%i",level,grid),pDebugFile);
      }
      


    }  // end for grid
    timeForBuildInterpolation+=getCPU()-timeb;
    


    // --- mark ghost points as "2" or 0  ---
    // note: this next routine also does a periodic update
    markGhostPoints( cg1 );
    if( debugb & 4 )
    {
      for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
      {
	intSerialArray mask1Local; getLocalArrayWithGhostBoundaries(cg1[grid].mask(),mask1Local);
	displayMask(mask1Local,"Ogmg::buildExtraLevels: mask1 after markGhostPoints",pDebugFile);
      }
    }
    

    // display(cg1.numberOfInterpolationPoints,"cg1.numberOfInterpolationPoints");
    

    // dimension new serial array interpolation data arrays
#define adjustSizeMacro(x,n)			\
    while( x.getLength() < n )			\
      x.addElement();				\
    while( x.getLength() > n )			\
      x.deleteElement()

    // *wdh* 091201 -- for parallel see classify.C l. 3879 ---

    // **TODO: set cg1->numberOfInterpolationPointsLocal  ------------------------------------************** FIX
    //             cg1->interpolationStartEndIndexLocal 

     #ifdef USE_PPP
      // numberOfInterpolationPoints(grid) = number of interp pts. on this processor
      // cg1.numberOfInterpolationPoints(grid) = sum total over all processors

      ParallelUtility::getSums( &numberOfInterpolationPoints(0), &cg1.numberOfInterpolationPoints(0), numberOfComponentGrids);

      // tell the CompositeGrid that we are storing the interp data in a local serial form:
      cg1->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;

      adjustSizeMacro(cg1->interpolationPointLocal,numberOfComponentGrids);
      adjustSizeMacro(cg1->interpoleeGridLocal,numberOfComponentGrids);
      adjustSizeMacro(cg1->variableInterpolationWidthLocal,numberOfComponentGrids);
      adjustSizeMacro(cg1->interpoleeLocationLocal,numberOfComponentGrids);
      adjustSizeMacro(cg1->interpolationCoordinatesLocal,numberOfComponentGrids);
    #else
     cg1.numberOfInterpolationPoints(Rg)=numberOfInterpolationPoints(Rg);
     // now we know how many interpolation points there are so we can create the arrays in the cg.
     cg1.update(
       CompositeGrid::THEinterpolationPoint       |
       CompositeGrid::THEinterpoleeGrid           |
       CompositeGrid::THEinterpoleeLocation       |
       CompositeGrid::THEinterpolationCoordinates,
       CompositeGrid::COMPUTEnothing);
    #endif

    if( debugb & 4 )
      display(cg1.numberOfInterpolationPoints,"cg1.numberOfInterpolationPoints",debugFile);


    //  printF("*** mgcg.interpolationIsAllExplicit()=%i\n",mgcg.interpolationIsAllExplicit());
    //  printF("*** cg0.interpolationIsAllExplicit()=%i\n",cg0.interpolationIsAllExplicit());
    //  printF("*** cg1.interpolationIsAllExplicit()=%i\n",cg1.interpolationIsAllExplicit());
    // 	cg1.interpolationIsImplicit.display("cg1.interpolationIsImplicit");

    // ---- Fill in the interpolation info. ----

    cg1->numberOfInterpolationPointsLocal.redim(cg1.numberOfComponentGrids());
    IntegerArray & interpolationStartEndIndex = cg1->interpolationStartEndIndex;
    

    IntegerArray gridStart(cg1.numberOfComponentGrids()), ng(cg1.numberOfComponentGrids());
    for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
    {
      for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
      {
	// in parallel we set interpolation is implicit even if there are no local interp pts: *wdh* 100101
	mgcg.interpolationIsImplicit(grid,grid2,level)=true;
	cg1.interpolationIsImplicit(grid,grid2,0)=true;

      }
      
      cg1->numberOfInterpolationPointsLocal(grid)=numberOfInterpolationPoints(grid);
      if( numberOfInterpolationPoints(grid) > 0 )
      {
        const int nig=numberOfInterpolationPoints(grid);

        #ifdef USE_PPP
         intSerialArray & interpoleeGrid1             = cg1->interpoleeGridLocal[grid]; 
         intSerialArray & interpolationPoint1         = cg1->interpolationPointLocal[grid];
         intSerialArray & interpoleeLocation1         = cg1->interpoleeLocationLocal[grid];
         intSerialArray & variableInterpolationWidth1 = cg1->variableInterpolationWidthLocal[grid];
         realSerialArray & interpolationCoordinates1  = cg1->interpolationCoordinatesLocal[grid];

         interpoleeGrid1.redim(nig);
         interpolationPoint1.redim(nig,numberOfDimensions);
         interpoleeLocation1.redim(nig,numberOfDimensions);
         variableInterpolationWidth1.redim(nig);
         interpolationCoordinates1.redim(nig,numberOfDimensions);

        #else
         const intArray & interpoleeGrid1            = cg1.interpoleeGrid[grid]; 
         const intArray & interpolationPoint1        = cg1.interpolationPoint[grid];
	 intArray & interpoleeLocation1              = cg1.interpoleeLocation[grid];
         intArray & variableInterpolationWidth1      = cg1.variableInterpolationWidth[grid];
         const realArray & interpolationCoordinates1 = cg1.interpolationCoordinates[grid];
        #endif  

	intSerialArray & interpoleeGrid            = interpoleeGridA[grid];
	intSerialArray & interpolationPoint        = interpolationPointA[grid];
	intSerialArray & interpoleeLocation        = interpoleeLocationA[grid];
        intSerialArray & variableInterpolationWidth=variableInterpolationWidthA[grid];
	realSerialArray & interpolationCoordinates = interpolationCoordinatesA[grid]; 

      const int *interpoleeLocationp = interpoleeLocation.Array_Descriptor.Array_View_Pointer1;
      const int interpoleeLocationDim0=interpoleeLocation.getRawDataSize(0);
#define il(i0,i1) interpoleeLocationp[i0+interpoleeLocationDim0*(i1)]
      int *interpoleeLocation1p = interpoleeLocation1.Array_Descriptor.Array_View_Pointer1;
      const int interpoleeLocation1Dim0=interpoleeLocation1.getRawDataSize(0);
#define il1(i0,i1) interpoleeLocation1p[i0+interpoleeLocation1Dim0*(i1)]

      const int *interpolationPointp = interpolationPoint.Array_Descriptor.Array_View_Pointer1;
      const int interpolationPointDim0=interpolationPoint.getRawDataSize(0);
#define ip(i0,i1) interpolationPointp[i0+interpolationPointDim0*(i1)]
      int *interpolationPoint1p = interpolationPoint1.Array_Descriptor.Array_View_Pointer1;
      const int interpolationPoint1Dim0=interpolationPoint1.getRawDataSize(0);
#define ip1(i0,i1) interpolationPoint1p[i0+interpolationPoint1Dim0*(i1)]

      const real *interpolationCoordinatesp = interpolationCoordinates.Array_Descriptor.Array_View_Pointer1;
      const int interpolationCoordinatesDim0=interpolationCoordinates.getRawDataSize(0);
#define ci(i0,i1) interpolationCoordinatesp[i0+interpolationCoordinatesDim0*(i1)]
      real *interpolationCoordinates1p = interpolationCoordinates1.Array_Descriptor.Array_View_Pointer1;
      const int interpolationCoordinates1Dim0=interpolationCoordinates1.getRawDataSize(0);
#define ci1(i0,i1) interpolationCoordinates1p[i0+interpolationCoordinates1Dim0*(i1)]


      int * interpoleeGridp = interpoleeGrid.Array_Descriptor.Array_View_Pointer0;
#define ig(i0) interpoleeGridp[i0]
      int * interpoleeGrid1p = interpoleeGrid1.Array_Descriptor.Array_View_Pointer0;
#define ig1(i0) interpoleeGrid1p[i0]
      int * ngp = ng.Array_Descriptor.Array_View_Pointer0;
#define NG(i0) ngp[i0]

      int * gridStartp = gridStart.Array_Descriptor.Array_View_Pointer0;
#define GRIDSTART(i0) gridStartp[i0]
      const int * variableInterpolationWidthp = variableInterpolationWidth.Array_Descriptor.Array_View_Pointer0;
#define viw(i0) variableInterpolationWidthp[i0]
      int * variableInterpolationWidth1p = variableInterpolationWidth1.Array_Descriptor.Array_View_Pointer0;
#define viw1(i0) variableInterpolationWidth1p[i0]

        // -- order the interpolation points by interpolee grid. ---
	ng=0;
	for( int i=0; i<nig; i++ )
	{
// 	  if( ig(i)<0 || ig(i) >= cg1.numberOfComponentGrids() ) 
// 	  {
// 	    printf("ERROR: level=%i, grid=%i, i=%i ig(i)=%i numberOfComponentGrids=%i\n",level,grid,i,ig(i),cg1.numberOfComponentGrids());
//             ::display(interpoleeGrid,"interpoleeGrid");
//             ::display(interpolationPoint,"interpolationPoint");
//             ::display(interpolationCoordinates,"interpolationCoordinates");
//             OV_ABORT("error");
// 	  }
	  NG(ig(i))++;
	}
	    
	GRIDSTART(0)=0;
	for( int grid2=1; grid2<cg1.numberOfComponentGrids(); grid2++ )
	  GRIDSTART(grid2)=GRIDSTART(grid2-1)+NG(grid2-1);
	
        // ***** we need to assign the interpolationStartEndIndex 
        // **** this needs to be set on multigridLevel[0] too ********

        // for now we assume that the interpolation is implicit on coarser levels *** fix this ***

        cg1.interpolationIsAllExplicit()=false;
        cg1.interpolationIsAllImplicit()=true;
	
	for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
	{
	  if( NG(grid2)>0 )
	  {

	    interpolationStartEndIndex(0,grid,grid2)=GRIDSTART(grid2);              // start value
	    interpolationStartEndIndex(1,grid,grid2)=GRIDSTART(grid2)+NG(grid2)-1;  // end value
	    if( true || cg1.interpolationIsImplicit(grid,grid2,0) )
	      interpolationStartEndIndex(2,grid,grid2)= interpolationStartEndIndex(1,grid,grid2);
            // fix this: put any implicit points first
            // 	   else if( ngi(grid2)>0 )
            // 	     cg1.interpolationStartEndIndex(2,grid,grid2)=GRIDSTART(grid2)+ngi(grid2)-1; // end value for implicit pts.
	  }
	}


        if( numberOfDimensions==2 )
	{
	  for( int i=0; i<nig; i++ )
	  {
	    int grid2=ig(i);
	    int j=GRIDSTART(grid2);
	    ig1(j)=grid2;
	    ip1(j,0)=ip(i,0);
	    ip1(j,1)=ip(i,1);
	    il1(j,0)=il(i,0);
	    il1(j,1)=il(i,1);
	    ci1(j,0)=ci(i,0);
	    ci1(j,1)=ci(i,1);
	    viw1(j)=viw(i);
	  
	    GRIDSTART(grid2)++;
	  }
	}
	else
	{
	  for( int i=0; i<nig; i++ )
	  {
	    int grid2=ig(i);
	    int j=GRIDSTART(grid2);
	    interpoleeGrid1(j)=grid2;
	    ip1(j,0)=ip(i,0);
	    ip1(j,1)=ip(i,1);
	    ip1(j,2)=ip(i,2);
	    il1(j,0)=il(i,0);
	    il1(j,1)=il(i,1);
	    il1(j,2)=il(i,2);
	    ci1(j,0)=ci(i,0);
	    ci1(j,1)=ci(i,1);
	    ci1(j,2)=ci(i,2);
	    viw1(j)=viw(i);
	  
	    GRIDSTART(grid2)++;
	  }
	}
	
	if( debugb & 4 )
	{
	  fprintf(pDebugFile,"myid=%i : grid=%i numberOfInterpolationPoints=%i\n",myid,grid,numberOfInterpolationPoints(grid));
	  ::display(interpolationPoint1,"interpolationPoint1",pDebugFile);
	  ::display(interpoleeGrid1,"interpoleeGrid1",pDebugFile);
	  ::display(interpoleeLocation1,"interpoleeLocation1",pDebugFile);
	  ::display(variableInterpolationWidth1,"variableInterpolationWidth1",pDebugFile);
	  ::display(interpolationCoordinates1,"interpolationCoordinates1",pDebugFile,"%5.2f ");
	}

      } // end if num-interp > 0 


    } // end for grid 
    
  
    //  Tell the CompositeGrid that the interpolation data have been computed:
    cg1->computedGeometry |=
      CompositeGrid::THEmask                     |
      CompositeGrid::THEinterpolationCoordinates |
      CompositeGrid::THEinterpolationPoint       |
      CompositeGrid::THEinterpoleeLocation       |
      CompositeGrid::THEinterpoleeGrid;

    // we also need to mark each MappedGrid (or else we lose the mask if we put/get to a file)
    for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
      cg1[grid]->computedGeometry |= MappedGrid::THEmask;     // added 030829 *wdh*



    // --- Save the local interp data in the top level CompositeGrid  mgcg ---
    #ifdef USE_PPP
    if( l==0 )
    {
      // -- now we have local interp. data at all levels, including level=0 ---

      // --- is this needed ?
      mgcg->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;

      // Why dor we fill in all levels here ? 
      const int numGridsAllLevels = numberOfComponentGrids*mgcg.numberOfMultigridLevels();  // total number of grids over all levels
      adjustSizeMacro(mgcg->interpolationPointLocal,numGridsAllLevels);
      adjustSizeMacro(mgcg->interpoleeGridLocal,numGridsAllLevels);
      adjustSizeMacro(mgcg->variableInterpolationWidthLocal,numGridsAllLevels);
      adjustSizeMacro(mgcg->interpoleeLocationLocal,numGridsAllLevels);
      adjustSizeMacro(mgcg->interpolationCoordinatesLocal,numGridsAllLevels);

      mgcg->numberOfInterpolationPointsLocal.redim(numGridsAllLevels);
    }
    
    if( true )
    {
      // --- We replace the interpolation data on the previous level (l) with the interpolation data ---
      //     that is local to this processor (computed with getLocalInterpolationData) 
      // NOTE: the "local" interp data computed above for level="level" is local to the finer level grid, level=l
      //       not the current level
      CompositeGrid & cgl = mgcg.multigridLevel[l];
      cgl->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;
      adjustSizeMacro(cgl->interpolationPointLocal,numberOfComponentGrids);
      adjustSizeMacro(cgl->interpoleeGridLocal,numberOfComponentGrids);
      adjustSizeMacro(cgl->variableInterpolationWidthLocal,numberOfComponentGrids);
      adjustSizeMacro(cgl->interpoleeLocationLocal,numberOfComponentGrids);
      adjustSizeMacro(cgl->interpolationCoordinatesLocal,numberOfComponentGrids);

      cgl->numberOfInterpolationPointsLocal.redim(numberOfComponentGrids);
      for( int grid=0; grid<numberOfComponentGrids; grid++ )
      {
        InterpolationData & ipd = interpData[grid];

	if( debugb & 2 )
	{
	  fprintf(pDebugFile," Ogmg: Fill-in local-interp data at level=%i : grid=%i, ni=%i\n",l,grid,ipd.numberOfInterpolationPoints);
	  // ::display(ipd.interpolationPoint,"ipd.interpolationPoint");
	}
	
        cgl->numberOfInterpolationPointsLocal(grid)=ipd.numberOfInterpolationPoints;
        cgl->interpolationPointLocal[grid].reference(ipd.interpolationPoint);
        cgl->interpoleeGridLocal[grid].reference(ipd.interpoleeGrid);
        cgl->variableInterpolationWidthLocal[grid].reference(ipd.variableInterpolationWidth);
        cgl->interpoleeLocationLocal[grid].reference(ipd.interpoleeLocation);
        cgl->interpolationCoordinatesLocal[grid].reference(ipd.interpolationCoordinates);
      }

      if( false  )
      {
	for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
	{
	  printF(" grid=%i, nig=%i\n",grid,cgl->numberOfInterpolationPointsLocal(grid));
	  ::display(cgl->interpoleeGridLocal[grid],"cgl->interpoleeGridLocal");
	  ::display(cgl->interpolationPointLocal[grid],"cgl->interpolationPointLocal");
	}
	
      }

      // sort the local interp. arrays and build the interpolationStartEndIndex array: 
      ParallelGridUtility::sortLocalInterpolationPoints(cgl);

      if( level==lastLevel )
      {
        // --- On the coarsest level we transfer the interpolation data to local arrays  ---
        // -- this is duplicate code from above : fix me --
        InterpolationData *interpData=NULL;
	ParallelGridUtility::getLocalInterpolationData( cg1, interpData );
	CompositeGrid & cgl = mgcg.multigridLevel[level];  // Note: level (not l)
	cgl->localInterpolationDataState=CompositeGridData::localInterpolationDataForAll;
	adjustSizeMacro(cgl->interpolationPointLocal,numberOfComponentGrids);
	adjustSizeMacro(cgl->interpoleeGridLocal,numberOfComponentGrids);
	adjustSizeMacro(cgl->variableInterpolationWidthLocal,numberOfComponentGrids);
	adjustSizeMacro(cgl->interpoleeLocationLocal,numberOfComponentGrids);
	adjustSizeMacro(cgl->interpolationCoordinatesLocal,numberOfComponentGrids);

	cgl->numberOfInterpolationPointsLocal.redim(numberOfComponentGrids);
	for( int grid=0; grid<numberOfComponentGrids; grid++ )
	{
	  InterpolationData & ipd = interpData[grid];

	  if( debugb & 2 )
	  {
	    fprintf(pDebugFile," Ogmg: Fill-in local-interp data at level=%i : grid=%i, ni=%i (LAST level)\n",
                   level,grid,ipd.numberOfInterpolationPoints);
	    // ::display(ipd.interpolationPoint,"ipd.interpolationPoint");
	  }
	
	  cgl->numberOfInterpolationPointsLocal(grid)=ipd.numberOfInterpolationPoints;
	  cgl->interpolationPointLocal[grid].reference(ipd.interpolationPoint);
	  cgl->interpoleeGridLocal[grid].reference(ipd.interpoleeGrid);
	  cgl->variableInterpolationWidthLocal[grid].reference(ipd.variableInterpolationWidth);
	  cgl->interpoleeLocationLocal[grid].reference(ipd.interpoleeLocation);
	  cgl->interpolationCoordinatesLocal[grid].reference(ipd.interpolationCoordinates);
	}

	// sort the local interp. arrays and build the interpolationStartEndIndex array: 
	ParallelGridUtility::sortLocalInterpolationPoints(cgl);

        delete [] interpData;

      }

    }

    #endif

    delete [] interpData;


#undef ip
#undef il
#undef ig
#undef viw
#undef ci

    //  -- save a check file of the grid interpolation data so we can compare serial and parallel results ---
    if( parameters.saveGridCheckFile )
    {
      
      fPrintF(gridCheckFile," =================== Interpolation data for level %i =================\n",level);
      for( int grid=0; grid<cg1.numberOfComponentGrids(); grid++ )
      {
	const int ni = cg1.numberOfInterpolationPoints(grid);
	fPrintF(gridCheckFile," level=%i, grid=%i, numberOfInterpolationPoints=%i\n",
		level,grid,ni);

	if( ni==0 ) continue;

        // save interp data
        #ifdef USE_PPP
         intSerialArray & interpoleeGrid1             = cg1->interpoleeGridLocal[grid]; 
         intSerialArray & interpolationPoint1         = cg1->interpolationPointLocal[grid];
         intSerialArray & interpoleeLocation1         = cg1->interpoleeLocationLocal[grid];
         intSerialArray & variableInterpolationWidth1 = cg1->variableInterpolationWidthLocal[grid];
         realSerialArray & interpolationCoordinates1  = cg1->interpolationCoordinatesLocal[grid];

	 // gather interp data to myid=0 so we can output
         const int destProc=0;
  	 intSerialArray ip,il;
         realSerialArray ci;
         Iv[0]=interpolationPoint1.dimension(0);
         Iv[1]=Range(numberOfDimensions);
	 // if( gridCheckFile!=NULL )
         //  ::display(interpolationPoint1,"interpolationPoint1",gridCheckFile);
	 CopyArray::getAggregateArray( interpolationPoint1, Iv, ip, destProc );
	 CopyArray::getAggregateArray( interpoleeLocation1, Iv, il, destProc );
	 CopyArray::getAggregateArray( interpolationCoordinates1, Iv, ci, destProc );
         intSerialArray ig,viw;
	 Iv[1]=Range(0,0);
         CopyArray::getAggregateArray( interpoleeGrid1, Iv, ig, destProc );
         CopyArray::getAggregateArray( variableInterpolationWidth1, Iv, viw, destProc );

        #else
         const intArray & ig  = cg1.interpoleeGrid[grid]; 
         const intArray & ip  = cg1.interpolationPoint[grid];
	 const intArray & il  = cg1.interpoleeLocation[grid];
         const intArray & viw = cg1.variableInterpolationWidth[grid];
         const realArray & ci = cg1.interpolationCoordinates[grid];
        #endif  

        // We sort into ascending order of ip(i,0) and secondarily in ascending order of ip(i,1)
        const int nip=ip.getLength(0);
	IntegerArray perm(ip.dimension(0));
	perm.seqAdd(0,1);

	if( numberOfDimensions==2 )
	{
	  SortCmp2d cmp(ip); // this class knows how to compare two elements of ip in 2D
	  std::sort( &perm(perm.getBase(0)),&perm(perm.getBase(0))+nip, cmp );
	}
	else
	{
	  SortCmp3d cmp(ip); // this class knows how to compare two elements of ip in 3D
	  std::sort( &perm(perm.getBase(0)),&perm(perm.getBase(0))+nip, cmp );
	}
	
	for( int j=ip.getBase(0); j<=ip.getBound(0); j++ )
	{
          int i=perm(j);
	  fPrintF(gridCheckFile," i=%i, ip=(%i,%i,%i) il=(%i,%i,%i) donor=%i viw=%i ci=(%5.2f,%5.2f,%5.2f)\n",
                 j,
		  ip(i,0),ip(i,1),(numberOfDimensions==2? 0 : ip(i,2)),
		  il(i,0),il(i,1),(numberOfDimensions==2? 0 : il(i,2)),ig(i),viw(i),
                  ci(i,0),ci(i,1),(numberOfDimensions==2? 0 : ci(i,2)));
	}

      } // end for grid
    } 

    if( false )
    {
      fflush(pDebugFile);
      OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
    }

    if( debugb & 16 && ps!=NULL )
    {
      ps->erase();
      PlotIt::plot(*ps,mgcg);
      PlotIt::plot(*ps,cg1);
    }
    
    
  } // end for l 
  // ----------------------------------------------------------------------------------------------
  // ------------------------------- END LOOP OVER LEVELS -----------------------------------------
  // ----------------------------------------------------------------------------------------------

  
  if( false )
  {
    fflush(pDebugFile);
    OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
  }
      
  // -- fill in the interpolation data in the main CompositeGrid ---
  if( newWay )
  {
    for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
    {
      Range Rl = Rg + mgcg.numberOfComponentGrids()*l;
      mgcg.numberOfInterpolationPoints(Rl)=mgcg.multigridLevel[l].numberOfInterpolationPoints(Rg);
    }
      // for( int l=1; l<mgcg.numberOfMultigridLevels(); l++ )
    for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
    {
      CompositeGrid & cgl = mgcg.multigridLevel[l];
      int gridl=l*mgcg.numberOfComponentGrids();
      for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
      {
        #ifdef USE_PPP
 	 mgcg->numberOfInterpolationPointsLocal(gridl)=cgl->numberOfInterpolationPointsLocal(grid);
	 mgcg->interpolationPointLocal[gridl].reference(cgl->interpolationPointLocal[grid]);
	 mgcg->interpoleeGridLocal[gridl].reference(cgl->interpoleeGridLocal[grid]);
	 mgcg->interpoleeLocationLocal[gridl].reference(cgl->interpoleeLocationLocal[grid]);
	 mgcg->variableInterpolationWidthLocal[gridl].reference(cgl->variableInterpolationWidthLocal[grid]);
	 mgcg->interpolationCoordinatesLocal[gridl].reference(cgl->interpolationCoordinatesLocal[grid]);

         if( false && debug & 2 )
	 {
           realSerialArray & ci = mgcg->interpolationCoordinatesLocal[gridl];
           printF(" level=%i grid=%i gridl=%i niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
		  mgcg->numberOfInterpolationPointsLocal(gridl),
                  ci.getBase(0),ci.getBound(0));
	  realSerialArray & cil= cgl->interpolationCoordinatesLocal[grid];
	  printF(" level=%i grid=%i gridl=%i cgl: niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
		 cgl->numberOfInterpolationPointsLocal(grid),
		 cil.getBase(0),ci.getBound(0));
	 }
	 

        #else
	 mgcg->interpolationPoint[gridl].reference(cgl->interpolationPoint[grid]);
	 mgcg->interpoleeGrid[gridl].reference(cgl->interpoleeGrid[grid]);
	 mgcg->interpoleeLocation[gridl].reference(cgl->interpoleeLocation[grid]);
	 mgcg->variableInterpolationWidth[gridl].reference(cgl->variableInterpolationWidth[grid]);
	 mgcg->interpolationCoordinates[gridl].reference(cgl->interpolationCoordinates[grid]);
        #endif
        gridl++;
      }

      for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
      {
	for( int grid2=0; grid2<cgl.numberOfComponentGrids(); grid2++ )
	{
	  int g=grid+l*mgcg.numberOfComponentGrids();
	  int g2=grid2+l*mgcg.numberOfComponentGrids();
	  mgcg.interpolationStartEndIndex(Range(0,2),g,g2)=cgl.interpolationStartEndIndex(Range(0,2),grid,grid2);

          // not used? : mgcg->interpolationStartEndIndexLocal(Range(0,2),g,g2)=cgl->interpolationStartEndIndexLocal(Range(0,2),grid,grid2);
	}
      }
      
    }
    mgcg.updateReferences();
    
    if( false && debug & 2 )
    {
      for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
      {
	CompositeGrid & cgl = mgcg.multigridLevel[l];
	int gridl=l*mgcg.numberOfComponentGrids();
	for( int grid=0; grid<cgl.numberOfComponentGrids(); grid++ )
	{
	  realSerialArray & ci = mgcg->interpolationCoordinatesLocal[gridl];
	  printF("AFTER updateRef's :  level=%i grid=%i gridl=%i mgcg: niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
		 mgcg->numberOfInterpolationPointsLocal(gridl),
		 ci.getBase(0),ci.getBound(0));
	  realSerialArray & cil= cgl->interpolationCoordinatesLocal[grid];
	  printF("AFTER updateRef's :  level=%i grid=%i gridl=%i cgl: niLocal=%i ci=[%i,%i]\n",l,grid,gridl,
		 cgl->numberOfInterpolationPointsLocal(grid),
		 cil.getBase(0),ci.getBound(0));
          
	}
      }
    }
    

    // Tell the CompositeGrid that the interpolation data have been computed:
    mgcg->computedGeometry |=
      CompositeGrid::THEmask                     |
      CompositeGrid::THEinterpolationCoordinates |
      CompositeGrid::THEinterpolationPoint       |
      CompositeGrid::THEinterpoleeLocation       |
      CompositeGrid::THEinterpoleeGrid;

    // ::display(mgcg.numberOfInterpolationPoints,"buildExtra: mgcg.numberOfInterpolationPoints");    
    
  }
  
  
  delete [] pMask1;

  delete [] pGridIndexRange0;
  // delete [] pDimension0;
  // delete [] pExtendedIndexRange0;
  // delete [] pIndexRange0;
  delete [] pBoundaryCondition0;

  delete [] pGridIndexRange1;
  delete [] pDimension1;
  delete [] pExtendedIndexRange1;
  // delete [] pIndexRange1;
  delete [] pBoundaryCondition1;

//   for( int l=0; l<mgcg.numberOfMultigridLevels(); l++ )
//   {
//     mgcg.multigridLevel[l]->computedGeometry |=
//       CompositeGrid::THEmask                     |
//       CompositeGrid::THEinterpolationCoordinates |
//       CompositeGrid::THEinterpolationPoint       |
//       CompositeGrid::THEinterpoleeLocation       |
//       CompositeGrid::THEinterpoleeGrid;
//   }
  

  delete [] iaA; // *wdh* added 040820
  delete [] interpoleeGridA;
  delete [] interpolationPointA;
  delete [] interpoleeLocationA;
  delete [] variableInterpolationWidthA;
  delete [] interpolationCoordinatesA;

//   for( l=level0; l<level0+numberOfExtraLevels; l++ )
//   {
//     mgcg.multigridLevel[level]->computedGeometry |=
//       CompositeGrid::THEmask                     |
//       CompositeGrid::THEinterpolationCoordinates |
//       CompositeGrid::THEinterpolationPoint       |
//       CompositeGrid::THEinterpoleeLocation       |
//       CompositeGrid::THEinterpoleeGrid;
//   }

  // printF(" **** debug=%i, debug & 1 = %i,  debug & 2 = %i,  debug & 4 = %i \n",debug,debug&1,debug&2,debug&4);
  
  if( debugb & 4 )
  {
    // -- check the grids ---

    Ogen ogen;
    int levelStart=1;  // 0 -- no need to check level 0 ?
    for( l=levelStart; l<mgcg.numberOfMultigridLevels(); l++ )
    {
      // Note: there is probably no need to check l==0 
      // Note: in parallel, explicit interpolation on l==0 requires extra parallel ghost for
      //       check CanInterpolate (2nd-order -> 2 ghost)
      int level=l;
      // Note: checkOverlappingGrid will check all levels.
      // CompositeGrid & cg0 = l==0 ? mgcg : mgcg.multigridLevel[l];
      CompositeGrid & cg0 = mgcg.multigridLevel[l];
      printF("--> checkOverlappingGrid: level %i...\n",level);
      int option=0;
      if( debug & 2 ) option=3;
      int rt=checkOverlappingGrid(cg0,option);
      if( rt==0 )
        printF("... level %i is OK\n",l);
      else
        printF("... level %i is NOT OK ****ERROR****\n",l);

      // int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];
      // Index Iv[3], &I1=Iv[0], &I2=Iv[1], &I3=Iv[2];
      int numErrors=0;
      IntegerArray errorsPerGrid(cg0.numberOfComponentGrids());
      errorsPerGrid=0;
      const bool checkOneSidedAtBoundaries=false;
      for( int grid=0; grid<cg0.numberOfComponentGrids(); grid++ )
      {
        // printF(" check: level=%i grid=%i numberOfInterpolationPoints=%i\n",
        //        l,grid,cg0.numberOfInterpolationPoints(grid));
	
	MappedGrid & mg = cg0[grid];
        const intArray & maskg = mg.mask();
        #ifdef USE_PPP
         intSerialArray mask; getLocalArrayWithGhostBoundaries(maskg,mask);
        #else
         const intSerialArray & mask = maskg;
        #endif

	getIndex(mg.gridIndexRange(),I1,I2,I3);
        int includeGhost=0;  // no parallel ghost
        bool ok = ParallelUtility::getLocalArrayBounds(maskg,mask,I1,I2,I3,includeGhost);

	if( ok )
	{
	  FOR_3D(i1,i2,i3,I1,I2,I3)
	  {
	    if( mask(i1,i2,i3)>0 )
	    {
	      if( !ogen.canDiscretize( mg,iv,checkOneSidedAtBoundaries ) ) // Note: iv==(i1,i2,i3)
	      {
		numErrors++;
		errorsPerGrid(grid)++;
		printf("buildExtraLevels:ERROR: myid=%i level=%i grid=%i Discretization pt (%i,%i,%i) cannot be discretized\n",
		       myid,l,grid,i1,i2,i3);
		fprintf(pDebugFile,"buildExtraLevels:ERROR: myid=%i level=%i grid=%i Discretization pt (%i,%i,%i) cannot be discretized\n",
			myid,l,grid,i1,i2,i3);

		Range J1(i1-1,i1+1),J2(i2-1,i2+1),J3(i3-1,i3+1);
		if( numberOfDimensions==2 )
		  J3=Range(i3,i3);

		displayMask(mask(J1,J2,J3),"mask near i1,i2,i3",pDebugFile);
	      
	      }
	    }
	  }
	}
	
        //
        // Now we need to check that there are no discretization points in the ghost point region of
        // interpolation boundaries. (This is a mistake that can be made in the above algorithm)
        const IntegerArray & gir = mg.gridIndexRange();
        I3=gir(0,2);
        const int numGhostLines=orderOfAccuracy/2; // check this many ghost lines
	for( int axis=0; axis<cg0.numberOfDimensions(); axis++ )
	{
	  for( int dir=0; dir<cg0.numberOfDimensions(); dir++ )
	  {
	    if( dir!=axis )
	    {
	      int na=gir(0,dir);
	      int nb=gir(1,dir);
              // check adjacent ghost lines (thus corners) if the adjacent boundary is interpolation
	      if( mg.boundaryCondition(0,dir)==0 ) na-=numGhostLines;
	      if( mg.boundaryCondition(1,dir)==0 ) nb+=numGhostLines;
	      Iv[dir]=Range(na,nb);
	    }
	  }
	  for( int side=0; side<=1; side++ )
	  {
            if( mg.boundaryCondition(side,axis)==0 )
	    {
	      const int is=1-2*side;
	      const int ghost=1;
	      // check "numGhostLines" different ghost lines :

	      Iv[axis]=Range(mg.gridIndexRange(side,axis)-is,mg.gridIndexRange(side,axis)-is*numGhostLines);
              bool ok = ParallelUtility::getLocalArrayBounds(maskg,mask,I1,I2,I3,includeGhost);
	      if( !ok ) continue;
	      FOR_3(i1,i2,i3,I1,I2,I3)
	      {
		if( mask(i1,i2,i3)>0 )
		{
		  numErrors++;
  	          errorsPerGrid(grid)++;
		  printf("ERROR: level=%i, grid=%i, ghost point (%i,%i,%i) (side,axis)=(%i,%i) mask=%i, "
                         "is a discretization pt!\n", l,grid,i1,i2,i3,side,axis,mask(i1,i2,i3));
		  fprintf(pDebugFile,"ERROR: level=%i, grid=%i, ghost point (%i,%i,%i) (side,axis)=(%i,%i) mask=%i, "
                         "is a discretization pt!\n", l,grid,i1,i2,i3,side,axis,mask(i1,i2,i3));
		}
	      }
	    }
	  }
	}
      }
      numErrors=ParallelUtility::getSum(numErrors);
      if( numErrors>0 )
      {
	printF("$$$$ check points on level %i **ERROR** there were %i invalid points.\n",
	       l,numErrors);
	
	OV_ABORT("ERROR");
      }
      else
      {
	printF("$$$$ check points on level %i **PASSED***\n",l);
      }

    }
  }
  

  if( (debugb & 8) && level0==0 && ( mgcg.numberOfInterpolationPoints(0)>0)  )
  {
    // now test out the validity of the newly created levels.

    for( l=level0; l<level0+numberOfExtraLevels; l++ )
    {
      level=l+1;
      
      printF("\n\n **************** check extra level %i ******************* \n\n",level);

      // Check the validity of a grid by solving an elliptic problem on it.
      checkGrid( mgcg.multigridLevel[level],ps,debugb );
      
    }

    // exit(0);
  }
  
  if( false )
  {
   mgcg.interpolationStartEndIndex.display("buildExtraLevels: END:mgcg.interpolationStartEndIndex");
   mgcg.multigridLevel[0].interpolationStartEndIndex.display("buildExtraLevels:END: mgcg.multigridLevel[0].interpolationStartEndIndex");
  }
  
  if( gridCheckFile!=NULL )
  {
    fflush(gridCheckFile);
  }

  tm[timeForBuildExtraLevels]+=getCPU()-time0;
  if( debugb & 4 )
    printF(" ****tm[timeForBuildExtraLevels]=%8.2e buildMask=%8.2e buildInterp=%8.2e validStencil=%8.2e ****\n",
           tm[timeForBuildExtraLevels],timeForBuildMask,timeForBuildInterpolation,timeForValidStencil);
  
  if( false )
  {
    fflush(pDebugFile);
    OV_ABORT("Ogmg:buildExtraLevelsNew: stop here for now");
  }


  debug=debugSave;

  return 0;
}



int Ogmg::
getInterpolationCoordinates( CompositeGrid & cg0, // finer grid
                             CompositeGrid & cg1, // new coarser grid
                             const IntegerArray & ib,     // check these points...
			     const int grid,            // ..on this grid
                             const IntegerArray & gridsToCheck, // ..from these grids
                             realSerialArray & rb,      // return these values
                             const bool isRectangular,
                             int iv0[3], real dx0[3], real xab0[2][3],   // these are used by Macros!
                             int iv1[3], real dx1[3], real xab1[2][3],
                             InterpolationData & ipd )
// ==================================================================================================
// /Description: ** new version that does many points at a time
//     Given a new interpolation point on a coarse grid, determine the r coordinates on the 
//   interpolee grid. 
//
// /ib (input) : ib(i,4) : (i,j1,j2,j3) 
// ==================================================================================================
{
  const int numberOfDimensions=cg0.numberOfDimensions();


  #ifdef USE_PPP
    intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
    intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
    realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
  #else
    const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
    const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
    const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
  #endif    


  // const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
  // const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
  const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
  const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);

  const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;

  // const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
  const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
  const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);

  MappedGrid & mg0 = cg0[grid];
  MappedGrid & mg1 = cg1[grid];
  #ifdef USE_PPP
    realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
    realSerialArray center0; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg0.center(),center0);
  #else
    const realArray & center = mg1.center();
    const realArray & center0 = mg0.center();
  #endif


  real *center0p;  
  int center0Dim0,center0Dim1,center0Dim2;
  real *centerp;
  int centerDim0,centerDim1,centerDim2;
  if( !isRectangular )
  {
    centerp = center.Array_Descriptor.Array_View_Pointer3;
    centerDim0=center.getRawDataSize(0);
    centerDim1=center.getRawDataSize(1);
    centerDim2=center.getRawDataSize(2);

    center0p = center0.Array_Descriptor.Array_View_Pointer3;
    center0Dim0=center0.getRawDataSize(0);
    center0Dim1=center0.getRawDataSize(1);
    center0Dim2=center0.getRawDataSize(2);

  }
#define CENTER0(i0,i1,i2,i3) center0p[i0+center0Dim0*(i1+center0Dim1*(i2+center0Dim2*(i3)))]	
      
  const int maxNumToInterp = ib.getLength(0);
  if( maxNumToInterp==0 ) return 0;

  realSerialArray x(maxNumToInterp,3), r(maxNumToInterp,3);
  IntegerArray ia(maxNumToInterp);
  
  real *xp = x.Array_Descriptor.Array_View_Pointer1;
  const int xDim0=x.getRawDataSize(0);
  real *rp = r.Array_Descriptor.Array_View_Pointer1;
  const int rDim0=r.getRawDataSize(0);

  int *iap = ia.Array_Descriptor.Array_View_Pointer0;
#undef IA
#define IA(i0) iap[i0]

  real *rbp = rb.Array_Descriptor.Array_View_Pointer1;
  const int rbDim0=rb.getRawDataSize(0);
#define RB(i0,i1) rbp[i0+rbDim0*(i1)]

  int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
  const int ibDim0=ib.getRawDataSize(0);

  int ii,axis;
  int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
  int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
  int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
  
#ifdef USE_PPP
  // -- parallel case : we cannot rely on being able to evaluate the center array -- 
  //    We evaluate the mapping instead 
  RealArray xc;
  real *xcp=NULL; // set below 
  int xcDim0;
  if( !isRectangular )
  {
    RealArray rc;
    if( maxNumToInterp>0 )
    {
      rc.redim(maxNumToInterp,numberOfDimensions);
      xc.redim(maxNumToInterp,numberOfDimensions);
    }
    real *rcp = rc.Array_Descriptor.Array_View_Pointer1;
    const int rcDim0=rc.getRawDataSize(0);
#define RC(i0,i1) rcp[i0+rcDim0*(i1)]
    xcp = xc.Array_Descriptor.Array_View_Pointer1;
    xcDim0=xc.getRawDataSize(0);
#define XC(i0,i1) xcp[i0+xcDim0*(i1)]
    
    const IntegerArray & gid1 = mg1.gridIndexRange();
    const RealArray & dr1 = mg1.gridSpacing();
    for( int i=0; i<maxNumToInterp; i++ )
    {
      for( int axis=0; axis<numberOfDimensions; axis++ )
	RC(i,axis)= (IB(i,axis+1)-gid1(0,axis))*dr1(axis);   // r-coordinates of the point 
    }

    Mapping & map1 = mg1.mapping().getMapping();
    map1.mapS(rc,xc);

  }
#endif   


  for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
  {
    if( gridsToCheck(grid2)==0 ) continue;  // no need to check this grid

    // collect up all new interpolation points that interpolate from grid2
    int jb=0;
    if( isRectangular )
    {
      if( numberOfDimensions==2 )
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
          ii=IB(i,0);  // index into orginal interpolation point arrays
	  if( ig0(ii)==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;  // save i
	    X(jb,0)=CENTER10(j1,j2,j3);
	    X(jb,1)=CENTER11(j1,j2,j3);
	    R(jb,0)=ci0(ii,0);
	    R(jb,1)=ci0(ii,1);
	    R(jb,2)=0.;
	    jb++;
	  }
      
	}
      }
      else
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
          ii=IB(i,0);  // index into orginal interpolation point arrays
	  if( ig0(ii)==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;
	    X(jb,0)=CENTER10(j1,j2,j3);
	    X(jb,1)=CENTER11(j1,j2,j3);
	    X(jb,2)=CENTER12(j1,j2,j3);
	    R(jb,0)=ci0(ii,0);
	    R(jb,1)=ci0(ii,1);
	    R(jb,2)=ci0(ii,2);
	    jb++;
	  }
	}
      }
    }
    else
    { 
      // curvilinear case 
      if( numberOfDimensions==2 )
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
          ii=IB(i,0);  // index into orginal interpolation point arrays
	  if( ig0(ii)==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;
            #ifndef USE_PPP
  	      X(jb,0)=CENTER(j1,j2,j3,0);
	      X(jb,1)=CENTER(j1,j2,j3,1);
            #else
  	      X(jb,0)=XC(i,0);
	      X(jb,1)=XC(i,1);
            #endif
	    R(jb,0)=ci0(ii,0);
	    R(jb,1)=ci0(ii,1);
	    R(jb,2)=0.;
	    jb++;
	  }
	}
      }
      else
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
          ii=IB(i,0);  // index into orginal interpolation point arrays
	  if( ig0(ii)==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;
            #ifndef USE_PPP
	      X(jb,0)=CENTER(j1,j2,j3,0);
	      X(jb,1)=CENTER(j1,j2,j3,1);
	      X(jb,2)=CENTER(j1,j2,j3,2);
            #else
  	      X(jb,0)=XC(i,0);
	      X(jb,1)=XC(i,1);
	      X(jb,2)=XC(i,2);
            #endif
	    R(jb,0)=ci0(ii,0);
	    R(jb,1)=ci0(ii,1);
	    R(jb,2)=ci0(ii,2);
	    jb++;
	  }
	}
      }
    } // end curvilinear 
    
    const int numToInterp=jb;
    if( numToInterp==0 ) continue;  // **** no points to interpolate   -------------- fix me parallel ----------
    
    // printF(" grid=%i : interpolate %i extra points from grid2=%i\n",grid,numToInterp,grid2);

    MappedGrid & g2 = cg1[grid2];
    const IntegerArray & extended = g2.extendedIndexRange(); 
    const realArray & center2 = g2.center();

    const bool g2IsRectangular=g2.isRectangular();
    real dx2[3], xra[3][3];
    if( g2IsRectangular )
    {
      g2.getDeltaX(dx2);
    }
    const real offset = parameters.allowExtrapolationOfInterpolationPoints ? 1. : 0.; // *wdh* 040903
    real rMin[3], rMax[3];
    for( axis=0; axis<numberOfDimensions; axis++ )
    {
      // normally limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
      // from the last interpolation point.
      const real dr = g2.gridSpacing(axis);
      rMin[axis] = g2.boundaryCondition(Start,axis)!=0  ? -dr*offset :
	                                                  (extended(Start,axis)+.25)*dr; // move in .25*Dr from the end
      rMax[axis] = g2.boundaryCondition(End  ,axis)!=0  ? 1.+dr*offset :(extended(End,  axis)-.25)*dr;
    }
      
    Range R=numToInterp, Rx=numberOfDimensions;
    
    // invert mapping to get coordinates of the new interpolation pt.
    Mapping & map2 = g2.mapping().getMapping();
    map2.useRobustInverse(true);
    r=-1.;
    #ifdef USE_PPP
      map2.inverseMapS(x(R,Rx),r);  // ** here is the expensive part **
    #else
      map2.inverseMap(x(R,Rx),r);  // ** here is the expensive part **
    #endif

    real dx[3], dr[3];
    real dr2[3]={g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2)}; //
    realSerialArray xx(1,3), rr(1,3);
    for( jb=0; jb<numToInterp; jb++ )
    {
      const int i=IA(jb);
      if( max(fabs(R(jb,0)),fabs(R(jb,1)),fabs(R(jb,2))) > 5. )
      {
	// pt was not invertible -- estimate it's inverse location

        const int ii=IB(i,0);
	
  	for( axis=0; axis<numberOfDimensions; axis++ )   // *wdh* 021203
  	  R(jb,axis)=ci0(ii,axis);	


	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
        int i1=ip0(ii,0), i2=ip0(ii,1);
        int i3=numberOfDimensions==2 ? 0 : ip0(ii,2);
        int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
	if( isRectangular )
	{
	  dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
	  dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
	  dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);

	}
	else
	{
	  for( axis=0; axis<numberOfDimensions; axis++ )
	    dx[axis]=CENTER(j1,j2,j3,axis)-CENTER0(i1,i2,i3,axis);
	}
	if( g2IsRectangular )
	{
	  dr[0]=dx[0]/dx2[0]*dr2[0];
	  dr[1]=dx[1]/dx2[1]*dr2[1];
	  dr[2]=dx[2]/dx2[2]*dr2[2];
	}    
	else
	{

	  Mapping & map2 = g2.mapping().getMapping();
	  rr=-1.;
	  xx(0,Rx)=x(jb,Rx);
          #ifdef USE_PPP
	    OV_ABORT("Ogmg::getInterpolationCoordinates:ERROR: finish this");
  	  #else
  	    map2.approximateGlobalInverse->findNearestGridPoint(0,0,xx,rr);
          #endif

          if( debug & 4 )
	    printF(" Ogmg:non-invertible pt: map2.usingRobustInverse()=%i, nearest: rr=(%8.2e,%8.2e,%8.2e)"
		   " -> i=(%i,%i,%i)\n",
		   (int)map2.usingRobustInverse(),rr(0,0),rr(0,1),rr(0,2),
		   int(rr(0,0)/g2.gridSpacing(0)),int(rr(0,1)/g2.gridSpacing(1)),int(rr(0,2)/g2.gridSpacing(2)));


	  // kv=(k1,k2,k3) = closest point on grid2 (use dr/dx from near this point)
                 
	  k3=g2.dimension(Start,axis3);
	  for( axis=0; axis<numberOfDimensions; axis++ )
	  {
	    // dx[axis]=center(j1,j2,j3,axis)-center0(i1,i2,i3,axis);
	    kv[axis]=int( R(jb,axis)/g2.gridSpacing(axis) + g2.indexRange(0,axis) );
	    kpv[axis]=kv[axis]+1;
	    if( kpv[axis] > g2.dimension(End,axis) )
	    {
	      kpv[axis]=kv[axis]-1;
	      assert( kpv[axis] >= g2.dimension(Start,axis) );
	    }
	  }


#define XR(m,n) xra[n][m]
	  int ax;
	  if( numberOfDimensions==2 )
	  {
	    // estimate (dx/dr) on grid 2 by differences (to avoid building xr)
	    for(ax=0; ax<numberOfDimensions; ax++ ) 
	    {
	      xra[0][ax]=(kp1-k1)*(center2(kp1,k2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(0);
	      xra[1][ax]=(kp2-k2)*(center2(k1,kp2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(1);
	    }
	    real det = XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0);
	    if( det!=0. )
	    {
	      det=1./det;
	      dr[0]=(  XR(1,1)*dx[0]-XR(0,1)*dx[1] )*det;
	      dr[1]=( -XR(1,0)*dx[0]+XR(0,0)*dx[1] )*det;
	    }
	    else
	    { // if the jacobian is singular
	      if( debug & 1 )
	      {
		printf("Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n");
	      }
	      dr[0]=dr[1]=0.;
	    }
	    dr[2]=0.;
            if( debug & 4 )
  	      printF("Ogmg:buildExtraLevels: non-invertible pt, dr from diff.: dx=(%e,%e) r=(%e,%e) dr=(%e,%e) \n",
		     dx[0],dx[1],r(0,0),r(0,1),dr[0],dr[1]);
	  }
	  else
	  {
	    for(ax=0; ax<numberOfDimensions; ax++ ) 
	    {
	      xra[0][ax]=(kp1-k1)*(center2(kp1,k2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(0);  // opt these *****
	      xra[1][ax]=(kp2-k2)*(center2(k1,kp2,k3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(1);
	      xra[2][ax]=(kp3-k3)*(center2(k1,k2,kp3,ax)-center2(k1,k2,k3,ax))/g2.gridSpacing(2);
	    }
	    real det =((XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0))*XR(2,2) +
		       (XR(0,1)*XR(1,2)-XR(0,2)*XR(1,1))*XR(2,0) +
		       (XR(0,2)*XR(1,0)-XR(0,0)*XR(1,2))*XR(2,1));
	    if( det!=0. )
	    {
	      det=1./det;
	      dr[0]=( (XR(1,1)*XR(2,2)-XR(2,1)*XR(1,2))*dx[0]+
		      (XR(2,1)*XR(0,2)-XR(0,1)*XR(2,2))*dx[1]+
		      (XR(0,1)*XR(1,2)-XR(1,1)*XR(0,2))*dx[2] )*det;
		      
	      dr[1]=( (XR(1,2)*XR(2,0)-XR(2,2)*XR(1,0))*dx[0]+
		      (XR(2,2)*XR(0,0)-XR(0,2)*XR(2,0))*dx[1]+
		      (XR(0,2)*XR(1,0)-XR(1,2)*XR(0,0))*dx[2] )*det;
		      
	      dr[2]=( (XR(1,0)*XR(2,1)-XR(2,0)*XR(1,1))*dx[0]+
		      (XR(2,0)*XR(0,1)-XR(0,0)*XR(2,1))*dx[1]+
		      (XR(0,0)*XR(1,1)-XR(1,0)*XR(0,1))*dx[2] )*det;

              if( debug & 4 )
              printF(" Ogmg:non-invertible pt: interp=(%i,%i,%i) j=(%i,%i,%i) R(jb=%i,.)=(%8.2e,%8.2e,%8.2e) \n"
                     "       x=(%8.2e,%8.2e,%8.2e) kv=[%i,%i,%i] kpv=[%i,%i,%i]\n"
                     "       dx=(%8.2e,%8.2e,%8.2e) dr=(%8.2e,%8.2e,%8.2e) gridSpacing=(%8.2e,%8.2e,%8.2e)\n"
                     " xr(.,0)=(%8.2e,%8.2e,%8.2e) \n"
                     " xr(.,1)=(%8.2e,%8.2e,%8.2e)\n"
                     " xr(.,2)=(%8.2e,%8.2e,%8.2e) \n",
		     i1,i2,i3,j1,j2,j3,jb,R(jb,0),R(jb,1),R(jb,2),x(jb,0),x(jb,1),x(jb,2),
                     k1,k2,k3,kp1,kp2,kp3,
                     dx[0],dx[1],dx[2],dr[0],dr[1],dr[2],
                     g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2),
                     XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));  
	      
              for(ax=0; ax<numberOfDimensions; ax++ )
	      {
                dr[ax]=min(g2.gridSpacing(ax),max(-g2.gridSpacing(ax),dr[ax]));
	      }
	      
	    }
	    else
	    { // if the jacobian is singular
	      if( debug & 1 )
		printf("Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n"
                       " grid=%i, grid2=%i : kv=[%i,%i,%i] kpv=[%i,%i,%i] \n"
                       " center2(kv) = (%8.2e,%8.2e,%8.2e) center2(kpv)=(%8.2e,%8.2e,%8.2e) \n"
                       " xra[.][0]=(%8.2e,%8.2e,%8.2e) \n"
                       " xra[.][1]=(%8.2e,%8.2e,%8.2e)\n"
                       " xra[.][2]=(%8.2e,%8.2e,%8.2e) \n",grid,grid2,
                       k1,k2,k3,kp1,kp2,kp3,center2(k1,k2,k3,0),center2(k1,k2,k3,1),center2(k1,k2,k3,2),
                       center2(kp1,k2,k3,0),center2(k1,kp2,k3,1),center2(k1,k2,kp3,2),
                       XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));
	      dr[0]=dr[1]=dr[2]=0.;
	    }
	  }
	}
#undef XR
		    
	for( axis=0; axis<numberOfDimensions; axis++ )
	{
	  R(jb,axis)+=dr[axis];
	}
      }  // end if point not invertible
    
      for( axis=0; axis<numberOfDimensions; axis++ )
      {
	// limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	// from the last interpolation point.
	RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
      }

    } // end for jb
  }  // end for grid2


  return 0;
}

int Ogmg::
getInterpolationCoordinatesNewOld( CompositeGrid & cg0, // finer grid
				CompositeGrid & cg1, // new coarser grid
				const IntegerArray & ib,     // check these points...
                                const RealArray & xa,        // with these x-coordinates 
				const int grid,            // ..on this grid
				const IntegerArray & gridsToCheck, // ..from these grids
				realSerialArray & rb,      // return these values
				const bool isRectangular,
				int iv0[3], real dx0[3], real xab0[2][3],   // these are used by Macros!
				int iv1[3], real dx1[3], real xab1[2][3],
				InterpolationData & ipd )
// ==================================================================================================
// /Description: ** Old "new" version that does many points at a time
//     Given a new interpolation point on a coarse grid, determine the r coordinates on the 
//   interpolee grid. 
//
// /ib (input) : ib(i,4) : (i,j1,j2,j3) 
// ==================================================================================================
{
  const bool checkForNans=false;  // for testing turn this on to check for nans

  CompositeGrid & mgcg = multigridCompositeGrid();
  const int numberOfDimensions=cg0.numberOfDimensions();
  const int numberOfComponentGrids = cg0.numberOfComponentGrids();

  #ifdef USE_PPP
    intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
    intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
    realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
  #else
    const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
    const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
    const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
  #endif    


  // const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
  // const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
  const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
  const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);

  const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;

  // const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
  const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
  const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);

  MappedGrid & mg0 = cg0[grid];
  MappedGrid & mg1 = cg1[grid];
  const IntegerArray & gid0 = mg0.gridIndexRange();
  const IntegerArray & gid1 = mg1.gridIndexRange();
  
  #ifdef USE_PPP
    realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
    realSerialArray center0; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg0.center(),center0);
  #else
    const realArray & center = mg1.center();
    const realArray & center0 = mg0.center();
  #endif


  const real *xap = xa.Array_Descriptor.Array_View_Pointer1;
  const int xaDim0=xa.getRawDataSize(0);
#define XA(i0,i1) xap[i0+xaDim0*(i1)]


  real *center0p;  
  int center0Dim0,center0Dim1,center0Dim2;
  real *centerp;
  int centerDim0,centerDim1,centerDim2;
  if( !isRectangular )
  {
    centerp = center.Array_Descriptor.Array_View_Pointer3;
    centerDim0=center.getRawDataSize(0);
    centerDim1=center.getRawDataSize(1);
    centerDim2=center.getRawDataSize(2);

    center0p = center0.Array_Descriptor.Array_View_Pointer3;
    center0Dim0=center0.getRawDataSize(0);
    center0Dim1=center0.getRawDataSize(1);
    center0Dim2=center0.getRawDataSize(2);

  }
#define CENTER0(i0,i1,i2,i3) center0p[i0+center0Dim0*(i1+center0Dim1*(i2+center0Dim2*(i3)))]	
      
  const int maxNumToInterp = ib.getLength(0);
  // if( maxNumToInterp==0 ) return 0;                 // ***************** fix me ***************

  realSerialArray x, r;
  IntegerArray ia;
  if( maxNumToInterp>0 )
    x.redim(maxNumToInterp,3); r.redim(maxNumToInterp,3); ia.redim(maxNumToInterp);
  
  real *xp = x.Array_Descriptor.Array_View_Pointer1;
  const int xDim0=x.getRawDataSize(0);
  real *rp = r.Array_Descriptor.Array_View_Pointer1;
  const int rDim0=r.getRawDataSize(0);

  int *iap = ia.Array_Descriptor.Array_View_Pointer0;
#undef IA
#define IA(i0) iap[i0]

  real *rbp = rb.Array_Descriptor.Array_View_Pointer1;
  const int rbDim0=rb.getRawDataSize(0);
#define RB(i0,i1) rbp[i0+rbDim0*(i1)]

  int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
  const int ibDim0=ib.getRawDataSize(0);

  int level0=0;
  const IntegerArray & coarseningRatio = mgcg.multigridCoarseningRatio(Range(0,2),grid,level0);
  int cf[3], &cf1=cf[0], &cf2=cf[1], &cf3=cf[2];
  cf1=coarseningRatio(axis1);  // coarsening factor
  cf2=coarseningRatio(axis2);
  cf3=coarseningRatio(axis3);  
  assert(cf1==2 && (cf2==2 || numberOfDimensions<2) && (cf3==2 || numberOfDimensions<3));

  const real epsDet=REAL_MIN*1.e5;  // *wdh* 1106012 -- lower bound for det(jacobian)

  int i0,ii,axis;
  int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
  int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
  int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
  
  if( false ) // *wdh* 110613
  {
    fprintf(pDebugFile,"=== Ogmg:getInterpCoordsNew START===\n");
    for( int i=0; i<maxNumToInterp; i++ )
    {
      ii=IB(i,4); 
      int donor = IB(i,5);
      fprintf(pDebugFile,"i=%i ii=%i donor=%i gridsToCheck(donor)=%i x=(%e,%e)\n",i,ii,donor,gridsToCheck(donor),
	      XA(ii,0),XA(ii,1));
    }
  }


  for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
  {
    #ifndef USE_PPP
      if( gridsToCheck(grid2)==0 ) continue;  // no need to check this grid -- in parallel we need to keep going
    #endif

    // collect up all new interpolation points that interpolate from grid2
    int jb=0;
    if( gridsToCheck(grid2)!=0 )
    {
      if( numberOfDimensions==2 )
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
	  ii=IB(i,4);  // index into cid and XA arrays
	  int donor = IB(i,5);
	  assert( donor>=0 && donor<numberOfComponentGrids );
	  if( donor==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;  // save i
	    X(jb,0)=XA(ii,0);
	    X(jb,1)=XA(ii,1);

	    i0=IB(i,0);  // index into original interpolation point arrays
	    if( i0>=0 )
	    {
	      R(jb,0)=ci0(i0,0); // initial guess
	      R(jb,1)=ci0(i0,1);
	      R(jb,2)=0.;
	    }
	    else
	    {
	      R(jb,0)=-1.;
	      R(jb,1)=-1.;
	      R(jb,2)=-1.;
	    }
	    jb++;
	  }
      
	}
      }
      else
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
	  ii=IB(i,4);  
	  int donor = IB(i,5);
	  assert( donor>=0 && donor<numberOfComponentGrids );
	  if( donor==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;
	    X(jb,0)=XA(ii,0);
	    X(jb,1)=XA(ii,1);
	    X(jb,2)=XA(ii,2);
	    i0=IB(i,0);  // index into orginal interpolation point arrays
	    if( i0>=0 )
	    {
	      R(jb,0)=ci0(i0,0);
	      R(jb,1)=ci0(i0,1);
	      R(jb,2)=ci0(i0,2);
	    }
	    else
	    {
	      R(jb,0)=-1.;
	      R(jb,1)=-1.;
	      R(jb,2)=-1.;
	    }
	    jb++;
	  }
	}
      }
    }
    
    const int numToInterp=jb;
    // if( numToInterp==0 ) continue;  // **** no points to interpolate   -------------- fix me parallel ----------
    
    // printF(" grid=%i : interpolate %i extra points from grid2=%i\n",grid,numToInterp,grid2);

    MappedGrid & g2 = cg1[grid2];
    const IntegerArray & extended = g2.extendedIndexRange(); 
    const realArray & center2 = g2.center();

    const bool g2IsRectangular=g2.isRectangular();
    real dx2[3], xra[3][3];
    if( g2IsRectangular )
    {
      g2.getDeltaX(dx2);
    }
    const real offset = parameters.allowExtrapolationOfInterpolationPoints ? 1. : 0.; // *wdh* 040903
    real rMin[3], rMax[3];
    for( axis=0; axis<numberOfDimensions; axis++ )
    {
      // normally limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
      // from the last interpolation point.
      const real dr = g2.gridSpacing(axis);
      rMin[axis] = g2.boundaryCondition(Start,axis)!=0  ? -dr*offset :
	                                                  (extended(Start,axis)+.25)*dr; // move in .25*Dr from the end
      rMax[axis] = g2.boundaryCondition(End  ,axis)!=0  ? 1.+dr*offset :(extended(End,  axis)-.25)*dr;
    }
      
    Range R=numToInterp, Rx=numberOfDimensions;
    
    // invert mapping to get coordinates of the new interpolation pt.
    Mapping & map2 = g2.mapping().getMapping();
    map2.useRobustInverse(true);
    if( numToInterp>0 )
    {
      r=-1.;
      #ifdef USE_PPP
        map2.inverseMapS(x(R,Rx),r);  // ** here is the expensive part **
      #else
        map2.inverseMap(x(R,Rx),r);  // ** here is the expensive part **
      #endif
    }
    else
    {
      // There are no points on this processor to interpolate
      RealArray xNull,rNull;
      #ifdef USE_PPP
        map2.inverseMapS(xNull,rNull);  // ** here is the expensive part **
      #else
        map2.inverseMap(xNull,rNull);  // ** here is the expensive part **
      #endif
    }
    
    real dx[3], dr[3]={0.,0.,0.};
    real dr2[3]={g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2)}; //
    realSerialArray xx(1,3), rr(1,3), xxr(1,3,3);
    for( jb=0; jb<numToInterp; jb++ )
    {
      const int i=IA(jb);  // index into the original ib array

      if( checkForNans )  // *wdh* 2011/06/12 -- for testing check for nan's
      {
	if( R(jb,0)!=R(jb,0) || R(jb,1)!=R(jb,1) || R(jb,2)!=R(jb,2) )
	{
	  if( true )
	  {
	    printf("Ogmg:getInterpCoordsNew: ERROR: r=(%e,%e,%e) nan's ?? map=%s\n",R(jb,0),R(jb,1),R(jb,2),
		   (const char*)map2.getName(Mapping::mappingName));
	  }
	  
	  R(jb,0)=R(jb,1)=R(jb,2)=Mapping::bogus;
	}
      }

      if( max(fabs(R(jb,0)),fabs(R(jb,1)),fabs(R(jb,2))) > 5. )
      {
	// pt was not invertible -- estimate it's inverse location

        int i0=IB(i,0); // note i
	if( i0<0 )
	{
          if( debug & 4 )
	    fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: Unable to invert pt (%i,%i,%i) grid=%i from donor=%i \n",IB(i,1),IB(i,2),IB(i,3),grid,grid2); 

          // find the closest fine grid interp point that also uses this donor
          int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3); // coarse grid point
	  int i1=(j1-gid1(0,0))*cf[0]+gid0(0,0), i2=(j2-gid1(0,1))*cf[1]+gid0(0,1), i3=(j3-gid1(0,2))*cf[2]+gid0(0,2);  // fine grid pt
          int minDist=INT_MAX;
	  for( int k=interpolationPoint0.getBase(0); k<=interpolationPoint0.getBound(0); k++ )
	  {
            int donor=ig0(k);
	    if( donor==grid2 )
	    {
              int dist = abs(i1-ip0(k,0))+abs(i2-ip0(k,1));
	      if( numberOfDimensions==3 ) dist+= abs(i3-ip0(k,2));
	      if( dist<minDist )
	      {
		i0=k;
		minDist=dist;
	      }
	    }
	    
	  }
	  

	  if( i0<0 )
	  {
	    if( debug & 4 )
	    {
	      fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i Unable to invert pt (%i,%i,%i) grid=%i from donor=%i"
		      " R=(%e,%e,%e) \n",i,IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 
	      fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i Unable to find a fine grid interp pt with donor=%i\n",i,grid2);
	    }
	    
	    // OV_ABORT("finish me for this case: IB(i,0)<0");


            // fill in bogus values -- this will force another donor grid to be found.
            // *** we could do better here ***
	    for( axis=0; axis<numberOfDimensions; axis++ )
	    {
	      RB(i,axis)=Mapping::bogus;
	    }
	    continue;
	    
	  }
          else
	  {
            if( debug & 2 )
	      fprintf(pDebugFile," ... use fine grid interp. point i0=%i, (%i,%i,%i)\n",i0,
		      ip0(i0,0),ip0(i0,1),(numberOfDimensions==2 ? 0 : ip0(i0,2)));
	      
	  }
	  
	  
	}
	
	assert( i0>=0 );
	
        // As a first approximation the r coords are the same as the nearby fine grid interp pt,
        // we then improve this below: 
  	for( axis=0; axis<numberOfDimensions; axis++ )   // *wdh* 021203
  	  R(jb,axis)=ci0(i0,axis);	


	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
        int i1=ip0(i0,0), i2=ip0(i0,1);
        int i3=numberOfDimensions==2 ? 0 : ip0(i0,2);
        int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
	if( isRectangular )
	{
	  dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
	  dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
	  dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);

	}
	else
	{
	  for( axis=0; axis<numberOfDimensions; axis++ )
	  {
	    // dx[axis]=CENTER(j1,j2,j3,axis)-CENTER0(i1,i2,i3,axis);
	    dx[axis]=X(jb,axis)-CENTER0(i1,i2,i3,axis);  
	  }
	  
	}
	if( g2IsRectangular )
	{
	  dr[0]=dx[0]/dx2[0]*dr2[0];
	  dr[1]=dx[1]/dx2[1]*dr2[1];
	  dr[2]=dx[2]/dx2[2]*dr2[2];
	}    
	else
	{

          // Evaluate x.r at the nearby interp coord's
	  Mapping & map2 = g2.mapping().getMapping();
          for( axis=0; axis<numberOfDimensions; axis++ )
	    rr(0,axis)=R(jb,axis);

          // *FIX* me: this next could hang in parallel if the forward map is distributed (e.g. DPM)
	  map2.mapS(rr,xx,xxr);
	  
// 	  rr=-1.;
// 	  xx(0,Rx)=x(jb,Rx);
//           #ifdef USE_PPP
// 	    OV_ABORT("Ogmg::getInterpolationCoordinates:ERROR: finish this");
//   	  #else
//   	    map2.approximateGlobalInverse->findNearestGridPoint(0,0,xx,rr);
//           #endif

//           if( debug & 4 )
// 	    printF(" Ogmg:non-invertible pt: map2.usingRobustInverse()=%i, nearest: rr=(%8.2e,%8.2e,%8.2e)"
// 		   " -> i=(%i,%i,%i)\n",
// 		   (int)map2.usingRobustInverse(),rr(0,0),rr(0,1),rr(0,2),
// 		   int(rr(0,0)/g2.gridSpacing(0)),int(rr(0,1)/g2.gridSpacing(1)),int(rr(0,2)/g2.gridSpacing(2)));


#define XR(m,n) xxr(0,m,n)
	  if( numberOfDimensions==2 )
	  {
	    real det = XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0);
	    if( fabs(det)>epsDet )
	    {
	      det=1./det;
	      dr[0]=(  XR(1,1)*dx[0]-XR(0,1)*dx[1] )*det;
	      dr[1]=( -XR(1,0)*dx[0]+XR(0,0)*dx[1] )*det;
	    }
	    else
	    { // if the jacobian is singular
	      if( debug & 1 )
	      {
		printf("Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n");
	      }
	      dr[0]=dr[1]=0.;
	    }
	    dr[2]=0.;
            if( debug & 4 )
  	      fprintf(pDebugFile,"Ogmg:buildExtraLevels: non-invertible pt, dr computed from r.x*dx: (fine interp i0=%i)\n"
                      "  grid=%i donor=%i fine=(i1,i2,i3)=(%i,%i,%i) coarse=(%i,%i,%i), dx=(%8.2e,%8.2e) r=(%8.2e,%8.2e)"
                      " dr=(%8.2e,%8.2e) \n",
		      i0,grid,grid2, i1,i2,i3,j1,j2,j3,
		     dx[0],dx[1],rr(0,0),rr(0,1),dr[0],dr[1]);
	  }
	  else
	  {
	    real det =((XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0))*XR(2,2) +
		       (XR(0,1)*XR(1,2)-XR(0,2)*XR(1,1))*XR(2,0) +
		       (XR(0,2)*XR(1,0)-XR(0,0)*XR(1,2))*XR(2,1));
	    if( det>epsDet )
	    {
	      det=1./det;
	      dr[0]=( (XR(1,1)*XR(2,2)-XR(2,1)*XR(1,2))*dx[0]+
		      (XR(2,1)*XR(0,2)-XR(0,1)*XR(2,2))*dx[1]+
		      (XR(0,1)*XR(1,2)-XR(1,1)*XR(0,2))*dx[2] )*det;
		      
	      dr[1]=( (XR(1,2)*XR(2,0)-XR(2,2)*XR(1,0))*dx[0]+
		      (XR(2,2)*XR(0,0)-XR(0,2)*XR(2,0))*dx[1]+
		      (XR(0,2)*XR(1,0)-XR(1,2)*XR(0,0))*dx[2] )*det;
		      
	      dr[2]=( (XR(1,0)*XR(2,1)-XR(2,0)*XR(1,1))*dx[0]+
		      (XR(2,0)*XR(0,1)-XR(0,0)*XR(2,1))*dx[1]+
		      (XR(0,0)*XR(1,1)-XR(1,0)*XR(0,1))*dx[2] )*det;

              if( debug & 4 )
		fprintf(pDebugFile," Ogmg:non-invertible pt: interp=(%i,%i,%i) j=(%i,%i,%i) R(jb=%i,.)=(%8.2e,%8.2e,%8.2e) \n"
		       "       x=(%8.2e,%8.2e,%8.2e) \n"
		       "       dx=(%8.2e,%8.2e,%8.2e) dr=(%8.2e,%8.2e,%8.2e) gridSpacing=(%8.2e,%8.2e,%8.2e)\n"
		       " xr(.,0)=(%8.2e,%8.2e,%8.2e) \n"
		       " xr(.,1)=(%8.2e,%8.2e,%8.2e) \n"
		       " xr(.,2)=(%8.2e,%8.2e,%8.2e) \n",
		       i1,i2,i3,j1,j2,j3,jb,R(jb,0),R(jb,1),R(jb,2),x(jb,0),x(jb,1),x(jb,2),
		       dx[0],dx[1],dx[2],dr[0],dr[1],dr[2],
		       g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2),
		       XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));  
	      
              for( int ax=0; ax<numberOfDimensions; ax++ )
	      {
                dr[ax]=min(g2.gridSpacing(ax),max(-g2.gridSpacing(ax),dr[ax]));
	      }
	      
	    }
	    else
	    { // if the jacobian is singular
	      if( debug & 1 )
		fprintf(pDebugFile,"Ogmg:WARNING: non-invertible point and jacobian=0. for estimating location\n"
                       " grid=%i, grid2=%i :  \n"
                       " xr[.][0]=(%8.2e,%8.2e,%8.2e) \n"
                       " xr[.][1]=(%8.2e,%8.2e,%8.2e) \n"
                       " xr[.][2]=(%8.2e,%8.2e,%8.2e) \n",grid,grid2,
                       XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));
	      dr[0]=dr[1]=dr[2]=0.;
	    }
	  }
	}
	
#undef XR
		    
	for( axis=0; axis<numberOfDimensions; axis++ )
	{
	  R(jb,axis)+=dr[axis];
	}

	if( checkForNans )  // *wdh* 2011/06/12 -- check for nan's
	{
	  if( R(jb,0)!=R(jb,0) || R(jb,1)!=R(jb,1) || R(jb,2)!=R(jb,2) )
	  {
	    printf("Ogmg:getInterpCoordsNew:ERROR(2): dr=(%e,%e,%e) r=(%e,%e,%e) nan's ?? map=%s\n",dr[0],dr[1],dr[2], R(jb,0),R(jb,1),R(jb,2),
		   (const char*)map2.getName(Mapping::mappingName));
            fflush(0);
	  }
	}
	
      }  // end if point not invertible
    
      for( axis=0; axis<numberOfDimensions; axis++ )
      {
	// limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	// from the last interpolation point.
	RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
      }
      if( checkForNans )  // *wdh* 2011/06/12 -- check for nan's
      {
	if( numberOfDimensions==2 )
	{
	  if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) )
	  {
	    printf("Ogmg:getInterpCoordsNew:ERROR(3): r=(%e,%e) nan's ?? map=%s\n",RB(i,0),RB(i,1),
		   (const char*)map2.getName(Mapping::mappingName));
	  }
	}
	else 
	{
	  if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) || RB(i,2)!=RB(i,2) )
	  {
	    printf("Ogmg:getInterpCoordsNew:ERROR(3): r=(%e,%e,%e) nan's ?? map=%s\n",RB(i,0),RB(i,1),RB(i,2),
		   (const char*)map2.getName(Mapping::mappingName));
	  }
	}
	
      }

    } // end for jb
  }  // end for grid2

  // *wdh* 2011/06/12 -- check for nan's
  if( checkForNans )  
  {
    for( int i=0; i<maxNumToInterp; i++ )
    {
      if( numberOfDimensions==2 )
      {
        // fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i RB=(%e,%e)\n",i,RB(i,0),RB(i,1));

	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) )
	{
	  printf("Ogmg:getInterpCoordsNew:ERROR(4): myid=%i i=%i r=(%e,%e) nan's ?? \n",myid,i,RB(i,0),RB(i,1));
	}
      }
      else 
      {
	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) || RB(i,2)!=RB(i,2) )
	{
	  printf("Ogmg:getInterpCoordsNew:ERROR(4): i=%i r=(%e,%e,%e) nan's ?? \n",i,RB(i,0),RB(i,1),RB(i,2));
	}
      }
	
    }
    fflush(0);
    fflush(pDebugFile);
    
  }
  
  return 0;
}


int Ogmg::
getInterpolationCoordinatesNew( CompositeGrid & cg0, // finer grid
				CompositeGrid & cg1, // new coarser grid
				const IntegerArray & ib,     // check these points...
                                const RealArray & xa,        // with these x-coordinates 
				const int grid,            // ..on this grid
				const IntegerArray & gridsToCheck, // ..from these grids
				realSerialArray & rb,      // return these values
				const bool isRectangular,
				int iv0[3], real dx0[3], real xab0[2][3],   // these are used by Macros!
				int iv1[3], real dx1[3], real xab1[2][3],
				InterpolationData & ipd,
                                IntegerArray & ia0,           // list of all interp points
                                realSerialArray & donorDist   // distance to donor
                               )
// ==================================================================================================
// /Description: ** new version that does many points at a time
//     Given a new interpolation point on a coarse grid, determine the r coordinates on the 
//   interpolee grid. 
//
// /ib (input) : ib(i,4) : (i,j1,j2,j3) 
// ==================================================================================================
{
  const bool checkForNans=false;  // for testing turn this on to check for nans

  CompositeGrid & mgcg = multigridCompositeGrid();
  const int numberOfDimensions=cg0.numberOfDimensions();
  const int numberOfComponentGrids = cg0.numberOfComponentGrids();

  #ifdef USE_PPP
    intSerialArray & interpoleeGrid0 = ipd.interpoleeGrid;
    intSerialArray & interpolationPoint0 = ipd.interpolationPoint;
    realSerialArray & interpolationCoordinates0 = ipd.interpolationCoordinates;
  #else
    const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
    const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
    const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
  #endif    


  // const intArray & interpoleeGrid0 =cg0.interpoleeGrid[grid];  // ************ should use cg0 ****
  // const realArray & interpolationCoordinates0 =cg0.interpolationCoordinates[grid];
  const real *interpolationCoordinates0p = interpolationCoordinates0.Array_Descriptor.Array_View_Pointer1;
  const int interpolationCoordinates0Dim0=interpolationCoordinates0.getRawDataSize(0);

  const int * interpoleeGrid0p = interpoleeGrid0.Array_Descriptor.Array_View_Pointer0;

  // const intArray & interpolationPoint0 =cg0.interpolationPoint[grid];
  const int *interpolationPoint0p = interpolationPoint0.Array_Descriptor.Array_View_Pointer1;
  const int interpolationPoint0Dim0=interpolationPoint0.getRawDataSize(0);

  MappedGrid & mg0 = cg0[grid];
  MappedGrid & mg1 = cg1[grid];
  const IntegerArray & gid0 = mg0.gridIndexRange();
  const IntegerArray & gid1 = mg1.gridIndexRange();
  
  #ifdef USE_PPP
    realSerialArray center;  if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg1.center(),center);
    realSerialArray center0; if( !isRectangular ) getLocalArrayWithGhostBoundaries(mg0.center(),center0);
  #else
    const realArray & center = mg1.center();
    const realArray & center0 = mg0.center();
  #endif


  const real *xap = xa.Array_Descriptor.Array_View_Pointer1;
  const int xaDim0=xa.getRawDataSize(0);
#define XA(i0,i1) xap[i0+xaDim0*(i1)]


  real *center0p;  
  int center0Dim0,center0Dim1,center0Dim2;
  real *centerp;
  int centerDim0,centerDim1,centerDim2;
  if( !isRectangular )
  {
    centerp = center.Array_Descriptor.Array_View_Pointer3;
    centerDim0=center.getRawDataSize(0);
    centerDim1=center.getRawDataSize(1);
    centerDim2=center.getRawDataSize(2);

    center0p = center0.Array_Descriptor.Array_View_Pointer3;
    center0Dim0=center0.getRawDataSize(0);
    center0Dim1=center0.getRawDataSize(1);
    center0Dim2=center0.getRawDataSize(2);

  }
#define CENTER0(i0,i1,i2,i3) center0p[i0+center0Dim0*(i1+center0Dim1*(i2+center0Dim2*(i3)))]	
      
  const int maxNumToInterp = ib.getLength(0);
  // if( maxNumToInterp==0 ) return 0;                 // ***************** fix me ***************

  realSerialArray x, r;
  IntegerArray ia;
  if( maxNumToInterp>0 )
    x.redim(maxNumToInterp,3); r.redim(maxNumToInterp,3); ia.redim(maxNumToInterp);
  
  real *xp = x.Array_Descriptor.Array_View_Pointer1;
  const int xDim0=x.getRawDataSize(0);
  real *rp = r.Array_Descriptor.Array_View_Pointer1;
  const int rDim0=r.getRawDataSize(0);

  int *ia0p = ia0.Array_Descriptor.Array_View_Pointer1;
  const int ia0Dim0=ia0.getRawDataSize(0);
#define IA0(i0,i1) ia0p[i0+ia0Dim0*(i1)]


  int *iap = ia.Array_Descriptor.Array_View_Pointer0;
#undef IA
#define IA(i0) iap[i0]

  real *rbp = rb.Array_Descriptor.Array_View_Pointer1;
  const int rbDim0=rb.getRawDataSize(0);
#define RB(i0,i1) rbp[i0+rbDim0*(i1)]

  int *ibp = ib.Array_Descriptor.Array_View_Pointer1;
  const int ibDim0=ib.getRawDataSize(0);

  int level0=0;
  const IntegerArray & coarseningRatio = mgcg.multigridCoarseningRatio(Range(0,2),grid,level0);
  int cf[3], &cf1=cf[0], &cf2=cf[1], &cf3=cf[2];
  cf1=coarseningRatio(axis1);  // coarsening factor
  cf2=coarseningRatio(axis2);
  cf3=coarseningRatio(axis3);  
  assert(cf1==2 && (cf2==2 || numberOfDimensions<2) && (cf3==2 || numberOfDimensions<3));

  const real epsDet=REAL_MIN*1.e5;  // *wdh* 1106012 -- lower bound for det(jacobian)

  int i0,ii,axis;
  int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];      
  int kv[3], &k1=kv[0], &k2=kv[1], &k3=kv[2];      
  int kpv[3], &kp1=kpv[0], &kp2=kpv[1], &kp3=kpv[2];      
  
  if( debug & 4 ) // *wdh* 110613
  {
    fprintf(pDebugFile,"  === getInterpolationCoordinatesNew START ===\n");
    for( int i=0; i<maxNumToInterp; i++ )
    {
      ii=IB(i,4); 
      int donor = IB(i,5);
      fprintf(pDebugFile,"  i=%i ii=%i (%i,%i,%i) donor=%i gridsToCheck(donor)=%i x=(%e,%e)\n",
              i,ii,IB(i,1),IB(i,2),IB(i,3),donor,gridsToCheck(donor),
	      XA(ii,0),XA(ii,1));
    }
  }


  // --------------------------------------------------------
  // ------------ Loop over possible donor grids ------------
  // --------------------------------------------------------
  for( int grid2=0; grid2<cg1.numberOfComponentGrids(); grid2++ )
  {
    #ifndef USE_PPP
      if( gridsToCheck(grid2)==0 ) continue;  // no need to check this grid -- in parallel we need to keep going
    #endif

    // collect up all new interpolation points that interpolate from grid2
    int jb=0;
    if( gridsToCheck(grid2)!=0 )
    {
      if( numberOfDimensions==2 )
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
	  ii=IB(i,4);  // index into cid and XA arrays
	  int donor = IB(i,5);
	  assert( donor>=0 && donor<numberOfComponentGrids );
	  if( donor==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;  // save i
	    X(jb,0)=XA(ii,0);
	    X(jb,1)=XA(ii,1);

	    i0=IB(i,0);  // index into original interpolation point arrays
	    if( i0>=0 )
	    {
	      R(jb,0)=ci0(i0,0); // initial guess
	      R(jb,1)=ci0(i0,1);
	      R(jb,2)=0.;
	    }
	    else
	    {
	      R(jb,0)=-1.;
	      R(jb,1)=-1.;
	      R(jb,2)=-1.;
	    }
	    jb++;
	  }
      
	}
      }
      else
      {
	for( int i=0; i<maxNumToInterp; i++ )
	{
	  ii=IB(i,4);  
	  int donor = IB(i,5);
	  assert( donor>=0 && donor<numberOfComponentGrids );
	  if( donor==grid2 )
	  {
	    j1=IB(i,1); j2=IB(i,2); j3=IB(i,3); 

	    IA(jb)=i;
	    X(jb,0)=XA(ii,0);
	    X(jb,1)=XA(ii,1);
	    X(jb,2)=XA(ii,2);
	    i0=IB(i,0);  // index into original fine grid interpolation point arrays
	    if( i0>=0 )
	    {
	      R(jb,0)=ci0(i0,0);
	      R(jb,1)=ci0(i0,1);
	      R(jb,2)=ci0(i0,2);
	    }
	    else
	    {
	      R(jb,0)=-1.;
	      R(jb,1)=-1.;
	      R(jb,2)=-1.;
	    }
	    jb++;
	  }
	}
      }
    }
    
    const int numToInterp=jb;
    // if( numToInterp==0 ) continue;  // **** no points to interpolate   -------------- fix me parallel ----------
    
    // printF(" grid=%i : interpolate %i extra points from grid2=%i\n",grid,numToInterp,grid2);

    MappedGrid & g2 = cg1[grid2];
    const IntegerArray & extended = g2.extendedIndexRange(); 
    const realArray & center2 = g2.center();

    const bool g2IsRectangular=g2.isRectangular();
    real dx2[3], xra[3][3];
    if( g2IsRectangular )
    {
      g2.getDeltaX(dx2);
    }
    const real offset = parameters.allowExtrapolationOfInterpolationPoints ? 1. : 0.; // *wdh* 040903
    real rMin[3], rMax[3];
    for( axis=0; axis<numberOfDimensions; axis++ )
    {
      // normally limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
      // from the last interpolation point.
      const real dr = g2.gridSpacing(axis);
      rMin[axis] = g2.boundaryCondition(Start,axis)!=0  ? -dr*offset :
	                                                  (extended(Start,axis)+.25)*dr; // move in .25*Dr from the end
      rMax[axis] = g2.boundaryCondition(End  ,axis)!=0  ? 1.+dr*offset :(extended(End,  axis)-.25)*dr;
    }
      
    Range Rni=numToInterp, Rx=numberOfDimensions;
    
    // invert mapping to get coordinates of the new interpolation pt.
    Mapping & map2 = g2.mapping().getMapping();
    map2.useRobustInverse(true);
    if( numToInterp>0 )
    {
      r=-1.;
      #ifdef USE_PPP
        map2.inverseMapS(x(Rni,Rx),r);  // ** here is the expensive part **
      #else
        map2.inverseMap(x(Rni,Rx),r);   // ** here is the expensive part **
      #endif
    }
    else
    {
      // There are no points on this processor to interpolate
      RealArray xNull,rNull;
      #ifdef USE_PPP
        map2.inverseMapS(xNull,rNull);  // ** here is the expensive part **
      #else
        map2.inverseMap(xNull,rNull);   // ** here is the expensive part **
      #endif
    }
    
    real dx[3], dr[3]={0.,0.,0.};
    real dr2[3]={g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2)}; //

    // numToFix : keep track of non-invertible points that need to call the map2 function
    int numToFix=0;  
    intSerialArray ja;

    for( jb=0; jb<numToInterp; jb++ )
    {
      const int i=IA(jb);  // index into the original ib array

      if( checkForNans )  // *wdh* 2011/06/12 -- for testing check for nan's
      {
	if( R(jb,0)!=R(jb,0) || R(jb,1)!=R(jb,1) || R(jb,2)!=R(jb,2) )
	{
	  if( true )
	  {
	    printf("  getInterpCoordsNew: ERROR: r=(%e,%e,%e) nan's ?? map=%s\n",R(jb,0),R(jb,1),R(jb,2),
		   (const char*)map2.getName(Mapping::mappingName));
	  }
	  
	  R(jb,0)=R(jb,1)=R(jb,2)=Mapping::bogus;
	}
      }

      const int ii = IB(i,4);  // index into IA0 array -- full list of coarse grid interp points 
      IA0(ii,4)=canInterpolateQuality1; // by default the interp. coord. quality is assumed to be good.

      if( max(fabs(R(jb,0)),fabs(R(jb,1)),fabs(R(jb,2))) > 5. )
      {
	// === pt was not invertible - estimate it's inverse location ===

        IA0(ii,4)=canInterpolateQualityBad; // bad quality for these "r" coordinates

	// To estimate the donor "r" coordinates we start from the corrdinates of a nearby
	// fine grid interpolation point and then add on a correction:
	//       r(coarse) = r(fine) + (dr/dx)*dx

        // printf("Ogmg::buildExtraLevelsNew:: myid=%i: Unable to invert pt (%i,%i,%i) grid=%i from donor=%i \n",
	//       myid,IB(i,1),IB(i,2),IB(i,3),grid,grid2); 

	if( debug & 4 )
	  fprintf(pDebugFile,"  getInterpCoordsNew: Unable to invert pt (%i,%i,%i) grid=%i from donor=%i,"
		  " R=(%8.2e,%8.2e,%8.2e)\n",IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 


        // --- First get i0: index of fine grid interpolation point that is closeby ---
        int i0=IB(i,0); // note i
	if( i0<0 )
	{
          // find the closest fine grid interp point that also uses this donor
          int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3); // coarse grid point
	  int i1=(j1-gid1(0,0))*cf[0]+gid0(0,0), i2=(j2-gid1(0,1))*cf[1]+gid0(0,1), i3=(j3-gid1(0,2))*cf[2]+gid0(0,2);  // fine grid pt
          int minDist=INT_MAX;
	  for( int k=interpolationPoint0.getBase(0); k<=interpolationPoint0.getBound(0); k++ )
	  {
            int donor=ig0(k);
	    if( donor==grid2 )
	    {
              int dist = abs(i1-ip0(k,0))+abs(i2-ip0(k,1));
	      if( numberOfDimensions==3 ) dist+= abs(i3-ip0(k,2));
	      if( dist<minDist )
	      {
		i0=k;
		minDist=dist;
	      }
	    }
	    
	  }
// 	  if( minDist>8 )  // the fine grid point cannot be two far away! *wdh* 2012/06/03
// 	  { 
// 	    i0=-1;
// 	  }

	  if( minDist>4 )
	  {
	    IA0(ii,4)=canInterpolateQualityVeryBad; // very bad qaulity for these "r" coordinates 
	  }
	  

	  if( i0<0 )
	  {
	    if( debug & 4 )
	    {
	      fprintf(pDebugFile,"  getInterpCoordsNew: i=%i Unable to invert pt (%i,%i,%i) grid=%i from donor=%i"
		      " R=(%8.2e,%8.2e,%8.2e) \n",i,IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 
	      fprintf(pDebugFile,"  getInterpCoordsNew: i=%i Unable to find a fine grid interp pt with donor=%i\n",i,grid2);
	    }
	    
	    // OV_ABORT("finish me for this case: IB(i,0)<0");


            // fill in bogus values -- this will force another donor grid to be found.
            // *** we could do better here ***
            IA0(ii,4)=canNotInterpolate; // mark as unable to interpolate
	    for( int axis=0; axis<numberOfDimensions; axis++ )
	    {
	      RB(i,axis)=Mapping::bogus;
	    }
	    continue;
	    
	  }
          else
	  {
            if( debug & 4 )
	      fprintf(pDebugFile,"  - use nearby fine grid interp. pt i0=%i, (%i,%i,%i) min-index-dist=%i "
                      "to guess interp coords...\n",
                      i0,ip0(i0,0),ip0(i0,1),(numberOfDimensions==2 ? 0 : ip0(i0,2)),minDist);
	      
	  }
	  
	  
	}
	
	assert( i0>=0 );
	
        // As a first approximation the r coords are the same as the nearby fine grid interp pt,
        // we then improve this below: 
  	for( axis=0; axis<numberOfDimensions; axis++ )   // *wdh* 021203
  	  R(jb,axis)=ci0(i0,axis);	

	

	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
	if( g2IsRectangular )
	{
          // -- If g2 is rectangular we can compute the correction dr[axis] directly. ---

	  int i1=ip0(i0,0), i2=ip0(i0,1), i3=numberOfDimensions==2 ? 0 : ip0(i0,2);
	  int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
	  if( isRectangular )
	  {
	    dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
	    dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
	    dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);
	  }
	  else
	  {
	    for( axis=0; axis<numberOfDimensions; axis++ )
	    {
	      dx[axis]=X(jb,axis)-CENTER0(i1,i2,i3,axis);  
	    }
	  
	  }
	  dr[0]=dx[0]/dx2[0]*dr2[0];
	  dr[1]=dx[1]/dx2[1]*dr2[1];
	  dr[2]=dx[2]/dx2[2]*dr2[2];

	  for( int axis=0; axis<numberOfDimensions; axis++ )
	  {
	    R(jb,axis)+=dr[axis];
	    // limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	    // from the last interpolation point.
	    RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
	  }

	}    
	else
	{
          // Grid g2 is curvilinear: 
          // Keep a list of non-invertible points that have a curvilinear donor grid.
          // Below we will evaluate map2 to determine dx/dr from which we compute dr[axis]

	  if( ja.getLength(0) >= numToFix )
	  { // add space to hold the points that need fixing
            int newSize = min( max(10,ja.getLength(0) + numToInterp/4), numToInterp);
            ja.resize(newSize,2);
	  }
	  ja(numToFix,0)=jb;
	  ja(numToFix,1)=i0;
	  numToFix++;
	}
      }  // end if point not invertible
      else
      {
        // Point was invertible: save the r coordinates
	if( debug & 4 )
	  fprintf(pDebugFile,"  getInterpCoordsNew: pt (%i,%i,%i) grid=%i interpolates from donor=%i,"
		  " R=(%8.2e,%8.2e,%8.2e)\n",IB(i,1),IB(i,2),IB(i,3),grid,grid2,R(jb,0),R(jb,1),R(jb,2)); 


        IA0(ii,4)=canInterpolateQuality1; // mark coordinates as best quality -- will later be adjusted
	for( int axis=0; axis<numberOfDimensions; axis++ )
	{
	  // limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	  // from the last interpolation point.

	  // RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis))); // *wdh* 2012/06/04

	  real rjb = R(jb,axis);
	  if( rjb<rMin[axis]-dr2[axis] || rjb>rMax[axis]+dr2[axis] )
	  {
            // coordinates are not so good: 
            IA0(ii,4)=canInterpolateWithExtrapolation;  
	  }

	  RB(i,axis)=max(rMin[axis],min(rMax[axis],rjb)); // *wdh* 2012/06/04


	}


      }
    
    } // end for jb


    int maxNumToFix=ParallelUtility::getMaxValue(numToFix);
    if( maxNumToFix>0 ) // we need to go through this loop if any processor has points to fix
    {
      // --- There were some non-invertible points that have a curvilinear donor grid ---
      // To estimate the donor "r" coordinates we start from the coordinates of a nearby
      // fine grid interpolation point and then add on a correction:
      //       r(coarse) = r(fine) + (dr/dx)*dx

      realSerialArray xx, rr, xxr;
      if( numToFix>0 )
      {
	rr.redim(numToFix,Rx);
	xx.redim(numToFix,Rx);
	xxr.redim(numToFix,Rx,Rx);
      }
      for( int jj=0; jj<numToFix; jj++ )
      {
	const int jb=ja(jj,0);
	for( int axis=0; axis<numberOfDimensions; axis++ )
	  rr(jj,axis)=R(jb,axis);
      }
      
      // Evaluate x.r at the nearby interp coord's
      map2.mapS(rr,xx,xxr);
	  
      for( int jj=0; jj<numToFix; jj++ )
      {
	const int jb=ja(jj,0);
	const int i0=ja(jj,1);
        const int i=IA(jb);  // index into the original ib array

	// dx = distance from nearby interpolation pt to the new interpolation point.
	// add dr = (dr/dx)_2 * dx 
        int i1=ip0(i0,0), i2=ip0(i0,1), i3=numberOfDimensions==2 ? 0 : ip0(i0,2);
        int j1=IB(i,1), j2=IB(i,2), j3=IB(i,3);
	if( isRectangular )
	{
	  dx[0]=CENTER10(j1,j2,j3)-CENTER00(i1,i2,i3);
	  dx[1]=CENTER11(j1,j2,j3)-CENTER01(i1,i2,i3);
	  dx[2]=CENTER12(j1,j2,j3)-CENTER02(i1,i2,i3);
	}
	else
	{
	  for( int axis=0; axis<numberOfDimensions; axis++ )
	  {
	    dx[axis]=X(jb,axis)-CENTER0(i1,i2,i3,axis);  
	  }
	  
	}
        #define XR(m,n) xxr(jj,m,n)
	if( numberOfDimensions==2 )
	{
	  real det = XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0);
	  if( fabs(det)>epsDet )
	  {
	    det=1./det;
	    dr[0]=(  XR(1,1)*dx[0]-XR(0,1)*dx[1] )*det;
	    dr[1]=( -XR(1,0)*dx[0]+XR(0,0)*dx[1] )*det;
	  }
	  else
	  { // if the jacobian is singular
	    if( debug & 1 )
	    {
	      printf("Ogmg:getInterpCoordsNew::WARNING: non-invertible point and jacobian=0. for estimating "
                     "location.\n");
	    }
	    dr[0]=dr[1]=0.;
	  }
	  dr[2]=0.;
	  if( debug & 4 )
	    fprintf(pDebugFile,"  getInterpCoordsNew: non-invertible pt, dr computed from r.x*dx: (fine interp i0=%i)\n"
		    "  grid=%i donor=%i fine=(i1,i2,i3)=(%i,%i,%i) coarse=(%i,%i,%i), dx=(%8.2e,%8.2e) r=(%8.2e,%8.2e)"
		    " dr=(%8.2e,%8.2e) \n",
		    i0,grid,grid2, i1,i2,i3,j1,j2,j3,
		    dx[0],dx[1],rr(jj,0),rr(jj,1),dr[0],dr[1]);
	}
	else // 3D
	{
	  real det =((XR(0,0)*XR(1,1)-XR(0,1)*XR(1,0))*XR(2,2) +
		     (XR(0,1)*XR(1,2)-XR(0,2)*XR(1,1))*XR(2,0) +
		     (XR(0,2)*XR(1,0)-XR(0,0)*XR(1,2))*XR(2,1));
	  if( det>epsDet )
	  {
	    det=1./det;
	    dr[0]=( (XR(1,1)*XR(2,2)-XR(2,1)*XR(1,2))*dx[0]+
		    (XR(2,1)*XR(0,2)-XR(0,1)*XR(2,2))*dx[1]+
		    (XR(0,1)*XR(1,2)-XR(1,1)*XR(0,2))*dx[2] )*det;
		      
	    dr[1]=( (XR(1,2)*XR(2,0)-XR(2,2)*XR(1,0))*dx[0]+
		    (XR(2,2)*XR(0,0)-XR(0,2)*XR(2,0))*dx[1]+
		    (XR(0,2)*XR(1,0)-XR(1,2)*XR(0,0))*dx[2] )*det;
		      
	    dr[2]=( (XR(1,0)*XR(2,1)-XR(2,0)*XR(1,1))*dx[0]+
		    (XR(2,0)*XR(0,1)-XR(0,0)*XR(2,1))*dx[1]+
		    (XR(0,0)*XR(1,1)-XR(1,0)*XR(0,1))*dx[2] )*det;

	    if( debug & 4 )
	      fprintf(pDebugFile," getInterpCoordsNew::non-invertible pt: interp=(%i,%i,%i) j=(%i,%i,%i)"
                      " R(jb=%i,.)=(%8.2e,%8.2e,%8.2e) \n"
		      "       x=(%8.2e,%8.2e,%8.2e) \n"
		      "       dx=(%8.2e,%8.2e,%8.2e) dr=(%8.2e,%8.2e,%8.2e) gridSpacing=(%8.2e,%8.2e,%8.2e)\n"
		      " xr(.,0)=(%8.2e,%8.2e,%8.2e) \n"
		      " xr(.,1)=(%8.2e,%8.2e,%8.2e) \n"
		      " xr(.,2)=(%8.2e,%8.2e,%8.2e) \n",
		      i1,i2,i3,j1,j2,j3,jb,R(jb,0),R(jb,1),R(jb,2),x(jb,0),x(jb,1),x(jb,2),
		      dx[0],dx[1],dx[2],dr[0],dr[1],dr[2],
		      g2.gridSpacing(0),g2.gridSpacing(1),g2.gridSpacing(2),
		      XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));  
	      
	    for( int ax=0; ax<numberOfDimensions; ax++ )
	    {
	      dr[ax]=min(g2.gridSpacing(ax),max(-g2.gridSpacing(ax),dr[ax]));
	    }
	      
	  }
	  else
	  { // if the jacobian is singular
	    if( debug & 1 )
	      fprintf(pDebugFile,"Ogmg::getInterpCoordsNew:WARNING: non-invertible point and jacobian=0. "
                      "for estimating location\n"
		      " grid=%i, grid2=%i :  \n"
		      " xr[.][0]=(%8.2e,%8.2e,%8.2e) \n"
		      " xr[.][1]=(%8.2e,%8.2e,%8.2e) \n"
		      " xr[.][2]=(%8.2e,%8.2e,%8.2e) \n",grid,grid2,
		      XR(0,0),XR(1,0),XR(2,0),XR(0,1),XR(1,1),XR(2,1),XR(0,2),XR(1,2),XR(2,2));
	    dr[0]=dr[1]=dr[2]=0.;
	  }
	} // end if 3D
	
	for( int axis=0; axis<numberOfDimensions; axis++ )
	{
	  R(jb,axis)+=dr[axis];
	  // limit r to [0,1] unless the boundary is interpolation, then limit by .25*Delta r
	  // from the last interpolation point.
	  RB(i,axis)=max(rMin[axis],min(rMax[axis],R(jb,axis)));
	}

      } // end for jj 
      
    } // end if( maxNumToFix>0 )
    
#undef XR

    // ------------------------------------------------------------------------
    // --- Compute the distance from the interp. pt. to the new donor point ---
    // ------------------------------------------------------------------------
    //  The distance will not be zero if the r-coord's have been shifted to the boundary

    // first make a sub-list of points for which we need to compute the distance
    if( numToInterp>0 )
      ja.redim(numToInterp);

    int numToComputeDist=0;
    for( int jb=0; jb<numToInterp; jb++ )
    {
      int i = IA(jb);  // index into IB, RB

      int ii = IB(i,4);  // index into IA0
      const int currentQuality=IA0(ii,3);         // current best donor quality
      const int interpCoordsQuality=IA0(ii,4);    // quality of the new donor

      
      if( interpCoordsQuality<=currentQuality )
      {
	// this donor may be of better quality -> we should compute the distance 
        // NOTE: there is really no need to compute the distance if the r-coord's are inside the unit square -> dist=0 *fix me*

	ja(numToComputeDist)=i;
	numToComputeDist++;
      }
      else
      {
	// this donor will not be chosen anyway -- 
	donorDist(ii,1)=REAL_MAX;
	for( int axis=0; axis<numberOfDimensions; axis++ )
	{
	  RB(i,axis)=Mapping::bogus;  // fill in bogus values -- this will force another donor grid to be found.
	}
      
      }
      
    } // end for jb
    
    
    realSerialArray rr,xx;
    if( numToComputeDist>0 )
    {
      rr.redim(numToComputeDist,Rx);  xx.redim(numToComputeDist,Rx);
    }
    
    for( int jj=0; jj<numToComputeDist; jj++ )
    {
      int i = ja(jj); // index into IB
      for( int axis=0; axis<numberOfDimensions; axis++ )
	rr(jj,axis)=RB(i,axis);  // Note: use RB values here since these have been limited to [-delta,1+delta]
      
    }
    
    // Evaluate x-coord's of donor points
    map2.mapS(rr,xx);

    // compute the distance from the donor points xx to the interp. pt. XA
    for( int jj=0; jj<numToComputeDist; jj++ )
    {
      int i = ja(jj); // index into IB
      int ii = IB(i,4); // index into IA0, XA
      
      real dist=0.;
      if( numberOfDimensions==2 )
        dist=sqrt( SQR(XA(ii,0)-xx(jj,0)) + SQR(XA(ii,1)-xx(jj,1)) );
      else
        dist=sqrt( SQR(XA(ii,0)-xx(jj,0)) + SQR(XA(ii,1)-xx(jj,1)) + SQR(XA(ii,2)-xx(jj,2)) );

      donorDist(ii,1)=dist;

      if( debug & 4 )
	fprintf(pDebugFile,"  getCoords: pt ii=%i (%i,%i,%i) xa=(%8.2e,%8.2e,%8.2e), potential donor=%i r=(%8.2e,%8.2e,%8.2e)"
                " x=(%8.2e,%8.2e,%8.2e) dist=%8.2e \n",
		ii,IA0(ii,0),IA0(ii,1),IA0(ii,2), XA(ii,0),XA(ii,1),(numberOfDimensions==2 ? 0. : XA(ii,2)),
                grid2,rr(jj,0),rr(jj,1),(numberOfDimensions==2 ? 0. : rr(jj,2)),
                xx(jj,0),xx(jj,1),(numberOfDimensions==2 ? 0. : xx(jj,2)),dist);

    }


  }  // end for( grid2 ) -- loop over possible donor grids




  // *wdh* 2011/06/12 -- check for nan's
  if( checkForNans )  
  {
    for( int i=0; i<maxNumToInterp; i++ )
    {
      if( numberOfDimensions==2 )
      {
        // fprintf(pDebugFile,"Ogmg:getInterpCoordsNew: i=%i RB=(%e,%e)\n",i,RB(i,0),RB(i,1));

	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) )
	{
	  printf("Ogmg:getInterpCoordsNew:ERROR(4): myid=%i i=%i r=(%e,%e) nan's ?? \n",myid,i,RB(i,0),RB(i,1));
	}
      }
      else 
      {
	if( RB(i,0)!=RB(i,0) || RB(i,1)!=RB(i,1) || RB(i,2)!=RB(i,2) )
	{
	  printf("Ogmg:getInterpCoordsNew:ERROR(4): i=%i r=(%e,%e,%e) nan's ?? \n",i,RB(i,0),RB(i,1),RB(i,2));
	}
      }
	
    }
    fflush(0);
    fflush(pDebugFile);
    
  }
  
  return 0;
}

