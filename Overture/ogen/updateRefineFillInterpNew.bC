#include "Overture.h"
#include "Ogen.h"
#include "display.h"
#include "HDF_DataBase.h"
#include "ParallelUtility.h"
#include "UpdateRefinementData.h"
#include "CanInterpolate.h"


int 
outputRefinementInfoNew( GridCollection & gc, 
			 const aString & gridFileName, 
			 const aString & fileName );

#beginMacro interpolationFailedMacro(g,grid,i)
// =============================================================================
//   Output diagnostics if we failed to interpolate a refinement grid point
// ============================================================================
{
  int bg = cg.baseGridNumber(grid);     // base grid for this refinement
  MappedGrid & cr = cg[grid];           // refined grid
  MappedGrid & cb = cg[bg];             // base grid

  int rf[3];  // refinement factors (to the BASE GRID!)
  rf[0]=rl.refinementFactor(0,g);
  rf[1]=rl.refinementFactor(1,g);
  rf[2]=rl.refinementFactor(2,g);

  const intSerialArray & ip = cg->interpolationPointLocal[grid];  // use the local array
  int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
  int ipDim0=ip.getRawDataSize(0);

  for( axis=0; axis<numberOfDimensions; axis++ )
  {
    iv[axis]=IP(i,axis);    
  }

  printf("updateRefinement:ERROR: myid=%i refinement patch interpolation point cannot interpolate! \n",myid);
  printf("ERROR: failed to interpolate point grid=%i i=%i ip=(%i,%i,%i) varWidth=%i\n",
	 grid,i,iv[0],iv[1],iv[2],variableInterpolationWidth(i));

  fprintf(plogFile,"updateRefinement:ERROR: refinement patch interpolation point cannot interpolate! \n");
	
  fprintf(plogFile,"ERROR: failed to interpolate point grid=%i i=%i ip=(%i,%i,%i) varWidth=%i\n",
	 grid,i,iv[0],iv[1],iv[2],variableInterpolationWidth(i));

  fflush(plogFile);
	  

  // ***** FAILED to interpolate -- output diagnostics ******
  const int *girp = cb.gridIndexRange().getDataPointer();
  bool isPeriodic[3]={false,false,false}; //
  for( dir=0; dir<numberOfDimensions; dir++ )
  {
    isPeriodic[dir]=  cb.isPeriodic(dir)==Mapping::functionPeriodic;
  }

  for( axis=0; axis<numberOfDimensions; axis++ )
  {
    // *** compute kv, lv bounds ***
    kv[axis]=floorDiv(iv[axis],rf[axis]);              // base grid pt <= iv
    if( isPeriodic[axis] )
    { // adjust for periodicity
      int period=GIR(End,axis)-GIR(Start,axis);
      kv[axis] =((kv[axis]+period-GIR(Start,axis)) % period)+GIR(Start,axis);
    }
    // lv[axis]=(iv[axis]+rf[axis]-1)/rf[axis];  // base grid pt >= iv
    lv[axis]=kv[axis] + ((iv[axis]%rf[axis]) !=0); // add 1 if iv is not coincident
    if( retry )
    { // If we are re-doing this point, increase the size of the base grid region that we search.
      if( kv[axis]==lv[axis] )
	lv[axis]+=1;
      // coincident=false; // assume this
    }
	  
  }

  intSerialArray & maskbLocal = maskBaseGrid[g];
    
  int * maskbp = maskbLocal.Array_Descriptor.Array_View_Pointer2;
  const int maskbDim0=maskbLocal.getRawDataSize(0);
  const int maskbDim1=maskbLocal.getRawDataSize(1);
#undef MASKB
#define MASKB(i0,i1,i2) maskbp[i0+maskbDim0*(i1+maskbDim1*(i2))]

  fprintf(plogFile,"Mask on the base grid (bg=%i), pts [%i,%i][%i,%i][%i,%i]:\n",bg,

	  kv[0],lv[0],kv[1],lv[1],kv[2],lv[2]);
  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
  {
    for( j2=kv[1]; j2<=lv[1]; j2++ )
    {
      for( j1=kv[0]; j1<=lv[0]; j1++ )
      {
	int mm=MASKB(j1,j2,j3);  // int ib=-maskb(j1,j2,j3)-1;
	fprintf(plogFile,"%6i ",mm); 
      }
      fprintf(plogFile,"\n");
    }
  }
  for( int dir=0; dir<numberOfDimensions; dir++ )
  {
    if( kv[dir]==lv[dir] )
    {
      lv[dir]+=1;
    }
  }
  fflush(plogFile);
  fprintf(plogFile,"*** show more pts: Mask on the base grid (bg=%i), pts [%i,%i][%i,%i][%i,%i]:\n",bg,
	  kv[0],lv[0],kv[1],lv[1],kv[2],lv[2]);
  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
  {
    for( j2=kv[1]; j2<=lv[1]; j2++ )
    {
      for( j1=kv[0]; j1<=lv[0]; j1++ )
      {
	int mm=MASKB(j1,j2,j3);  // int ib=-maskb(j1,j2,j3)-1;
	fprintf(plogFile,"%6i ",mm); 
      }
      fprintf(plogFile,"\n");
    }
  } 

  intSerialArray & interpoleeGridBaseGrid = interpoleeGridBaseGridA[g];
	  
  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
  {
    for( j2=kv[1]; j2<=lv[1]; j2++ )
    {
      for( j1=kv[0]; j1<=lv[0]; j1++ )
      {
	int ib=-MASKB(j1,j2,j3)-1;
	if( ib>=0 && ib<numberOfInterpolationPointsLocal(bg) )
	{
	  // the base grid point jv is an interpolation point.
	  int ipbg=interpoleeGridBaseGrid(ib);
	  fprintf(plogFile," ** The refinement grid point is close to base grid "
		  "interpolation pt=%i, donor grid=%i\n",
		  ib,ipbg);
	}
      }
    }
  }
	  
//   if( true )
//   {
//     printf("I will save a file `updateRefinementDebug.cmd' that can be used with the `refine' test\n"
// 	   " program in order to regenerate the adaptive grid and test it.\n");
//     outputRefinementInfoNew( cg, "bugGrid.hdf","updateRefinementDebug.cmd" );

//     fclose(plogFile);
//     Overture::abort("error");
//   }
//   else
//   {
// //     interpoleeGrid(i)=interpolee;
// //     interpolationCoordinates(i,Rx)=rrs(0,Rx);
// //     variableInterpolationWidth(i)=cg.interpolationWidth(0,grid,interpolee,mgLevel);

//   }

}
#endMacro



int Ogen::
updateRefinementFillInterpolationDataNew(CompositeGrid & cg, UpdateRefinementData & urd)
// =============================================================================
// /Description:
//   Fill in the interpolation data as part of the updateRefinement algorithm
// 
// ==============================================================================
{
  // debug=3;

  real & timeForInterpData = urd.timeForInterpData;
  real & timeForCopyInterpPoints = urd.timeForCopyInterpPoints;
  
  timeForInterpData=getCPU();
  timeForCopyInterpPoints=0.;

  const int np=max(1,Communication_Manager::Number_Of_Processors);

  using namespace CanInterpolate;

  Range Rx(0,cg.numberOfDimensions()-1),all;
  const int & numberOfDimensions = cg.numberOfDimensions();
  Index Iv[4], &I1 = Iv[0], &I2=Iv[1], &I3=Iv[2];
   Index Jv[3], &J1 = Jv[0], &J2=Jv[1], &J3=Jv[2];
  Index Kv[3], &K1 = Kv[0], &K2=Kv[1], &K3=Kv[2];

  int iv[3], &i1=iv[0], &i2=iv[1], &i3=iv[2];
  int jv[3], &j1=jv[0], &j2=jv[1], &j3=jv[2];
  int kv[3], &k3=kv[2];
  int lv[3], &l3=lv[2];
  int ie[3], &ie1=ie[0], &ie2=ie[1], &ie3=ie[2];

  
  IntegerArray & numberOfInterpolationPointsLocal = cg->numberOfInterpolationPointsLocal;
  int grid,axis,side,dir,l;

  int pShift[3]={0,0,0};
  RealArray rrs(1,3), xxs(1,3),rbs(1,3); rrs=-1.; rbs=-1.;

  intSerialArray interpolates(1), useBackupRules(1);
  useBackupRules=FALSE;
  // 
  // If checkForOneSided=TRUE then canInterpolate will not allow a one-sided interpolation
  // stencil to use ANY interiorBoundaryPoint's -- this is actually too strict. We really
  // only want to disallow interpolation that has less than the minimum overlap distance
  //
  checkForOneSided=false;  

  const int notAssigned = INT_MIN;
  const int mgLevel=0;  // *** multigrid level


  // Dimension the interpolationStartEndIndex array and copy values from base grids (which do not change)
  IntegerArray ise; ise=cg.interpolationStartEndIndex;
  // This next is wrong -- will break a reference with the rcData in the GC
  //  cg.interpolationStartEndIndex.redim(4,cg.numberOfComponentGrids(),cg.numberOfComponentGrids()); // is this needed?
  cg.interpolationStartEndIndex=-1;
  Range B = cg.numberOfBaseGrids();
  cg.interpolationStartEndIndex(all,B,B)=ise(all,B,B);

  // arrays to hold copys of the interpolation data
  intSerialArray *ipLocal = new intSerialArray [cg.numberOfBaseGrids()]; 
  intSerialArray *igLocal = new intSerialArray [cg.numberOfBaseGrids()]; 
  realSerialArray *ciLocal = new realSerialArray [cg.numberOfBaseGrids()];

  if( false )
  {
    // Here we copy all base grid interp points from all processors
    for( grid=0; grid<cg.numberOfBaseGrids(); grid++ )
    {
      // ipLocal[grid] will be a local copy of all the interpolation points
      ParallelUtility::redistribute(cg.interpolationPoint[grid],ipLocal[grid]);
      ParallelUtility::redistribute(cg.interpoleeGrid[grid],igLocal[grid]);
      ParallelUtility::redistribute(cg.interpolationCoordinates[grid],ciLocal[grid]);
    }
  }
  else
  {
    // here is the new way -- only transfer base grid interp data that we need on each processor
    transferInterpDataForAMR(cg,ipLocal,igLocal,ciLocal);
  }
  

  int iv0[3]={0,0,0};
  real dx[3]={0.,0.,0.},xab[2][3]={0.,0.,0.,0.,0.,0.};
#define VERTEX0(i0,i1,i2) xab[0][0]+dx[0]*(i0-iv0[0])
#define VERTEX1(i0,i1,i2) xab[0][1]+dx[1]*(i1-iv0[1])
#define VERTEX2(i0,i1,i2) xab[0][2]+dx[2]*(i2-iv0[2])


  for( l=1; l<cg.numberOfRefinementLevels(); l++ )
  { // Begin levels =1,...

    GridCollection & rl = cg.refinementLevel[l];


    // *** Stage I 
    //       o make a local copy of the interpolation data for this base grid
    //       o fill in local base grid mask with interpolation point numbers

    if( debug & 4 )
    {
      fPrintF(logFile,"\n **** Level l=%i : STAGE I ****\n",l);
      fprintf(plogFile,"\n **** Level l=%i : STAGE I ****\n",l);
    }

    // Allocate mask arrays for the portions of the base grid that lie 
    // underneath the refinement grid (local portion there-of)
    intSerialArray *maskBaseGrid = new intSerialArray [rl.numberOfComponentGrids()];  // delete these when done

    // Arrays to hold a local copy of the interpolation data for this base grid
    intSerialArray *ipBaseGridA = new intSerialArray [rl.numberOfComponentGrids()]; // delete these 
    intSerialArray *interpoleeGridBaseGridA= new intSerialArray [rl.numberOfComponentGrids()];
    realSerialArray *interpolationCoordinatesBaseGridA= new realSerialArray [rl.numberOfComponentGrids()];

    // number of local base grid interpolation points for each refinement grid:
    int *niBaseGrid = new int [rl.numberOfComponentGrids()]; // delete this
    int g;
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      niBaseGrid[g]=0;
    }
    
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  // Begin grids on this level g=0,...


      int grid =rl.gridNumber(g);           // index into cg
      int bg = cg.baseGridNumber(grid);     // base grid for this refinement
      MappedGrid & cr = rl[g];              // refined grid
      MappedGrid & cb = cg[bg];             // base grid
      const intArray & maskb = cb.mask();
      intArray & maskr = cr.mask();
      
      #ifdef USE_PPP
       intSerialArray maskrLocal; getLocalArrayWithGhostBoundaries(maskr,maskrLocal);
      #else
       intSerialArray & maskrLocal=maskr; 
      #endif
      

      // Make a local copy of the interpolation data for this base grid
//       intArray & ipBG = cg.interpolationPoint[bg];
//       intArray & interpoleeGridBG = cg.interpoleeGrid[bg];
//       realArray & interpolationCoordinatesBG = cg.interpolationCoordinates[bg];

      intSerialArray & ipBG = ipLocal[bg];
      intSerialArray & interpoleeGridBG = igLocal[bg];
      realSerialArray & interpolationCoordinatesBG = ciLocal[bg];

//      const int niBG=cg.numberOfInterpolationPoints(bg);
//      if( niBG==0 ) continue;

      const int niBG=ipBG.getLength(0);
      
      intSerialArray & ipBaseGrid = ipBaseGridA[g];
      intSerialArray & interpoleeGridBaseGrid = interpoleeGridBaseGridA[g];
      realSerialArray & interpolationCoordinatesBaseGrid = interpolationCoordinatesBaseGridA[g];

      if( niBG>0 )
      {
	ipBaseGrid.redim(niBG,numberOfDimensions);
	interpoleeGridBaseGrid.redim(niBG);
	interpolationCoordinatesBaseGrid.redim(niBG,numberOfDimensions);
      }

      int rf[3];  // refinement factors (to the BASE GRID!)
      rf[0]=rl.refinementFactor(0,g);
      rf[1]=rl.refinementFactor(1,g);
      rf[2]=rl.refinementFactor(2,g);

      #ifndef USE_PPP
        maskBaseGrid[g].reference(maskb);
        const intSerialArray & maskbLocal = maskb;
      #else
        intSerialArray & maskbLocal = maskBaseGrid[g];
    
        // We need a copy of the base grid mask points that lie underneath this refinement grid
        //    maskbLocal : the portion of maskb that unlies maskrLocal (i.e. using the partition of maskr)
        int ghost[4]={0,0,0,0}; //
        for( axis=0; axis<numberOfDimensions; axis++ )
   	  ghost[axis]=1;  // one ghost pt on the coarse grid will correspond to rrf points on the refinement grid
	
        getIndex(cr.extendedIndexRange(),I1,I2,I3);
        Iv[3]=0;
        CopyArray::copyCoarseToFine( maskb, maskr, Iv, maskbLocal, rf, ghost);
      #endif

      bool isPeriodic[3]={false,false,false}; //
      int ndr[3]={0,0,0};  // period in index space
      for( dir=0; dir<numberOfDimensions; dir++ )
      {
	isPeriodic[dir]=  cb.isPeriodic(dir)==Mapping::functionPeriodic;
	ndr[dir]=cb.gridIndexRange(1,dir)-cb.gridIndexRange(0,dir);
      }
      
      real timeCopyIp=getCPU();
      iv[2]=cb.indexRange(Start,axis3);
      int ii=0;
      for( int i=0; i<niBG; i++ )
      {
        // make a copy of the base grid interpolation data that sits under this refinement grid:
        bool ok=true;
	for( int dir=0; dir<numberOfDimensions; dir++ )
	{
	  iv[dir]=ipBG(i,dir);  

          // int ivr = iv[dir]*rf[dir]; // index in refinement index space
	  // if( ivr<maskrLocal.getBase(dir) || ivr>maskrLocal.getBound(dir) ) // *** use local maskb bounds ***
          if( iv[dir]<maskbLocal.getBase(dir) || iv[dir]>maskbLocal.getBound(dir) )
	  { 
            // base grid interpolation pt is outside this refinement -- ignore it if the periodic image is also outside
            if( isPeriodic[dir] )
	    {
              // is the periodic image of an interp in this local array?
              if( iv[dir]<maskbLocal.getBase(dir) &&
                  iv[dir]+ndr[dir] <= maskbLocal.getBound(dir)  )
	      { // periodic image is inside
                iv[dir]+=ndr[dir];
                assert( iv[dir] >= maskbLocal.getBase(dir) );
	      }
	      else if( iv[dir]>maskbLocal.getBound(dir) &&
                       iv[dir]-ndr[dir]>=maskbLocal.getBase(dir) )
	      {// periodic image is inside
                iv[dir]-=ndr[dir];
                assert( iv[dir] <= maskbLocal.getBound(dir) );
	      }
	      else
	      {
                ok=false;
	      }
	    }
	    else
	    {
	      ok=false;
	    }
	    
	    // ** break;
	  }
	}
	// ** if( ok )
	{
          // all processors must do the same P++ array op's
	  assert( ii<=interpoleeGridBaseGrid.getBound(0) );
	  
          interpoleeGridBaseGrid(ii)=interpoleeGridBG(i);      
          assert( interpoleeGridBaseGrid(ii)>=0 && interpoleeGridBaseGrid(ii)<cg.numberOfBaseGrids() );
	  
	  for( int dir=0; dir<numberOfDimensions; dir++ )
	  {
	    ipBaseGrid(ii,dir)=iv[dir];
            interpolationCoordinatesBaseGrid(ii,dir)=interpolationCoordinatesBG(i,dir); 
	  }
          if( ok ){ ii++; }
	  
	}
      }
      timeForCopyInterpPoints+=getCPU()-timeCopyIp;
      
      niBaseGrid[g]=ii;  // number of base grid interpolation points under this local refinement grid
      

      if( debug & 4 )
      {
        fprintf(plogFile,"myid=%i, l=%i g=%i grid=%i bg=%i: ni=%i niBaseGrid[g=%i]=%i (local base grid interp pts)\n",
                myid,l,g,grid,bg,niBG,bg,niBaseGrid[g]);
	fprintf(plogFile,"Here is the base grid interpolation data that lies in the local refinement grid\n");
	for( int i=0; i<niBaseGrid[g]; i++ )
	{
	  fprintf(plogFile," i=%i, ip=(%i,%i) donor=(%i) ci=(%8.2e,%8.2e)\n",i,
                      ipBaseGrid(i,0),ipBaseGrid(i,1),
		  interpoleeGridBaseGrid(i),
                  interpolationCoordinatesBaseGrid(i,0),interpolationCoordinatesBaseGrid(i,1));
	}
        fflush(plogFile);
      }
      

      if( debug & 4 )
      {
        fprintf(plogFile,"\n ==== Assign base grid mask with interp pts grid=%i (g=%i,bg=%i) at level=%i ====\n",
		grid,g,bg,l);
      }
      
      // printf(" interpoleeGridBG: bg=%i, min=%i, max=%i (before update)\n",bg,min(interpoleeGridBG),max(interpoleeGridBG));


      int * maskbp = maskbLocal.Array_Descriptor.Array_View_Pointer2;
      const int maskbDim0=maskbLocal.getRawDataSize(0);
      const int maskbDim1=maskbLocal.getRawDataSize(1);
#undef MASKB
#define MASKB(i0,i1,i2) maskbp[i0+maskbDim0*(i1+maskbDim1*(i2))]

      int * ipbgp = ipBaseGrid.Array_Descriptor.Array_View_Pointer1;
      int ipbgDim0=ipBaseGrid.getRawDataSize(0);
#undef IPBG
#define IPBG(i0,i1) ipbgp[i0+ipbgDim0*(i1)]

      const int isRectangular = cr.isRectangular();

      // mark base grid interpolation points with an index into its interpolation arrays
      // this let's us go from a mask<0 point to the index in the interpolationPoint array.
      i3=cb.indexRange(Start,axis3);
      const int ni=niBaseGrid[g]; // interp points on the local base grid
      if( numberOfDimensions==2 )
      {
	for( int i=0; i<ni; i++ )
	{
	  MASKB(IPBG(i,0),IPBG(i,1),i3)=-(i+1);
	}
      }
      else
      {
	for( int i=0; i<ni; i++ )
	{
	  MASKB(IPBG(i,0),IPBG(i,1),IPBG(i,2))=-(i+1);
	}
      }
	
      // **** perform a periodic update on maskbLocal if it spans a periodic direction *****

      // cb.mask().periodicUpdate();
	
      for( dir=0; dir<numberOfDimensions; dir++ )
      {
	if( isPeriodic[dir] )
	{ // does the local array span the periodic direction:
	  if( maskbLocal.getBase(dir) <cb.indexRange(0,dir) && 
	      maskbLocal.getBound(dir)>cb.indexRange(1,dir) )
	  {
            for( int d=0; d<3; d++ )
	    {
	      Jv[d]=maskbLocal.dimension(d); Kv[d]=Jv[d];
	    }
            // assign left ghost points from right interior values
	    Jv[dir]=Range(maskbLocal.getBase(dir),cb.indexRange(0,dir)-1);
	    Kv[dir]=Jv[dir]+ndr[dir];
	    maskbLocal(J1,J2,J3)=maskbLocal(K1,K2,K3);

	    // assign right ghost points from left interior values
	    Jv[dir]=Range(cb.indexRange(1,dir)+1,maskbLocal.getBound(dir));
	    Kv[dir]=Jv[dir]-ndr[dir];
	    maskbLocal(J1,J2,J3)=maskbLocal(K1,K2,K3);
	  }
	}
	
      }
      
      if( debug & 4 )
      {
	// fPrintF(logFile,"*** cg.numberOfInterpolationPoints(bg)=%i\n",niBG);
	// display(ipBG,"ipBG",logFile);
	displayMask(maskbLocal,sPrintF(buff,"Here is maskbLocal with interp pts marked, bg=%i (g=%i grid=%i)",bg,g,grid),plogFile);
	// display(maskbLocal,sPrintF(buff,"Here is maskbLocal with interp pts marked, bg=%i (g=%i grid=%i)",bg,g,grid),plogFile,"%4i ");
      }
      
      
    }  // end for grid g=0,...



    // Stage II: 
    //    o make a list of potential donor points 


    // For each refinement grid interpolation point save a list of potential base grid interpolation points

    // interpolationPointBaseGridA[g][i][bg] = interp. point index on base grid
    // interpoleeBaseGridA[g][i][bg] = donor base grid
    // numberOfPossibleInterpoleeBaseGridsA[g][i] = number of potential donor base grids
    // interpCoordsA[g][bg][3*i]  : interp coordinates of the point on a given base grid

    int **interpolationPointBaseGridA = new int* [rl.numberOfComponentGrids()];
    int **interpoleeBaseGridA = new int* [rl.numberOfComponentGrids()];
    int ** numberOfPossibleInterpoleeBaseGridsA = new int* [rl.numberOfComponentGrids()];
    real **interpCoordsA = new real* [rl.numberOfComponentGrids()];

    const int maximumNumberOfPossibleBaseGrids=10;
    bool retry=true;  // in parallel we initially turn on the retry option to we don't have to repeat a point

    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  // Begin grids on this level g=0,...


      int grid =rl.gridNumber(g);           // index into cg
      int bg = cg.baseGridNumber(grid);     // base grid for this refinement
      MappedGrid & cr = rl[g];              // refined grid
      MappedGrid & cb = cg[bg];             // base grid
//       const intArray & maskb = cb.mask();
//       intArray & maskr = cr.mask();

      const int ni = numberOfInterpolationPointsLocal(grid);  // number of new interp points
      // const intSerialArray & ip = interpolationPoints[l][g];      // new interp points 
      const intSerialArray & ip = cg->interpolationPointLocal[grid];  // use the local array

      interpolationPointBaseGridA[g] = new int [ni*maximumNumberOfPossibleBaseGrids];
      interpoleeBaseGridA[g] = new int [ni*maximumNumberOfPossibleBaseGrids];
      numberOfPossibleInterpoleeBaseGridsA[g] = new int [ni];
      interpCoordsA[g] = new real [3*ni*maximumNumberOfPossibleBaseGrids]; // these are not assigned until later
      
      #define interpolationPointBaseGrid(i,bg) interpolationPointBaseGridA[g][(bg)+maximumNumberOfPossibleBaseGrids*(i)]    
      #define interpoleeBaseGrid(i,bg) interpoleeBaseGridA[g][(bg)+maximumNumberOfPossibleBaseGrids*(i)]
      #define numberOfPossibleInterpoleeBaseGrids(i) numberOfPossibleInterpoleeBaseGridsA[g][i]
      #define interpCoords(i,bg,dir) interpCoordsA[g][(bg)+maximumNumberOfPossibleBaseGrids*((i)+ni*(dir))]
      
      // these names are too close to the above
      intSerialArray & ipBaseGrid = ipBaseGridA[g];
      intSerialArray & interpoleeGridBaseGrid = interpoleeGridBaseGridA[g];
      realSerialArray & interpolationCoordinatesBaseGrid = interpolationCoordinatesBaseGridA[g];


//       intArray & ipBG = cg.interpolationPoint[bg];
//       intArray & interpoleeGridBG = cg.interpoleeGrid[bg];
//       realArray & interpolationCoordinatesBG = cg.interpolationCoordinates[bg];

      if( debug & 4 )
        fprintf(plogFile,"\n ========= Find donor pts for grid=%i (g=%i) bg=%i at refinement level=%i =========\n",
		grid,g,bg,l);

      int rf[3];  // refinement factors (to the BASE GRID!)
      rf[0]=rl.refinementFactor(0,g);
      rf[1]=rl.refinementFactor(1,g);
      rf[2]=rl.refinementFactor(2,g);

      bool isPeriodic[3]={false,false,false}; //
      for( dir=0; dir<numberOfDimensions; dir++ )
      {
	isPeriodic[dir]=  cb.isPeriodic(dir)==Mapping::functionPeriodic;
      }

      intSerialArray & maskbLocal = maskBaseGrid[g];

      int * maskbp = maskbLocal.Array_Descriptor.Array_View_Pointer2;
      const int maskbDim0=maskbLocal.getRawDataSize(0);
      const int maskbDim1=maskbLocal.getRawDataSize(1);
      #undef MASKB
      #define MASKB(i0,i1,i2) maskbp[i0+maskbDim0*(i1+maskbDim1*(i2))]

      int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
      int ipDim0=ip.getRawDataSize(0);
      #undef IP
      #define IP(i0,i1) ipp[i0+ipDim0*(i1)]

      int * ipbgp = ipBaseGrid.Array_Descriptor.Array_View_Pointer1;
      int ipbgDim0=ipBaseGrid.getRawDataSize(0);
      #undef IPBG
      #define IPBG(i0,i1) ipbgp[i0+ipbgDim0*(i1)]


      i3=j3=k3=l3=cr.indexRange(Start,axis3);
      const int *girp = cb.gridIndexRange().getDataPointer();
      #define GIR(side,axis) girp[side+2*(axis)]

      for( int i=0; i<ni; i++ ) // refinement interpolation points
      {
//         // int interpoleeFound=0; // 0=not found, 1=found but from a base grid, 2=found from a refinement (done)
// 	int interpolee=-1;     // best guess so far for an interpolee grid 
      
        bool coincident=true;
        for( axis=0; axis<numberOfDimensions; axis++ )
	{
          iv[axis]=IP(i,axis);      // check this interp point

          if( iv[axis] % rf[axis] != 0 )
	    coincident=false;     // this pt does not lie on a base grid pt
          
          // [ kv[dir] : lv[dir] ] -- look in this box of points on the base grid mask

	  kv[axis]=floorDiv(iv[axis],rf[axis]);              // base grid pt <= iv
          if( isPeriodic[axis] )
	  { // adjust for periodicity .. but only if we are outside the local base grid mask
            if( kv[axis]<maskbLocal.getBase(axis) || kv[axis]>=maskbLocal.getBound(axis) ) // *wdh* 060312
	    {
	      int period=GIR(End,axis)-GIR(Start,axis);
	      kv[axis] =((kv[axis]+period-GIR(Start,axis)) % period)+GIR(Start,axis);
	    }
	    
	  }
          // lv[axis]=(iv[axis]+rf[axis]-1)/rf[axis];  // base grid pt >= iv
          lv[axis]=kv[axis] + ((iv[axis]%rf[axis]) !=0); // add 1 if iv is not coincident
          if( retry )
	  { // If we are re-doing this point, increase the size of the base grid region that we search.
	    if( kv[axis]==lv[axis] )
	      lv[axis]+=1;
            // coincident=false; // assume this
	  }
	  
	}
	if( debug & 4)
	  fprintf(plogFile,"\n>>  Interp. pt %i=(%i,%i,%i) (grid %i, base=%i) base coords=kv=(%i,%i,%i):lv=(%i,%i,%i)"
                     " maskbLocal=[%i,%i][%i,%i][%i,%i] ...\n",i,i1,i2,i3,grid,bg,kv[0],kv[1],kv[2],lv[0],lv[1],lv[2],
                      maskbLocal.getBase(0),maskbLocal.getBound(0),
                      maskbLocal.getBase(1),maskbLocal.getBound(1),
                      maskbLocal.getBase(2),maskbLocal.getBound(2)
                       );

	// **** For this interp pt., make a list of possible donor base grids (usually only one) *** 
	numberOfPossibleInterpoleeBaseGrids(i)=0;
	for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
	{
	  for( j2=kv[1]; j2<=lv[1]; j2++ )
	  {
	    for( j1=kv[0]; j1<=lv[0]; j1++ )
	    {
	      int ib=-MASKB(j1,j2,j3)-1;
	      if( ib>=0 && ib<niBaseGrid[g] )
	      {
		// ** The base grid point jv is an interpolation point. ***
                //   ib is an index into the local base grid interpolation data arrays

                assert( ib<=interpoleeGridBaseGrid.getBound(0) );

		int bgDonor=interpoleeGridBaseGrid(ib);  // donor grid corresponding to the base grid interp pt.
                assert( bgDonor>=0 && bgDonor<cg.numberOfBaseGrids());
		// make sure we don't already have this one in the list.
		bool alreadyFound=false;
		for( int nb=0; nb<numberOfPossibleInterpoleeBaseGrids(i); nb++ )
		{
		  if( interpoleeBaseGrid(i,nb)==bgDonor )
		  {
		    alreadyFound=true;
		    break;
		  }
		}
		if( !alreadyFound )
		{
		  if( debug & 4)
		  {
		    fprintf(plogFile,"  ..interp. pt %i=(%i,%i,%i) (grid %i, base=%i). Base interp pt %i is close"
			    " ipBG=(%i,%i) =? jv=(%i,%i), donor base-grid=%i.\n",
			    i,i1,i2,i3,grid,bg,ib,IPBG(ib,0),IPBG(ib,1),j1,j2,interpoleeGridBaseGrid(ib));
                    fflush(plogFile);
		  }
		  
		  interpolationPointBaseGrid(i,numberOfPossibleInterpoleeBaseGrids(i))=ib;
		  interpoleeBaseGrid(i,numberOfPossibleInterpoleeBaseGrids(i))=bgDonor;
		  numberOfPossibleInterpoleeBaseGrids(i)++;
		  assert( numberOfPossibleInterpoleeBaseGrids(i)<=maximumNumberOfPossibleBaseGrids );
		  
		}
		
	      }
	      else if( MASKB(j1,j2,j3)<0 )
	      {
		printf("updateRefinementFillInterpolationDataNew:ERROR: myid=%i : pt %i=(%i,%i,%i)\n"
                       "   grid=%i base=%i mask(%i,%i,%i)=%i is negative but not marked as an interp pt!\n",
		       myid,i,i1,i2,i3,grid,bg,j1,j2,j3,MASKB(j1,j2,j3));
		Overture::abort("error");
	      }
	    }
	  }
	} // end for j3
	if( numberOfPossibleInterpoleeBaseGrids(i)==0 )
	{
          printf("\n updateRefinement:ERROR: unable to find a base grid interp. pt.! See log file for details\n");
          fprintf(plogFile,"\n updateRefinement:ERROR: unable to find a base grid interp. pt.! "
                         "numberOfPossibleInterpoleeBaseGrids=0\n");
	  
	  fprintf(plogFile,"  ..interp. pt %i=(%i,%i,%i) (grid %i, base=%i). niBaseGrid[g]=%i\n",
		  i,i1,i2,i3,grid,bg,niBaseGrid[g]);
	  fprintf(plogFile,"Mask values: ib=-mask-1 --> index into base grid interp points. 0 <= ib < %i\n",
		  niBaseGrid[g]);
	  fprintf(plogFile,"Mask on the base grid (bg=%i), pts [%i,%i][%i,%i][%i,%i]:\n",bg,
                    kv[0],lv[0],kv[1],lv[1],kv[2],lv[2]);
	  for( j3=kv[2]; j3<=lv[2]; j3++ ) // loop over neighbouring base grid points.
	  {
	    for( j2=kv[1]; j2<=lv[1]; j2++ )
	    {
	      for( j1=kv[0]; j1<=lv[0]; j1++ )
	      {
                int mm=MASKB(j1,j2,j3);  // int ib=-maskb(j1,j2,j3)-1;
		fprintf(plogFile,"%6i ",mm); 
	      }
              fprintf(plogFile,"\n");
	    }
	  }
	  Overture::abort("error");
	}

      }  // end for i 

    }// end for g 
    


    // Stage III: 
    //    o invert donor points 

    // ** first try -- invert 1 pt at a time **

    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  // Begin grids on this level g=0,...


      int grid =rl.gridNumber(g);           // index into cg
      int bg = cg.baseGridNumber(grid);     // base grid for this refinement
      MappedGrid & cr = rl[g];              // refined grid
      MappedGrid & cb = cg[bg];             // base grid

      const bool isRectangular=cr.isRectangular();
      const RealArray & vertex = isRectangular ? Overture::nullRealArray() : cr.vertex().getLocalArray();

      if( isRectangular )
      { // these next values are use in the VERTEX0 macro
	cr.getRectangularGridParameters( dx, xab );
	iv0[0]=cr.gridIndexRange(0,0);
	iv0[1]=cr.gridIndexRange(0,1);
	iv0[2]=cr.gridIndexRange(0,2);

      }
      if( debug & 8 )
      {
	if( !cb.isRectangular() ) display(cb.vertex(),sPrintF("vertex on the base grid=%i",bg),logFile,"%3.1f ");
	if( !cr.isRectangular() ) display(vertex,sPrintF("vertex on the refinement grid=%i",grid),logFile,"%3.1f ");
      }
      
      if( debug & 4 )
        fprintf(plogFile,"\n =============== get interpolation coord's grid=%i (g=%i) at refinement level=%i ============\n",
		grid,g,l);

      // printf(" interpoleeGridBG: bg=%i, min=%i, max=%i (before update)\n",bg,min(interpoleeGridBG),max(interpoleeGridBG));

      int rf[3];  // refinement factors (to the BASE GRID!)
      rf[0]=rl.refinementFactor(0,g);
      rf[1]=rl.refinementFactor(1,g);
      rf[2]=rl.refinementFactor(2,g);

      // const intSerialArray & ip = interpolationPoints[l][g];      // new interp points 
      const intSerialArray & ip = cg->interpolationPointLocal[grid];  // use the local array
      int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
      int ipDim0=ip.getRawDataSize(0);
      #undef IP
      #define IP(i0,i1) ipp[i0+ipDim0*(i1)]

      i3=j3=k3=l3=cr.indexRange(Start,axis3);

      const int ni=numberOfInterpolationPointsLocal(grid);  // number of interp points on this processor

      for( int i=0; i<ni; i++ ) // refinement interpolation points
      {
        bool coincident=true;
        for( axis=0; axis<numberOfDimensions; axis++ )
	{
          iv[axis]=IP(i,axis);    
          if( iv[axis] % rf[axis] != 0 )
	    coincident=false;     // this pt does not lie on a base grid pt
	}
	if( debug & 4)
	  fprintf(plogFile,"\n>>Interp. pt %i=(%i,%i,%i) (grid %i, base=%i) numPossibleBase=%i"
                     " Trying to interpolate...\n",i,i1,i2,i3,grid,bg,numberOfPossibleInterpoleeBaseGrids(i));


        // loop over possible base grids
	for( int nb=0; nb<numberOfPossibleInterpoleeBaseGrids(i); nb++ )
	{
	  if( debug & 4)
	    fprintf(plogFile," ...invert pt on base grid %i (grid=%i isRectangular=%i)\n",interpoleeBaseGrid(i,nb), 
                  grid,isRectangular);
	    
          // find the coordinates of the interpolation point on this base grid:
	  int baseGridInterpolee=interpoleeBaseGrid(i,nb);
	  assert( baseGridInterpolee>=0 && baseGridInterpolee<cg.numberOfBaseGrids());
	  
	  if( !coincident )
	  {
	    // invert the mapping to locate the point.
	    if( isRectangular )
	    {
	      xxs(0,0)=VERTEX0(i1,i2,i3);
	      xxs(0,1)=VERTEX1(i1,i2,i3);
	      xxs(0,2)=VERTEX2(i1,i2,i3);
	    }
	    else
	    {
	      for( dir=0; dir<numberOfDimensions; dir++ )
		xxs(0,dir)=vertex(i1,i2,i3,dir);              // *************  use vertexLocal
	    }

            // ***** we need to do more than one point at a time ****
            rbs=-1.;  // *wdh* 040324
	    cg[baseGridInterpolee].mapping().getMapping().inverseMapS(xxs(0,Rx),rbs);

	  }
	  else
	  {
            realSerialArray & interpolationCoordinatesBaseGrid = interpolationCoordinatesBaseGridA[g];

	    int ib=interpolationPointBaseGrid(i,nb);
	    for( dir=0; dir<numberOfDimensions; dir++ )
	      rbs(0,dir)=interpolationCoordinatesBaseGrid(ib,dir);
	    
	  }
          // save interp coords
          for( dir=0; dir<numberOfDimensions; dir++ )
            interpCoords(i,nb,dir)=rbs(0,dir);

	  if( debug & 4)
	    fprintf(plogFile,"            pt %i=(%i,%i,%i) (grid %i, base=%i) --> invert: r=(%8.2e,%8.2e,%8.2e)"
		    " (coincident=%i)\n",
		    i,i1,i2,i3,grid,bg,rbs(0,0),rbs(0,1),rbs(0,2),coincident);
	  
	}
      } 
    }  // end for g 

    
    // Stage IV: 
    //    o canInterpolate ? 

    IntegerArray multipleInterpoleeGrids(rl.numberOfComponentGrids());
    multipleInterpoleeGrids=false;

    CanInterpolateQueryData *cid=NULL;
    int maxNumberOfQueries = 0;
    int niTotal=0;
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      int grid =rl.gridNumber(g); 
      niTotal+=numberOfInterpolationPointsLocal(grid);
    }
    if( niTotal>0 )
    {
      // guess how many queries we will make -- 
      //        guess that there are on average less than 3 grids queried per level
      maxNumberOfQueries = (niTotal+1)*(l+1)*3;
      cid = new CanInterpolateQueryData[maxNumberOfQueries];
    }

    int n=0;  // counts number of queries
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  // Begin grids on this level g=0,...


      int grid =rl.gridNumber(g);           // index into cg
      int bg = cg.baseGridNumber(grid);     // base grid for this refinement
      MappedGrid & cr = rl[g];              // refined grid
      MappedGrid & cb = cg[bg];             // base grid

      const bool isRectangular=cr.isRectangular();
      const RealArray & vertex = isRectangular ? Overture::nullRealArray() : cr.vertex().getLocalArray();

      if( isRectangular )
      { // these next values are use in the VERTEX0 macro
	cr.getRectangularGridParameters( dx, xab );
	iv0[0]=cr.gridIndexRange(0,0);
	iv0[1]=cr.gridIndexRange(0,1);
	iv0[2]=cr.gridIndexRange(0,2);

      }
      if( debug & 4 )
        fprintf(plogFile,"\n =============== canInterpolate? grid=%i (g=%i) at refinement level=%i ============\n",
		grid,g,l);


      int rf[3];  // refinement factors (to the BASE GRID!)
      rf[0]=rl.refinementFactor(0,g);
      rf[1]=rl.refinementFactor(1,g);
      rf[2]=rl.refinementFactor(2,g);

      i3=j3=k3=l3=cr.indexRange(Start,axis3);

      const int ni=numberOfInterpolationPointsLocal(grid);  // number of interp points on this processor

      // *** temp arrays for now:
      const int nid=max(1,ni);
//       intSerialArray interpoleeGrid(nid); 
//       realSerialArray interpolationCoordinates(nid,numberOfDimensions); 
//       intSerialArray variableInterpolationWidth(nid); 

      intSerialArray & interpolationPoint = cg->interpolationPointLocal[grid]; 
      interpolationPoint.resize(nid,numberOfDimensions);  // ** does this resize maintain the old values?
      
      intSerialArray & interpoleeGrid = cg->interpoleeGridLocal[grid]; 
      interpoleeGrid.redim(nid);
      intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid]; 
      variableInterpolationWidth.redim(nid); 
      variableInterpolationWidth=0;  // initialize to an invalid value
      realSerialArray & interpolationCoordinates = cg->interpolationCoordinatesLocal[grid];
      interpolationCoordinates.redim(nid,numberOfDimensions);

      intSerialArray & interpoleeLocation = cg->interpoleeLocationLocal[grid]; 
      interpoleeLocation.redim(nid,numberOfDimensions);
      interpoleeLocation=notAssigned; // these are assigned below **** check this *****


      // const intSerialArray & ip = interpolationPoints[l][g];      // new interp points 
      const intSerialArray & ip = cg->interpolationPointLocal[grid];  // use the local array
      int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
      int ipDim0=ip.getRawDataSize(0);
      #undef IP
      #define IP(i0,i1) ipp[i0+ipDim0*(i1)]

      
      for( int i=0; i<ni; i++ ) // refinement interpolation points
      {
        bool coincident=true;
        for( axis=0; axis<numberOfDimensions; axis++ )
	{
          iv[axis]=IP(i,axis);    

          if( iv[axis] % rf[axis] != 0 )
	    coincident=false;     // this pt does not lie on a base grid pt

          // compute kv, lv here or just below for debugging?
	}
	if( debug & 4)
	{
	  fprintf(plogFile,"\n>>canInterpolate:Interp. pt %i=(%i,%i,%i) (grid %i, base=%i)\n"
		  " Trying to interpolate...\n",i,i1,i2,i3,grid,bg);
	}
	

	// check the possible base grids.
	// *** we should try to check the last valid choice ****
	bool canInterpolate=false;
	bool backupCanInterpolate=false;
        int interpolee=-1;
	for( int nb=0; nb<numberOfPossibleInterpoleeBaseGrids(i); nb++ )
	{
          // find the coordinates of the interpolation point on this base grid:
	  int baseGridInterpolee=interpoleeBaseGrid(i,nb);

	  if( debug & 4)
	    fprintf(plogFile," ...check next base grid, nb=%i, base grid %i (grid=%i isRectangular=%i)\n",
                  interpoleeBaseGrid(i,nb),bg,grid,isRectangular);
	    
	  
	  if( debug & 2 )
	  { // get x coords for info messages:
	    if( isRectangular )
	    {
	      xxs(0,0)=VERTEX0(i1,i2,i3);
	      xxs(0,1)=VERTEX1(i1,i2,i3);
	      xxs(0,2)=VERTEX2(i1,i2,i3);
	    }
	    else
	    {
	      for( dir=0; dir<numberOfDimensions; dir++ )
		xxs(0,dir)=vertex(i1,i2,i3,dir);             
	    }
	  }
	  
          // get the interp coords
          for( dir=0; dir<numberOfDimensions; dir++ )
            rbs(0,dir)=interpCoords(i,nb,dir); 



          // ******** now check canInterpolate ****
	  MappedGrid & ibg = cg[baseGridInterpolee]; // the interpolee base grid.
	    
          // ******************************************************************************************
	  // *** now check to see if we can interpolate from any refinement grids on this base grid ***
          // ******************************************************************************************

	  for( int level=l; level>=0 && !canInterpolate ; level-- )
	  {
	    GridCollection & rll = cg.refinementLevel[level];

	    for( int g2=0; g2<rll.numberOfComponentGrids() && !canInterpolate; g2++ )
	    {
	      int grid2=rll.gridNumber(g2);
	      if( rll.baseGridNumber(g2)==baseGridInterpolee )
	      {
		// ie[3]=={ie1,ie2,ie3} : nearest point on the interpolee grid
		for( axis=0; axis<numberOfDimensions; axis++ )
		{
		  ie[axis]=int( (rbs(0,axis)/ibg.gridSpacing(axis))*rll.refinementFactor(axis,g2)+
				ibg.indexRange(Start,axis)+.5 );  // closest point (cell centered??)
		  // adjust points for periodicity -- the refinement patch may go from [-10,10] for example.
		  if( ibg.isPeriodic(axis)==Mapping::functionPeriodic )
		  {
		    int period=(ibg.gridIndexRange(End,axis)-ibg.gridIndexRange(Start,axis))*
		      rll.refinementFactor(axis,g2);
		    int ieNew =( (ie[axis]-rll[g2].indexRange(Start,axis)+period) % period ) +
		      rll[g2].indexRange(Start,axis);
		    pShift[axis]=ieNew-ie[axis];

		    // fprintf(plogFile,"periodic shift: ie[%i]=%i ieNew=%i, period=%i\n",axis,ie[axis],
		    //        ieNew,period);
			    
		    ie[axis]=ieNew;
		  }
		  else
		    pShift[axis]=0;
		}
		if( debug & 2 )
		{
		  fprintf(plogFile," ..check refinement grid2=%i level=%i ie=(%i,%i) rb=(%4.2f,%4.2f) xx=(%8.2e,%8.2e)"
                          "bounds=[%i,%i]x[%i,%i]\n",
			  grid2,level,ie1,ie2,rbs(0,0),rbs(0,1),xxs(0,0),xxs(0,1),
                          rll[g2].indexRange(Start,0),rll[g2].indexRange(End,0),
			  rll[g2].indexRange(Start,1),rll[g2].indexRange(End,1) );
		}
			
                // const IntegerArray & g2IndexRange = rll[g2].indexRange();
                const IntegerArray & g2IndexRange = rll[g2].extendedIndexRange(); // *wdh* 040804 

		if( ie1<g2IndexRange(Start,0) || ie1>g2IndexRange(End,0) ||
		    ie2<g2IndexRange(Start,1) || ie2>g2IndexRange(End,1) )        
		  continue;
		if( numberOfDimensions==3 && 
		    (ie3<g2IndexRange(Start,2) || ie3>g2IndexRange(End,2)) )
		  continue;

		// we are inside this refinement grid.

		interpolee=rll.gridNumber(g2);
		MappedGrid & ig = cg[interpolee];  
		for( axis=0; axis<numberOfDimensions; axis++ )
		{
		  const int rf = rll.refinementFactor(axis,g2);
		  rrs(0,axis)=(rbs(0,axis)*rf/ibg.gridSpacing(axis)+pShift[axis]
			       -(ig.indexRange(Start,axis)-ibg.indexRange(Start,axis)*rf) )*ig.gridSpacing(axis);
		}
		if( interpolee==baseGridInterpolee )
		{
                  for( axis=0; axis<numberOfDimensions; axis++ )
		    if( ig.isPeriodic(axis) )
		    {
		      rrs(0,axis)=fmod(rrs(0,axis)+1.,1.);   // base grid may be periodic, shift to [0,1]
		    }
		}

		if( debug & 4)
		  fprintf(plogFile,"  ..pt is inside refinement grid g2=%i (grid2=%i) at level %i rrs=(%g,%g)\n",
			  g2,grid2,level,rrs(0,0),rrs(0,1));
		if( n>=maxNumberOfQueries )
		{
		  int newMaxNumberOfQueries=int( maxNumberOfQueries*1.5 );
		  printf("\n *********************************************************\n"
                         " updateRefinementFillInterpDataNew:WARNING: \n"
                         "   myid=%i allocating more space for canInterpolate queries.\n"
                         "   Current number=%i, newNumber=%i (niTotal=%i)\n"
                         " ***********************************************************\n",
                         myid,maxNumberOfQueries,newMaxNumberOfQueries,niTotal);

		  CanInterpolateQueryData *cidNew = new CanInterpolateQueryData[newMaxNumberOfQueries];
		  for( int m=0; m<maxNumberOfQueries; m++ )
		  { // copy to the new array of queries.
		    cidNew[m]=cid[m];
		  }
		  delete [] cid;
		  cid = cidNew;
                  maxNumberOfQueries=newMaxNumberOfQueries;
		}
		

		cid[n].id=n; cid[n].i=i; cid[n].grid=grid; cid[n].donor=interpolee;
		for( int axis=0; axis<numberOfDimensions; axis++ )
		  cid[n].rv[axis]=rrs(0,axis);
		n++;
		
	      }
	    }
	  } // end for l
	} // end for nb
      } // end for i
    }  // end for g 
  
    
    int numberToCheck=n;
    if( debug & 2 )
    {
      printf(" ***** INFO: myid=%i l=%i maxNumberOfQueries=%i, actual number of queries=%i, niTotal=%i\n",
	     myid,l,maxNumberOfQueries,numberToCheck,niTotal);
    }
      
    // Allocate space for results
    CanInterpolateResultData *cir =NULL;
    cir = new CanInterpolateResultData[max(1,numberToCheck)]; // allocate at least 1 for MPI calls in caInterpolate
    

    // --------------------------------
    // -------check canInterpolate-----
    // --------------------------------
    CanInterpolate::canInterpolate( cg, numberToCheck,cid, cir );
      
//     int interpOk_ = new int [numberToCheck];
//     #define interpOk(i) interpOk_[i]
//     for( int n=0; n<numberToCheck; n++ )
//     {
//       interpOk(n)=0;
//     }
      

    // process the canInterpolate results
    for( int n=0; n<numberToCheck; n++ )
    {
      int i=cid[n].i;
      int width = cir[n].width;   // interpolation width (=0 if invalid)
      int grid=cid[n].grid;
      intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid]; 

      // Choose the donor point with largest width (and use the first one with that width) : 
      if( width>variableInterpolationWidth(i) )
      {
	int interpolee=cid[n].donor;

	if( grid<0 || grid>=cg.numberOfComponentGrids() || interpolee<0 || interpolee>=cg.numberOfComponentGrids() )
	{
	  printf("*** updateRefinementFillInterpolationDataNew:ERROR:myid=%i INVALID grid or donor from canInterpolate \n"
                 "   i=%i, grid=%i, donor=%i, width=%i\n",myid,i,grid,interpolee,width);
	  Overture::abort("error");
	}
        const int maxWidth = min( 11, cg.interpolationWidth(0,grid,interpolee,0)) ;
        if( width<0 || width>maxWidth )
	{
	  printf("*** updateRefinementFillInterpolationDataNew:ERROR:myid=%i INVALID interpolation width from canInterpolate \n"
                 "   i=%i, grid=%i, donor=%i, width=%i\n",myid,i,grid,interpolee,width);
	  Overture::abort("error");
	}
	

        intSerialArray & interpoleeGrid = cg->interpoleeGridLocal[grid];
        intSerialArray & interpoleeLocation = cg->interpoleeLocationLocal[grid];
        realSerialArray & interpolationCoordinates = cg->interpolationCoordinatesLocal[grid];

        interpoleeGrid(i)=interpolee;
        for( axis=0; axis<numberOfDimensions; axis++ )
	{
	  interpolationCoordinates(i,axis)=cid[n].rv[axis];
          interpoleeLocation(i,axis)=cir[n].il[axis];
	}
	
	variableInterpolationWidth(i)=width;
	if( debug & 4 )
	{
          // const IntegerArray & gid = cg[interpolee].gridIndexRange();
          // const IntegerArray & ir = extendedGridIndexRange(cg[interpolee]);
          const IntegerArray & ir = cg[interpolee].extendedIndexRange();
	  for( axis=0; axis<numberOfDimensions; axis++ )
	  {
	    if( interpoleeLocation(i,axis)<ir(0,axis)-1 || 
                interpoleeLocation(i,axis)>ir(1,axis) )
	    {
	      printf("updateRefineFillInterpDataNew:ERROR:myid=%i INVALID donor pt!:\n "
                     " i=%i, grid=%i, donor=%i, width=%i il=(%i,%i,%i), ci=(%8.2e,%8.2e,%8.2e) "
                     "egir=[%i,%i][%i,%i][%i,%i]\n",
                     myid,i,grid,interpolee,width,
		     interpoleeLocation(i,0),interpoleeLocation(i,1),
                     (numberOfDimensions==2 ? 0 : interpoleeLocation(i,2)),
                     interpolationCoordinates(i,0),interpolationCoordinates(i,1),
                     (numberOfDimensions==2 ? 0. : interpolationCoordinates(i,2)),
                     ir(0,0),ir(1,0),ir(0,1),ir(1,1),ir(0,2),ir(1,2) );
	    }
	  }
	}
	
	if( debug & 4)
	{
          intSerialArray & ip = cg->interpolationPointLocal[grid];
          const int maxWidth = cg.interpolationWidth(0,grid,interpolee,0);
          real *rv = cid[n].rv;
          if( width==maxWidth && cg.refinementLevelNumber(interpolee)==l )
	  {
	    fprintf(plogFile,"  ..pt %i (%i,%i,%i) on grid=%i can interp from refine grid %i, "
                    "r=(%g,%g,%g) width=%i il=[%i,%i,%i] isImplicit=%i\n",
		    i,
                    ip(i,0),ip(i,1),((numberOfDimensions==2 ? 0 : ip(i,2))),
                    grid,interpolee,rv[0],rv[1],(numberOfDimensions==2 ? 0. : rv[2]),width,
                    interpoleeLocation(i,0),interpoleeLocation(i,1),
                     (numberOfDimensions==2 ? 0 :interpoleeLocation(i,2)),
                     cg.interpolationIsImplicit(grid,interpolee));
	  }
	  else
	  {
	    fprintf(plogFile,"  ..pt %i (%i,%i,%i) on grid=%i may interp from grid %i,"
                             " r=(%g,%g,%g) width=%i il=[%i,%i,%i] isImplicit=%i (keep looking)\n",
		    i,ip(i,0),ip(i,1),((numberOfDimensions==2 ? 0 : ip(i,2))),
                    grid,interpolee,rv[0],rv[1],(numberOfDimensions==2 ? 0. : rv[2]),width,
                    interpoleeLocation(i,0),interpoleeLocation(i,1),
                     (numberOfDimensions==2 ? 0 :interpoleeLocation(i,2)),
                     cg.interpolationIsImplicit(grid,interpolee) );
	  }
	  
	}
	
      }
      
    } // end for n
    
    
    // Look to see if we have multiple donor grids (later we sort the interp).
    // Also check that we have interpolated all points -- if not we print diagnostics and abort
    bool interpolationFailed=false;
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  
      int grid =rl.gridNumber(g);     
      int ni=numberOfInterpolationPointsLocal(grid);

      intSerialArray & interpoleeGrid = cg->interpoleeGridLocal[grid];
      intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid]; 

      for( int i=0; i<ni; i++ )
      {
 	if( i>0 && !multipleInterpoleeGrids(g) )
 	  multipleInterpoleeGrids(g) =interpoleeGrid(i)!=interpoleeGrid(i-1);

	if( variableInterpolationWidth(i)<=0 )
	{ // this point was unable to interpolate --
          interpolationFailed=true;
	  interpolationFailedMacro(g,grid,i);
	}
      }
      // *wdh* 2012/03/02 -- all proc's must output the file on failure
      if( true )
      {
	interpolationFailed=ParallelUtility::getMaxValue(interpolationFailed);
	if( interpolationFailed )
	{
	  printF("I will save a file `updateRefinementDebug.cmd' that can be used with the `refine' test\n"
		 " program in order to regenerate the adaptive grid and test it.\n");
	  outputRefinementInfoNew( cg, "bugGrid.hdf","updateRefinementDebug.cmd" );

	  fclose(plogFile);
	  OV_ABORT("updateRefineFillInterNew: fatal ERROR");

	}
      }
      else if( interpolationFailed )
      {
        OV_ABORT("updateRefineFillInterNew: fatal ERROR");
	
      }
      
    }

    delete [] cid;
    delete [] cir;


    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  
      int grid =rl.gridNumber(g);     
      MappedGrid & cr = rl[g];              // refined grid

      const intSerialArray & ip = cg->interpolationPointLocal[grid];  // use the local array
      int * ipp = ip.Array_Descriptor.Array_View_Pointer1;
      int ipDim0=ip.getRawDataSize(0);

      if( numberOfInterpolationPointsLocal(grid)>0 )
      {
        // ** now mark interpolation points in the proper way ***
        intArray & maskr = cr.mask(); 
        const intSerialArray & maskrLocal = maskr.getLocalArray();
	const int ni=numberOfInterpolationPointsLocal(grid); 
	if( numberOfDimensions==2 )
	{
	  i3=cr.indexRange(Start,axis3);
          for( int i=0; i<ni; i++ )
    	    maskrLocal(IP(i,0),IP(i,1),i3)=MappedGrid::ISinterpolationPoint;   
	}
	else
	{
          for( int i=0; i<ni; i++ )
	    maskrLocal(IP(i,0),IP(i,1),IP(i,2))=MappedGrid::ISinterpolationPoint;   
	}

      }

      // make sure the parallel ghost points agree: 
      cr.mask().updateGhostBoundaries();



    } // end for g
    
    
    //   ***************************************
    //   **** Sort interp pts by donor grid ****
    //   ****  assign interpoleeLocations   ****
    //   ***************************************
    for( g=0; g<rl.numberOfComponentGrids(); g++ )
    {  
      int grid =rl.gridNumber(g);     

      intSerialArray & interpolationPoint = cg->interpolationPointLocal[grid]; 
      intSerialArray & interpoleeGrid = cg->interpoleeGridLocal[grid]; 
      intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid]; 
      realSerialArray & interpolationCoordinates = cg->interpolationCoordinatesLocal[grid];
      intSerialArray & interpoleeLocation = cg->interpoleeLocationLocal[grid]; 

      const int ni=numberOfInterpolationPointsLocal(grid); 
      IntegerArray & ise = cg.interpolationStartEndIndex;

      // sort the interpolation points by interpolee grid.
      // ise(all,grid,all)=-1;   // --> this is already done above now
      if( multipleInterpoleeGrids(g) )
      {
	if( debug & 4 )
	  fprintf(plogFile," ************* computeOverlap: Sorting interpolation points... ********************\n");
	// First count the number of interpolee points for each grid.
	IntegerArray ng(cg.numberOfComponentGrids()+1);
	intSerialArray ig(interpoleeGrid);  // we do need copies of these
	intSerialArray ip(interpolationPoint);
	intSerialArray il(interpoleeLocation);
	realSerialArray ic(interpolationCoordinates);
	intSerialArray iw(variableInterpolationWidth);
	
	ng=0;
	for( int i=0; i<ni; i++ )
	  ng(interpoleeGrid(i)+1)+=1;
	
	for( int gg=2; gg<=cg.numberOfComponentGrids(); gg++ )  // note <=
	  ng(gg)+=ng(gg-1); // ng(g) now points to the starting position for interpolee grid "g"
	  
	for( int grid2=0; grid2<cg.numberOfComponentGrids(); grid2++ )
	{
	  if( ng(grid2+1)-ng(grid2)>0 )
	  {
	    ise(0,grid,grid2)=ng(grid2);      // start value
	    ise(1,grid,grid2)=ng(grid2+1)-1;  // end value
	    // end value for implicit points: (could sort to put any implicit points first)
	    ise(2,grid,grid2)= ise(1,grid,grid2);
	  }
//             printf("     grid=%i, grid2=%i, ng(grid2)=%i, ng(grid2+1)=%i SE=[%i,%i]\n",
//                      grid,grid2,ng(grid2),ng(grid2+1),ise(0,grid,grid2),
//                       ise(1,grid,grid2));
	}
	
	// Now fill in the points -- this could be sped up --
	for( int i=0; i<ni; i++ )
	{
	  int pos=ng(ig(i)); ng(ig(i))+=1;
	  interpoleeGrid(pos)=ig(i);
	  interpolationPoint(pos,Rx)=ip(i,Rx);
	  interpolationCoordinates(pos,Rx)=ic(i,Rx);
	  interpoleeLocation(pos,Rx)=il(i,Rx);
	  variableInterpolationWidth(pos)=iw(i);
	}
      }
      else
      {
	if( ni>0 )
	{
	  int grid2=interpoleeGrid(0);
	  //  printf(" grid=%i, grid2=%i, ng(grid2)=%i, ni=%i\n",grid,grid2,cg.numberOfInterpolationPoints(grid));

	  ise(0,grid,grid2)=0;      // start value
	  ise(1,grid,grid2)=numberOfInterpolationPointsLocal(grid)-1;  // end value
	  // end value for implicit points: (could sort to put any implicit points first)
	  ise(2,grid,grid2)= ise(1,grid,grid2);
	}
      }
      if( debug & 4 )
      {
	for( int grid2=0; grid2<cg.numberOfComponentGrids(); grid2++ )
	  fprintf(plogFile," ==> grid=%i grid2=%i ise=%i %i \n",grid,grid2,ise(0,grid,grid2),ise(1,grid,grid2));
      }
      

      IntegerArray interpolationWidth(3);
      interpolationWidth=1;
      for( int i=0; i<ni; i++ )
      {
	int grid2=interpoleeGrid(i);
        interpolationWidth(Rx)=variableInterpolationWidth(i);
	MappedGrid & g2 = cg[grid2];
	for( int axis=0; axis<numberOfDimensions; axis++ )
	{
          if( interpoleeLocation(i,axis)==notAssigned )
	  {
	    // Get the lower-left corner of the interpolation cube.
	    int intLoc=int(floor(interpolationCoordinates(i,axis)/g2.gridSpacing(axis) + g2.indexRange(0,axis) -
				 .5 * interpolationWidth(axis) + (g2.isCellCentered(axis) ? .5 : 1.)));
	    if (!g2.isPeriodic(axis)) 
	    {
	      if( (intLoc < g2.extendedIndexRange(0,axis)) && (g2.boundaryCondition(Start,axis)>0) )
	      {
		//                        Point is close to a BC side.
		//                        One-sided interpolation used.
		intLoc = g2.extendedIndexRange(0,axis);
	      }
	      if( (intLoc + interpolationWidth(axis) - 1 > g2.extendedIndexRange(1,axis))
		  && (g2.boundaryCondition(End,axis)>0) )
	      {
		//                        Point is close to a BC side.
		//                        One-sided interpolation used.
		intLoc = g2.extendedIndexRange(1,axis) - interpolationWidth(axis) + 1;
	      }
	    } // end if
	    interpoleeLocation(i,axis) = intLoc;
	  }
	} // end for axis
      } // end for i 
    } // end for g 
    

    // *** Output all interpolation data for this grid ***
    if( debug & 2 )
    {
      fprintf(plogFile,"\n *** End of Stage IV -- Summary for myid=%i, np=%i ***\n",myid,np);
      for( g=0; g<rl.numberOfComponentGrids(); g++ )
      {  
	int grid =rl.gridNumber(g);     

	intSerialArray & interpolationPoint = cg->interpolationPointLocal[grid]; 
	intSerialArray & interpoleeGrid = cg->interpoleeGridLocal[grid]; 
	intSerialArray & variableInterpolationWidth = cg->variableInterpolationWidthLocal[grid]; 
	realSerialArray & interpolationCoordinates = cg->interpolationCoordinatesLocal[grid];
	intSerialArray & interpoleeLocation = cg->interpoleeLocationLocal[grid]; 

        const int ni=numberOfInterpolationPointsLocal(grid); 
        fprintf(plogFile,"\n ---- grid=%i ni=%i ---\n",grid,ni);
        for( int i=0; i<ni; i++ )
	{
	  fprintf(plogFile," grid=%i: i=%4i ip=(%3i,%3i,%3i) donor=%i il=(%3i,%3i,%3i) ci=(%9.2e,%9.2e,%9.2e)\n",
                  grid,i,
		  interpolationPoint(i,0),interpolationPoint(i,1),
                       (numberOfDimensions==2 ? 0 : interpolationPoint(i,2)),
		  interpoleeGrid(i),
		  interpoleeLocation(i,0),interpoleeLocation(i,1),
                       (numberOfDimensions==2 ? 0 : interpoleeLocation(i,2)),
		  interpolationCoordinates(i,0),interpolationCoordinates(i,1),
                  (numberOfDimensions==2 ? 0 : interpolationCoordinates(i,2)));
	}
	
      }
      fflush(plogFile);
    }
  

    // clean up 

    delete [] maskBaseGrid;
    delete [] ipBaseGridA;
    delete [] interpoleeGridBaseGridA;
    delete [] interpolationCoordinatesBaseGridA;
    delete [] niBaseGrid;

    for( int g=0; g<rl.numberOfComponentGrids(); g++ )
    {
      delete [] interpolationPointBaseGridA[g];
      delete [] interpoleeBaseGridA[g];
      delete [] numberOfPossibleInterpoleeBaseGridsA[g];
      delete [] interpCoordsA[g];
    }
    delete [] interpolationPointBaseGridA;
    delete [] interpoleeBaseGridA;
    delete [] numberOfPossibleInterpoleeBaseGridsA;
    delete [] interpCoordsA;
    
      
  } // done refinement levels

  delete [] ipLocal;
  delete [] igLocal;
  delete [] ciLocal;


  timeForInterpData=getCPU()-timeForInterpData;

  return 0;
}
