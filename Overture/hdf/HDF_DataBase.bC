#include "HDF_DataBase.h"
#include "DataBaseBuffer.h"
#include "ReferenceCountingList.h"

#ifdef OV_USE_HDF5
#include "HDF5_DataBase.C"
#else

#include "mfhdf.h"          // multi-file hdf include
int HDF_DataBase::debug =0; 

//\begin{>HDF_DataBaseInclude.tex}{\subsection{Constructors}} 
HDF_DataBase::
HDF_DataBase()
//=====================================================================================
// /Description:
//   Default constructor;
// /Author: WDH
//
//\end{HDF_DataBaseInclude.tex} 
//=====================================================================================
{  
  className="HDF_DataBase";
  rcData = NULL;
  dbList=NULL;
  accessMode=none;
  file_id=sd_id=-1;

  mode=normalMode; // *wdh* do not change this
  dataBaseBuffer=NULL;
  bufferWasCreatedInThisDirectory=FALSE;
}

//\begin{>>HDF_DataBaseInclude.tex}{}
HDF_DataBase::
HDF_DataBase(const HDF_DataBase & db )
//=====================================================================================
// /Description:
//   Copy constructor (shallow copy).
//   Make a copy of the directory. This does not copy the data-base file.
// /Author: WDH
//
//\end{HDF_DataBaseInclude.tex} 
//=====================================================================================
{
  rcData=NULL;
  *this=db;
}

//\begin{>>HDF_DataBaseInclude.tex}{}
HDF_DataBase::
HDF_DataBase(const GenericDataBase & db )
//=====================================================================================
// /Description:
//   Copy constructor, this works if db is really a member of this derived class.
// /Author: WDH
//
//\end{HDF_DataBaseInclude.tex} 
//=====================================================================================
{
  // cast to HDF_DataBase -- first check class name
  if( db.className=="HDF_DataBase" )
  {
    rcData=NULL;
    *this=(const HDF_DataBase &) db;
  }
  else
  {
    cout << "HDF_DataBase:ERROR: copy constructor - input type is not HDF_DataBase\n";
    throw "HDF_DataBase:ERROR: copy constructor - input type is not HDF_DataBase";
  }
}

GenericDataBase* HDF_DataBase::
virtualConstructor() const
{
  return new HDF_DataBase;
}



HDF_DataBase & HDF_DataBase::
operator=(const HDF_DataBase & db )
//=====================================================================================
// /Description:
//   Shallow copy: make a copy of the directory. This does not copy the data-base file.
// /Author: WDH
//
//=====================================================================================
{ 
  if( debug & 2 )
    cout << "HDF_DataBase: operator = called " << endl;

  if( rcData && rcData->decrementReferenceCount()==0 )
    destroy();

  this->GenericDataBase::operator=(db);            // call = base class
  // make this object point to the same rcData
  rcData=db.rcData;
  if( rcData )
    rcData->incrementReferenceCount();

  file_id=db.file_id;
  sd_id=db.sd_id;
  dbList=db.dbList;
  accessMode=db.accessMode;

  mode=db.mode;
  dataBaseBuffer=db.dataBaseBuffer; // copy pointer only
  bufferWasCreatedInThisDirectory=FALSE;

  return *this;
}

GenericDataBase & HDF_DataBase::
operator=(const GenericDataBase & db )
{
  // cast to HDF_DataBase if appropriate
  if( db.className=="HDF_DataBase" )
  {
    *this = (const HDF_DataBase &) db;
  }
  else
  {
    cout << "HDF_DataBase:ERROR: operator= - input type is not HDF_DataBase\n";
    throw "HDF_DataBase:ERROR: operator= - input type is not HDF_DataBase";
  }
  return *this;
}


HDF_DataBase::
~HDF_DataBase()
{
  if( dataBaseBuffer!=NULL && bufferWasCreatedInThisDirectory )
  {
    mode=normalMode;
    closeStream();  // close stream buffers
  }

  if( debug & 2 )
    cout << "HDF_DataBase: destructor called\n";
  if( rcData && rcData->decrementReferenceCount()==0 )
    destroy();
  if( dbList && dbList->getLength()==0 )
  {
    if( debug & 1 )
      cout << "~HDF_DataBase: delete the list...\n";
    delete dbList;
  }
}

void HDF_DataBase::
destroy()
{
  // close the vgroup, delete from the list and then delete
  close();
  dbList->deleteElement(*rcData);
  delete rcData;
}

 

int HDF_DataBase:: 
close()
// close the directory, flush data
{
  assert(rcData!=NULL);
  // Terminate access to the Vgroup interface.
  if( rcData->vgroup_id > 0 )
  {
    // assert( file_id > 0 && sd_id > 0 );
    if( file_id<=0 || sd_id<=0 ) 
    {
      printf("HDF_DataBase::close:ERROR: file_id=%i and sd_id=%i\n",file_id,sd_id);
      assert( file_id > 0 && sd_id > 0 );
    }
    if( debug & 2 )
      cout << "close: vgroup_id =" << rcData->vgroup_id << endl;
    Vdetach(rcData->vgroup_id);
    rcData->vgroup_id=-1;
    // rcData->vgroup_ref=-1;
  }
  return 0;
}
 
void HDF_DataBase::
reference( const HDF_DataBase & db )
{
  *this=db;
}

// This is a private routine
// It will allocate a new rcData and put it in the list
// you should always assign a (new) vgroup_id after calling breakReference
// all rcData's in the list should have different vgroup_id's
void HDF_DataBase::
breakReference()
{
  if( rcData && rcData->decrementReferenceCount()==0 )
    destroy();

  rcData = new HDF_DataBaseRCData;
  rcData->incrementReferenceCount();
  rcData->vgroup_id=-1;
  // rcData->vgroup_ref=-1;
  dbList->addElement(*rcData);
}


//\begin{>>HDF_DataBaseInclude.tex}{\subsection{mount}} 
int HDF_DataBase:: 
mount(const aString & fileName, const aString & flags )
//=============================================================================
// /Description:
//   Mount a data-base file.
// /fileName (input): the name of the file.
// /flags (input): flags to indicate how to access the file, "I" = initialize
//   a new file, "W" = open an existing file for reading and writing,
//   "R" = open an existing file read-only.
// /Return values: 0=success, -1=unable to open a file that was supposed to exist,
//     1=error in file format for an exitsing file, 2=unknown value for flags 
//\end{HDF_DataBaseInclude.tex} 
//=============================================================================
{
  if( file_id > 0 )
  {
    cout << "HDF_DataBase:mount: ERROR: cannot mount a file on a dataBase that already has a file mounted!\n";
    throw "HDF_DataBase:mount: ERROR: cannot mount a file on a dataBase that already has a file mounted!\n";
  }
  // **** could check more here dbList==NULL ...

  //
  // make the list that holds all the data-bases associated with this file
  // The list may already be there if we have used this dataBase for something else
  // It had better be empty or only contain vgroups with vgroup_id=-1
  // We should not delete it since there may be objects around that use the rcData's found in the list
  // 
  if( dbList==NULL )
    dbList = new ListOfHDF_DataBaseRCData;

  if( referenceCountingList==NULL )
    referenceCountingList = new ReferenceCountingList;

  /* Open an HDF file with full access. */
  if( flags==" I" || flags[0]=='I' || flags[0]=='i' )
  {
    accessMode=write;
    sd_id   = SDstart((const char *)fileName, DFACC_CREATE);
    if( sd_id <= 0 )
    {
      cout << "HDF_DataBase:mount:ERROR: unable to open a new file = " << (const char *)fileName << endl;
      exit (1);
    }	
    file_id = Hopen((const char *)fileName, DFACC_RDWR, 0);
    // Initialize HDF for subsequent Vgroup/Vdata access. 
    if( file_id<=0 ) 
    {
      printf("HDF_DataBase::mount:ERROR return from Hopen file_id=%i\n",file_id);
      assert( file_id > 0 );
    }

    Vstart(file_id);
    // Create a Vgroup.
    breakReference();  // this will create a new rcData
    rcData->vgroup_id = Vattach(file_id, -1, "w"); 

    /* Set the name and class for this Vgroup. */
    Vsetname(rcData->vgroup_id, "root");
    Vsetclass(rcData->vgroup_id, "directory");

  }
  else 
  {
    if( flags==" W" || flags[0]=='W' || flags[0]=='w' )
    {
      accessMode=write;
      sd_id   = SDstart((const char *)fileName, DFACC_RDWR);
      if (sd_id == -1) 
	return -1; // file couldn't be opened
      file_id = Hopen((const char *)fileName, DFACC_RDWR, 0);
    }
    else if( flags==" R" || flags[0]=='R' || flags[0]=='r' )
    {
/* check if it is possible to open the file */
      accessMode=read;
      sd_id   = SDstart((const char *)fileName, DFACC_READ);
      if (sd_id == -1) 
	return -1; // file couldn't be opened
      file_id = Hopen((const char *)fileName, DFACC_READ, 0);
    }
    else
    {
      cout << "HDF_DataBase:mount: unknown flags = " << (const char *)flags << endl;
      return 2;
    }
    if( sd_id <= 0 )
    {
      // cout << "HDF_DataBase:mount:ERROR: unable to open an old file = " << (const char *)fileName << endl;
      return -1;
    }	
    if( file_id<=0 ) 
    {
      printf("HDF_DataBase::mount:ERROR return from Hopen file_id=%i\n",file_id);
      assert( file_id > 0 );
    }

    // attach the root -- here we assume that it is the first vgroup in file *****
    Vstart(file_id);
    int32 ref = -1;
    ref = Vgetid(file_id,ref);
    breakReference();  // this will create a new rcData
    rcData->vgroup_id = Vattach(file_id, ref, (accessMode==write ? "w" : "read" )); 
    if( rcData->vgroup_id <= 0 )
    {
      cout << "HDF_DataBase::mount: There is no `root' directory in this dataBase file!\n";
      cout << "                     The data base is not valid. Maybe it was not closed properly\n";
      return 1;
    }
  }
  return 0;
}

int HDF_DataBase:: 
isNull() const
//======================================================================================
// /Description: Return TRUE if the dataBase is not pointing to a valid directory,
//    FALSE otherwise. 
//======================================================================================
{
  return file_id <= 0 ;
}


int HDF_DataBase:: 
unmount() 
//=============================================================================
// /Description:
//   Flush all the data to the file and close it.
//=============================================================================
{
  assert(rcData!=NULL);
  // assert( file_id > 0 && sd_id > 0 );
  if( file_id<=0 ) 
  {
    printf("HDF_DataBase::unmount:ERROR file_id=%i\n",file_id);
    assert( file_id > 0 );
  }

  if( dataBaseBuffer!=NULL )
    closeStream();    // flush any stream buffers
    
  // remove all vgroups in reverse order
  int length = dbList->getLength();
  for( int i=length-1; i>=0; i-- )
  {
    if( (*dbList)[i].vgroup_id > 0 )
    {
      if( debug & 2 )
	cout << "close: vgroup_id =" << (*dbList)[i].vgroup_id << endl;
      Vdetach((*dbList)[i].vgroup_id);
      (*dbList)[i].vgroup_id=-1;
    }
    else
    {
      // This is ok if the dataBase was mounted and unmounted more than once and there are
      // still leftover's in the list
      // cout << "HDF_DataBase:unmount: consistency error, a vgroup_id <=0 in the list!\n";
      // throw "HDF_DataBase:unmount: consistency error, a vgroup_id <=0 in the list!\n";
    }
  }
  Vend(file_id);

  // Close the HDF file. 
  Hclose(file_id);
  SDend(sd_id); 
  file_id=sd_id=-1;

  delete referenceCountingList;
  referenceCountingList=NULL;

  return 0;
}

int HDF_DataBase:: 
flush() 
//=============================================================================
// /Description:
//   Flush all the data to the file
// *** this doesn't seem to work **** may have to close the file and reopen
//=============================================================================
{
  assert(rcData!=NULL);
  // assert( file_id > 0 && sd_id > 0 );
  if( file_id<=0 || sd_id<=0 ) 
  {
    printf("HDF_DataBase::flush:ERROR file_id=%i sd_id=%i\n",file_id,sd_id);
    assert( file_id > 0 && sd_id > 0 );
  }

  if( debug & 2)
    cout << "HDF_DataBase::flush the file\n";

  if( dataBaseBuffer!=NULL )
    closeStream();    // flush any stream buffers

  // dettach and attach all the open vgroups -- this should flush the data
  int length = dbList->getLength();
  int32 *vgroup_ref = new int32[length+1];
  int i;
  for( i=length-1; i>=0; i-- )
  {
    if( (*dbList)[i].vgroup_id > 0 )
    {
      vgroup_ref[i] = VQueryref((*dbList)[i].vgroup_id);
      if( vgroup_ref[i] <= 0 )
      {
        cout << " HDF_DataBase::flush:ERROR computing vgroup_ref = " << vgroup_ref[i] << endl;
        throw "error";
      }
      if( debug & 2 )
	cout << "flush: vgroup_ref = " << vgroup_ref[i] << ", vgroup_id =" << (*dbList)[i].vgroup_id << endl;
      Vdetach((*dbList)[i].vgroup_id);
      // ******* open again *****
      // (*dbList)[i].vgroup_id=Vattach(file_id,vgroup_ref[i],(accessMode==read ? "r" : "w"));
    }
  }
  // end vgroup access, then start again
  Vend(file_id);

  HDflush(file_id); // *** this doesn't seem to work
  Hsync(file_id);
  
  Vstart(file_id);
  for( i=length-1; i>=0; i-- )
  {
    if( (*dbList)[i].vgroup_id > 0 )
    {
      // ******* open again *****
      (*dbList)[i].vgroup_id=Vattach(file_id,vgroup_ref[i],(accessMode==read ? "r" : "w"));
    }
  }
  delete [] vgroup_ref;
  return 0;
}

int HDF_DataBase:: 
getID() const
//=====================================================================================
// /Description: 
//   Get the identifier for this directory. For HDF files this is the reference number.
//=====================================================================================
{
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 || rcData->vgroup_id<=0  ) 
  {
    printf("HDF_DataBase::getID:ERROR file_id=%i sd_id=%i rcData->vgroup_id=%i\n",file_id,sd_id,rcData->vgroup_id);
    assert( file_id > 0 && sd_id > 0 && rcData->vgroup_id > 0 );
  }
  int32 ref= VQueryref(rcData->vgroup_id);

  return ref;
}


int HDF_DataBase:: 
create(GenericDataBase & db0, const aString & name, const aString & dirClassName ) 
//=============================================================================
// /Description:
//   create a sub-directory
// /name (input): name of the sub-directory
//   If name="." then the current directory will be returned.
// /dirClassName (input): name of the class for the directory, default="directory"
// /return value: is 0 is the directory was successfully created, 1 otherwise
//=============================================================================
{
  
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 )
  {
    printf("HDF_DataBase::create:ERROR file_id=%i sd_id=%i\n",file_id,sd_id);
    assert( file_id > 0 && sd_id > 0 );
  }
  if( accessMode!=write )
  {
    cout << "HDF_DataBase:ERROR: cannot createDir on a read-only dataBase \n";
    throw  "HDF_DataBase:ERROR: cannot createDir on a read-only dataBase ";
  }    

  // cast to this derived type
  if( db0.className!="HDF_DataBase" )
  {
    cout << "HDF_DataBase:ERROR: create - input type is not HDF_DataBase\n";
    throw "HDF_DataBase:ERROR: create - input type is not HDF_DataBase";
  }
  HDF_DataBase & db = (HDF_DataBase &) db0;

  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers

  // Create a Vgroup.
  db=*this;  // initialize
  if( name=="." || mode==streamOutputMode )
    return 0;

  db.breakReference();  // this will create a new rcData
  db.rcData->vgroup_id = Vattach(file_id, -1, "w"); 
  if( db.rcData->vgroup_id <= 0 )
  {
    cout << "HDF_DataBase:create: fatal error in creating a new directory! \n";
    throw "HDF_DataBase:create: fatal error in creating a new directory! \n";
  }    
  // Set the name and class for this Vgroup. 
  int32 istat=Vsetname(db.rcData->vgroup_id, (const char *)name);
  if( istat==FAIL )
  { 
    printf("HDF_DataBase::create sub directory: ERROR return from Vsetname\n"); 
    return 1; 
  } 
  istat=Vsetclass(db.rcData->vgroup_id,(const char *)dirClassName);
  if( istat==FAIL )
  { 
    printf("HDF_DataBase::create sub directory: ERROR return from Vsetclass\n"); 
    return 1; 
  } 

  // Insert the sub-directory into "this" directory. 
  istat=Vinsert(rcData->vgroup_id, db.rcData->vgroup_id);
  if( istat==FAIL )
  { 
    printf("HDF_DataBase::create sub directory: ERROR return from Vinsert\n"); 
    return 1; 
  } 

  return 0;
}

int HDF_DataBase:: 
find(GenericDataBase & db, const aString & name, const aString & dirClassName ) const
//=============================================================================
// /Description:
//   find a sub-directory with a given name and class-name (optional)
//   If name="." then the current directory will be returned.
//   This function will "crash" if the sub-directory was not found. Use
//   locate if you don't want the function to crash.
// /name (input): name of the sub-directory
// /dirClassName (input): name of the class for the directory, default="directory"
// /return value: is 0 is the directory was found, 1 otherwise
//=============================================================================
{
  int returnValue;
  returnValue = locate(db,name,dirClassName);
  if( returnValue!=0 )
  {
    cout << "FindDir:ERROR: unable to find directory " << (const char *) name << endl;
    throw "FindDir:ERROR: unable to find directory ";
  }
  return returnValue;
}

int HDF_DataBase:: 
locate(GenericDataBase & db0, const aString & name, const aString & dirClassName ) const
//=============================================================================
// /Description:
//   locate a sub-directory with a given name and class-name (optional)
//   If name="." then the current directory will be returned.
// /name (input): name of the sub-directory
// /dirClassName (input): name of the class for the directory, default="directory"
// /return value: is 0 is the directory was found, 1 otherwise
//   See also the find function.
//=============================================================================
{
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 )
  {
    printf("HDF_DataBase::locate:ERROR file_id=%i sd_id=%i\n",file_id,sd_id);
    assert( file_id > 0 && sd_id > 0 );
  }

  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers

  // cast to this derived type
  if( db0.className!="HDF_DataBase" )
  {
    cout << "HDF_DataBase:ERROR: create - input type is not HDF_DataBase\n";
    throw "HDF_DataBase:ERROR: create - input type is not HDF_DataBase";
  }
  HDF_DataBase & db = (HDF_DataBase &) db0;
  db=*this; // initialize
  if( name=="." || mode==streamInputMode )
    return 0;

  // get the total number of tag/reference pairs in the vgroup
  int npairs = Vntagrefs(rcData->vgroup_id);
  int32 tag, ref;
  char vname[VGNAMELENMAX], cname[VGNAMELENMAX];
  int found=FALSE;
  for( int i=0; i<npairs; i++ )
  {
    // get tag and ref
    int status = Vgettagref(rcData->vgroup_id, i, &tag, &ref );
    if( debug & 2 )
      printf(" findDir i=%i, tag=%i, ref=%i\n", i,tag,ref);
    if( Visvg(rcData->vgroup_id,ref) )
    {
      // this is a vgroup
      int vgID = Vattach(file_id,ref,(accessMode==read ? "r" : "w") );
      Vgetname(vgID,vname);
      Vgetclass(vgID,cname);
      if( debug & 2 )
      {
        printf(" findDir vname = [%s], class= [%s]\n",vname,cname);
        printf(" findDir  name = [%s], dirClassName= [%s]\n",(const char*)name,(const char*)dirClassName);
      }
      if( name==vname && (dirClassName=="directory" || dirClassName==cname) )
      {
        // check if this vgroup is already in the dbList:
        int length = dbList->getLength();
        int foundInList=FALSE;
        for( int i=length-1; i>=0; i-- )
        {
          if( (*dbList)[i].vgroup_id==vgID )
	  {
            if( debug & 2 )
	      cout << "***find/locate(db): vgroup is already in the list!\n";
            if( db.rcData && db.rcData->decrementReferenceCount()==0 )
              db.destroy();
            db.rcData=&(*dbList)[i];  
            db.rcData->incrementReferenceCount();
            foundInList=TRUE;
	    break;
	  }
        }
        if( !foundInList )
	{
	  db.breakReference();
  	  db.rcData->vgroup_id=vgID;
	}
        if( debug & 2 )
	  cout << "findDir: item found: vgroup_id=" << db.rcData->vgroup_id << endl;
	found=TRUE;
	break;
      }
      else
        Vdetach(vgID);
    }
  }
  if( !found )
  {
    if( debug & 1 )
      cout << "FindDir:ERROR: unable to find directory " << (const char *) name << endl;
    return 1;
  }
  return 0;
}

int HDF_DataBase::
find(aString *nameOut, const aString & dirClassName, const int & maxNumber, int & actualNumber) const
// ====================================================================================================
// /Description:
//   Find all objects with the given class name in this directory.
// 
// See comments in GenericDataBase.C
// ====================================================================================================
{
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 )
  {
    printf("HDF_DataBase::find:ERROR file_id=%i sd_id=%i\n",file_id,sd_id);
    assert( file_id > 0 && sd_id > 0 );
  }

  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers

  // get the total number of tag/reference pairs in the vgroup
  int npairs = Vntagrefs(rcData->vgroup_id);
  int32 tag, ref;
  char cname[VGNAMELENMAX], name[VGNAMELENMAX];
  int numberFound=0, numberSaved=0;
  for( int i=0; i<npairs; i++ )
  {
    int found=FALSE;
    // get tag and ref
    int status = Vgettagref(rcData->vgroup_id, i, &tag, &ref );
    if( debug & 2 )
      printf(" findDir npairs=%i, i=%i, tag=%i, ref=%i\n", npairs,i,tag,ref);
    
    if( tag==DFTAG_NDG ) // Numeric Data Group -- should be an A++ array 
    { 
      // get index (which SDS in the file 0,1,2,...)  
      int32 sds_index=SDreftoindex(sd_id,ref); 
      // select this SDS and get identifier  
      int32 sds_id=SDselect(sd_id,sds_index); 

      int32 rank, dims[MAX_VAR_DIMS], numberType, nattrs;
      status = SDgetinfo(sds_id, name, &rank, dims, &numberType, &nattrs); 
      if( (dirClassName=="intArray"    && numberType==DFNT_INT32   ) ||
          (dirClassName=="floatArray"  && numberType==DFNT_FLOAT32 ) ||
          (dirClassName=="doubleArray" && numberType==DFNT_FLOAT64 ) )
      {
        // double check that this is an A++ array, it will have the following attribute:
        int32 attr_index = SDfindattr(sds_id,(char *)"arrayBase");
	if( attr_index >= 0 )
	{
          found=TRUE;
          if( debug & 2 )
   	    cout << "find( *name ): item found: (Numeric Data Group), name=" << name << endl;
	}
	else
	{
          cout << "HDF_DataBase:find(*name,...) : WARNING: file contains a Scientific Data set " <<
	    "that is not an A++ array, name=" << name << endl;
	}
      }
      int32 status = SDendaccess(sds_id);
    }
    else if( tag==DFTAG_VH ) //  Vdata Header  -- this could be an int/float/double or string
    { // this is a VDATA
      int vdataID = VSattach(file_id,ref,"r");
      VSgetclass(vdataID,cname);
      if( dirClassName==cname )
      {
	found=TRUE;
	VSgetname(vdataID,name);
	if( debug & 2 )
	  cout << "find( *name ): item found: class = " << cname << ", name=" << name << endl;
      }
      VSdetach(vdataID);
    }
    else if( tag==DFTAG_VG ) // Vgroup
    {
      int vgID = Vattach(file_id,ref,"r"); 
      Vgetclass(vgID,cname);
      if( debug & 2 )
      {
	Vgetname(vgID,name);
	printf(" find( *name ): cname = %s, name=%s\n",cname,name);
      }
      if( dirClassName==cname ) // ***************** special checks needed for "floatArray" , "int" ...
      {
        found=TRUE;
	Vgetname(vgID,name);
	if( debug & 2 )
	  cout << "find( *name ): item found: vgroup_id=" << vgID << endl;
      }
      Vdetach(vgID);
    }
    else
    {
      cout << "HDF_DataBase:find(*name,...) : WARNING: unknown item in file, tag= " << tag << endl;
    }
    if( found )
    { // save name in the list
      numberFound++;
      if( numberFound<=maxNumber )
      { 
	nameOut[numberSaved]=name;  // save the name
	numberSaved++;
      }
    }
  }
  actualNumber=numberFound;
  return numberSaved;
}



int HDF_DataBase::
find(GenericDataBase *dbOut, aString *nameOut, const aString & dirClassName, 
                      const int & maxNumber, int & actualNumber) const
// =====================================================================================
// /Description:
//   Find all sub-directories with a given dirClassName
//
//  /dbOut (input/output): return directories found in this array. You must allocate
//     at least maxNumber directories in dbOut, for example with if maxNumber=10 you
//     could say
//     \begin{verbatim}
//         HDF_DataBase dbOut[10];
//     \end{verbatim}
//  /nameOut : array of Strings to hold the names of the directories. You must allocate at
//     least maxNumber Strings in this array.
//  /maxNumber (input): this is the maximum number of directories that 
//         can be stored in dbOut[]. 
//  /actualNumber (output): This is the actual number of directories
//         that exist.
//  /return value:  The number of directories that were saved in the db array.
//
// /Description:
//   To first determine the number of sub-directories with the given dirClassName that exist 
//    make a call with maxNumber=0. Then allocate db[actualNumber] and call again.
//    
// =====================================================================================
{
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 )
  {
    printf("HDF_DataBase::find:ERROR file_id=%i sd_id=%i\n",file_id,sd_id);
    assert( file_id > 0 && sd_id > 0 );
  }

  if( dbOut->className!="HDF_DataBase" )
  {
    cout << "HDF_DataBase:findDir:ERROR the arg GenericDataBase *db does not point to `HDF_DataBase'! \n";
    throw "HDF_DataBase:findDir:ERROR";
  }
  HDF_DataBase *db = (HDF_DataBase *)dbOut;
  
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers

  // get the total number of tag/reference pairs in the vgroup
  int npairs = Vntagrefs(rcData->vgroup_id);
  int32 tag, ref;
  char cname[VGNAMELENMAX], name[VGNAMELENMAX];
  int numberFound=0, numberSaved=0;
  for( int i=0; i<npairs; i++ )
  {
    // get tag and ref
    int status = Vgettagref(rcData->vgroup_id, i, &tag, &ref );
    if( debug & 2 )
      printf(" find(*db): npairs=%i, i=%i, tag=%i, ref=%i\n", npairs,i,tag,ref);
      
    if( Visvg(rcData->vgroup_id,ref) ) // is this a vgroup
    { 
      int vgID = Vattach(file_id,ref,(accessMode==read ? "r" : "w")); 
      Vgetclass(vgID,cname);
      if( debug & 2 )
      {
        printf(" find(*db): cname = %s \n",cname);
      }
      if( dirClassName==cname )
      {
	Vgetname(vgID,name);
        if( debug & 2 )
	  printf("find(*db): item found: name=%s, vgroup_id=%i \n",name,vgID);

        numberFound++;
	if( numberFound<=maxNumber )
	{ // save the data base
          nameOut[numberSaved]=name;  // save the name
	  // check if this vgroup is already in the dbList:
          HDF_DataBase & db0 = db[numberSaved];
          db0=*this; // initialize
          int foundInList=FALSE;
	  int length = dbList->getLength();
	  for( int i=length-1; i>=0; i-- )
	  {
	    if( (*dbList)[i].vgroup_id==vgID )
	    {
              if( debug & 2 )
	        cout << "***findDir's: vgroup is already in the list!\n";
               
	      if( db0.rcData && db0.rcData->decrementReferenceCount()==0 )
		db0.destroy();
	      db0.rcData=&(*dbList)[i];  
              db0.rcData->incrementReferenceCount();
	      foundInList=TRUE;
	      break;
	    }
	  }
	  if( !foundInList )
	  {
  	    db0.breakReference();
  	    db0.rcData->vgroup_id=vgID;
	  }
	  numberSaved++;
	}
        else
          Vdetach(vgID);
      }
      else
        Vdetach(vgID);
    }
  }
  actualNumber=numberFound;
  return numberSaved;
}

int HDF_DataBase::
build(GenericDataBase & db0, int id)
//=====================================================================================
// /Description: 
//    Build a directory with the given ID, such as that returned by the member function {\tt getID()}.
// /db0 (output) : on output a data base that points to the directory with reference number equal to "id".
// /id (input) : build a directory for this identifier.
//=====================================================================================
{
  // *** looks like we should use the "ref" number as the directory ID
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 )
  {
    printf("HDF_DataBase::build:ERROR file_id=%i sd_id=%i\n",file_id,sd_id);
    assert( file_id > 0 && sd_id > 0 );
  }

  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers

  // cast to this derived type
  if( db0.className!="HDF_DataBase" )
  {
    cout << "HDF_DataBase:ERROR: create - input type is not HDF_DataBase\n";
    throw "HDF_DataBase:ERROR: create - input type is not HDF_DataBase";
  }
  HDF_DataBase & db = (HDF_DataBase &) db0;
  db=*this; // initialize

  int32 ref=id;
  int vgID = Vattach(file_id,ref,(accessMode==read ? "r" : "w") );

  // check if this vgroup is already in the dbList:
  int length = dbList->getLength();
  int foundInList=FALSE;
  for( int i=length-1; i>=0; i-- )
  {
    if( (*dbList)[i].vgroup_id==vgID )
    {
      if( debug & 2 )
	cout << "***build: vgroup is already in the list!\n";
      if( db.rcData && db.rcData->decrementReferenceCount()==0 )
	db.destroy();
      db.rcData=&(*dbList)[i];  
      db.rcData->incrementReferenceCount();
      foundInList=TRUE;
      break;
    }
  }
  if( !foundInList )
  {
    // attach a vgroup with a given ID
    // int vgID = Vattach(file_id,ref,(accessMode==read ? "r" : "w") );
    db.breakReference();
    db.rcData->vgroup_id=vgID;
  }

  return 0;
}


void HDF_DataBase::
closeStream() const
// this is not really a const function
{
  
  HDF_DataBase & db = (HDF_DataBase & )(*this);  // cast away const

// *wdh* 000925  if( dataBaseBuffer==NULL ||  !dataBaseBuffer->isOpen() )
  if( dataBaseBuffer==NULL ||  !dataBaseBuffer->isOpen() || !bufferWasCreatedInThisDirectory )
    return;
  if( mode!=normalMode )
  {
    cout << "HDF_DataBase::closeStream: error: you should be in normalMode to close the stream buffers\n";
    throw "error";
  }
  if( HDF_DataBase::debug & 1 )
    printf("HDF_DataBase::closeStream: close the stream buffers: db.dataBaseBuffer=%d \n",db.dataBaseBuffer);
  // close and de-allocate buffers
  db.mode=bufferMode;
  db.dataBaseBuffer->closeBuffer(db); 
  delete db.dataBaseBuffer;
  db.dataBaseBuffer=NULL;
  db.mode=normalMode;

}

void HDF_DataBase::
setMode(const InputOutputMode & mode_ /* =normalMode */)
//=====================================================================================
//    
// /Description:
//   Set the input-output mode for the data base.
// /mode\_ (input) : input-output mode, {\tt normalMode}, {\tt streamInputMode}, 
//  {\tt streamOutput}, or {\tt noStreamMode}. In {\tt normalMode} the data is saved in the standard
//   hierarchical manner. In {\tt streamInputMode}/{\tt streamOutputMode} mode the
//   data is input/output continuguously from/into a buffer. The name of the object is ignored and
//   the act of creating new directories is ignored. In stream mode the data must be read back 
//   in in exactly the order it was written. In {\tt noStreamMode}
//   any requests to change to  {\tt streamInputMode} or {\tt streamOutputMode} will be ignored. This can
//   be used to suggest that no streaming should be done. To overide this mode you must first set the
//   mode to {\tt normalMode} and then you can change the mode to a streaming mode.
//=====================================================================================
{
  if( mode==mode_ || (mode==noStreamMode && mode_!=normalMode) )
    return;

  if( mode_==bufferMode )
  {
    mode=mode_;
    return;
  }

  if( dataBaseBuffer==NULL )
  {
    dataBaseBuffer= new DataBaseBuffer;
    bufferWasCreatedInThisDirectory=TRUE;
  }

  InputOutputMode oldMode =mode;
  if( mode_!=oldMode )
  {
    if( mode_==streamOutputMode )
    {
      // open new buffers
      mode=bufferMode;
      dataBaseBuffer->openBuffer(*this,mode_);
    }
    else if( mode_==streamInputMode )
    {
      // get existing buffers
      mode=bufferMode;
      dataBaseBuffer->openBuffer(*this,mode_); // we should be in normalMode for this get
    }
    else if( mode_==normalMode )
    {
      if( !bufferWasCreatedInThisDirectory && (oldMode==streamOutputMode || oldMode==streamInputMode) )
      {
	cout << "HDF_DataBase::setMode:ERROR: attempt to set mode back to normalMode from streamOutputMode or \n"
             << " streamInputMode BUT this directory did not originally set the mode! \n";
	cout << "  ...this could cause fatal errors, continuing anyway... \n";
      }
      // close and de-allocate buffers
      mode=normalMode;   // change the mode so we can put arrays in normal way
      closeStream();
    }
    mode=mode_;
  }
  
}


// number of array dimensions for A++
#define NUM_APP_DIMS 4
#undef PUT


//=====================================================================================
// /Description: Save an A++ array in the data-base. The array is saved as an HDF
// Scientific Data Set.
// /x (input): array to save
// /name (input): save the array with this name.
//
// Define a macro to save a float/int/double A++ Array
//  type=floatArray/intArray/doubleArray HDFType=corresponding HDF type
// ========================================================================================
#beginMacro PUTARRAY(type,serialType,HDFType,putName)  
int HDF_DataBase::  
putName( const type & x_, const aString & name )  
{  
  #If #type eq #serialType
    const type & x = x_;
  #Else
    // For parallel arrays we save the data without ghost points
    // we assume that the data lives on one processor.
    const int myid = max(0,Communication_Manager::My_Process_Number);
    if( myid!=0 )
    {
      printf("HDF_DataBase::put:type: ERROR: put called for a processor number not equal to zero!\n");
      throw "error";
    }
    const serialType & xLocal = x_.getLocalArray();  // this is a view
    serialType x;
    x=xLocal;      // this will now hold contiguous data that we can save
  #End

  assert(rcData!=NULL); 
  if( file_id<=0 || sd_id<=0 ) 
  { 
    printf("HDF_DataBase::put(type,name):ERROR file_id=%i sd_id=%i name=%s\n",file_id,sd_id,(const char*)name); 
    assert( file_id > 0 && sd_id > 0 ); 
  } 
  if( accessMode!=write )  
  {  
    cout << "HDF_DataBase:ERROR:put: cannot put an array to a read-only file, name ="   
         << (const char*) name << endl;  
    return 1;  
  }  
  if( mode==streamOutputMode ) 
  { 
    /* save in the stream buffer */ 
    int dims[NUM_APP_DIMS][2]; 
    int size=1; 
    for( int d=0; d<NUM_APP_DIMS; d++) 
    { 
      dims[d][0]=x.getBase(d); 
      dims[d][1]=x.getBound(d);  
      size*=(dims[d][1]-dims[d][0]+1);  
    } 
    dataBaseBuffer->putToBuffer( NUM_APP_DIMS*2, dims[0] ); 
    dataBaseBuffer->putToBuffer( size,x.getDataPointer() ); 
    return 0; 
  } 
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) ) 
    closeStream();    /* flush any stream buffers */ 
  
  int32 dims[NUM_APP_DIMS], rank, start[NUM_APP_DIMS], edges[NUM_APP_DIMS], base[NUM_APP_DIMS];  
  rank=NUM_APP_DIMS;  
  for( int n=0; n<NUM_APP_DIMS; n++ )  
  {  
    dims[n]=x.getLength(n);  
    start[n]=0;  
    edges[n]=dims[n];  
    base[n]=x.getBase(n);  
  }  
  /* to prevent a seg fault for a null array we create an SDS with 1 element, rank=1 */ 
  /* the seg fault seems to be generated when all the dims=0 in the SDcreate statement */ 
  SDsetfillmode(sd_id,SD_NOFILL); /* no need to initialize array */ 
  int32 sds_id, istat; 
  if( dims[0] > 0 && dims[1] > 0 && dims[2] > 0 && dims[3] > 0 )                       
  {   
    /* create the array */  
    sds_id = SDcreate(sd_id,(char*)((const char *)name),HDFType,rank,dims);  
    if( sds_id==FAIL ) 
    {  
      printf("HDF_DataBase::put(A++ array): ERROR return from SDCreate\n"); 
      return 1; 
    } 
    istat = SDwritedata(sds_id,start, NULL, edges,(unsigned char*)(x.getDataPointer()));  
    if( istat==FAIL ) 
    {  
      printf("HDF_DataBase::put(A++ array): ERROR return from SDwritedata\n"); 
      return 1; 
    } 
  }
  else  
  { 
    rank=1; dims[0]=1; 
    /* create the array */  
    sds_id = SDcreate(sd_id,(char*)((const char *)name),HDFType,rank,dims);  
    if( sds_id==FAIL ) 
    {  
      printf("HDF_DataBase::put(A++ array): ERROR return from SDCreate\n"); 
      return 1; 
    } 
  } 
   /* only use new way of saving dimensions -- this save space */ 
  for( int r=0; r<rank; r++ ) 
  { 
    int32 dimID=SDgetdimid(sds_id,r); /* get id for dimension r */ 
    if( dimID==FAIL ) printf(" +++put:ERROR getting dimension id \n"); 
    SDsetdimval_comp(dimID,SD_DIMVAL_BW_INCOMP); 
  }
 /* Save array lower bounds */  
  istat =SDsetattr(sds_id,(char*)"arrayBase", DFNT_INT32, NUM_APP_DIMS, base );  
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put(A++ array): ERROR return from SDsetattr\n"); 
    return 1; 
  } 
  /* Insert the sds into the Vgroup.  */  
  int32 ref = SDidtoref(sds_id);  
  if( ref<0 ) 
  {  
    printf("HDF_DataBase::put(A++ array): ERROR return from  SDidtoref\n"); 
    return 1; 
  } 
  istat=Vaddtagref(rcData->vgroup_id, DFTAG_NDG, ref );   
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put(A++ array): ERROR return from Vaddtagref\n"); 
    return 1; 
  } 
  /* terminate access to the array */  
  istat = SDendaccess(sds_id);  
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put(A++ array): ERROR return from SDendaccess\n"); 
    return 1; 
  } 
  return 0;  
}
#endMacro

// now declare instances of the macro
PUTARRAY(floatSerialArray,floatSerialArray,DFNT_FLOAT32,put)
PUTARRAY(intSerialArray,intSerialArray,DFNT_INT32,put)
PUTARRAY(doubleSerialArray,doubleSerialArray,DFNT_FLOAT64,put)

PUTARRAY(floatArray,floatSerialArray,DFNT_FLOAT32,putDistributed)
PUTARRAY(intArray,intSerialArray,DFNT_INT32,putDistributed)
PUTARRAY(doubleArray,doubleSerialArray,DFNT_FLOAT64,putDistributed)

//=====================================================================================  
// /Description: get an A++ array from the data-base.   
// /x (output): the array to get. This array will be redim'd to have the  
//   correct dimensions (base and bound).  
// /name (input): the name of the array in the data-base  
//=====================================================================================  
// Define a macro to get a float/int/double A++ Array
//  type=floatArray/intArray/doubleArray HDFType=corresponding HDF type
#beginMacro GETARRAY(type,serialType,HDFType,getName)  
int HDF_DataBase::  
#If #type eq "floatArray" || #type eq "intArray" || #type eq "doubleArray"
getName( type & x, const aString & name )  const 
#Else
getName( type & x, const aString & name, Index *Iv )  const 
#End
{  
  assert(rcData!=NULL); 
  if( file_id<=0 || sd_id<=0 ) 
  { 
    printf("HDF_DataBase::get(type,name):ERROR file_id=%i sd_id=%i name=%sn",file_id,sd_id,(const char*)name); 
    assert( file_id > 0 && sd_id > 0 ); 
  } 
  if( mode==streamInputMode )  
  {  
    /* get from the stream buffer */ 
    int dims[NUM_APP_DIMS][2];  
    dataBaseBuffer->getFromBuffer( NUM_APP_DIMS*2, dims[0] );  
    int size=1;  
    for( int d=0; d<NUM_APP_DIMS; d++)  
      size*=(dims[d][1]-dims[d][0]+1);  

    x.redim(Range(dims[0][0],dims[0][1]),  
            Range(dims[1][0],dims[1][1]),  
            Range(dims[2][0],dims[2][1]),  
            Range(dims[3][0],dims[3][1]));  
    #If #type eq #serialType
      dataBaseBuffer->getFromBuffer( size,x.getDataPointer() );  
    #Else
      // For distributed arrays we read the whole array into a temporary location and then copy the
      // appropriate portion to the local array
      Range S0(dims[0][0],dims[0][1]);
      Range S1(dims[1][0],dims[1][1]);
      Range S2(dims[2][0],dims[2][1]);
      Range S3(dims[3][0],dims[3][1]);
      serialType xs(S0,S1,S2,S3);
// parse error on next line with gcc 3.3.2 ???
//        serialType xs(Range(dims[0][0],dims[0][1]),  
//                      Range(dims[1][0],dims[1][1]),  
//                      Range(dims[2][0],dims[2][1]),  
//                      Range(dims[3][0],dims[3][1])); 
      dataBaseBuffer->getFromBuffer( size,xs.getDataPointer() );  
      const serialType & xLocal = x.getLocalArrayWithGhostBoundaries();

      Range R1(max(dims[0][0],xLocal.getBase(0)),min(dims[0][1],xLocal.getBound(0)));
      Range R2(max(dims[1][0],xLocal.getBase(1)),min(dims[1][1],xLocal.getBound(1)));
      Range R3(max(dims[2][0],xLocal.getBase(2)),min(dims[2][1],xLocal.getBound(2)));
      Range R4(max(dims[3][0],xLocal.getBase(3)),min(dims[3][1],xLocal.getBound(3)));

      xLocal(R1,R2,R3,R4)=xs(R1,R2,R3,R4);

      // xLocal.display("HDF_DB: xLocal after get");

    #End

    return 0;  
  }  
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) ) 
    closeStream();    /* flush any stream buffers */ 
  /*  get the total number of tag/reference pairs in the vgroup */  
  int npairs = Vntagrefs(rcData->vgroup_id);  
  int32 tag, ref, rank, nt, dims[MAX_VAR_DIMS], nattrs;  
  int32 start[MAX_VAR_DIMS], edges[MAX_VAR_DIMS], base[MAX_VAR_DIMS];  
  char sd_name[MAX_NC_NAME];  
  int found=FALSE;  
  int i;   
  for( i=0; i<npairs; i++ )  
  {  
    /* get tag and ref */  
    int status = Vgettagref(rcData->vgroup_id, i, &tag, &ref );  
    if( debug & 2 )  
      printf(" getSDS: i=%i, tag=%i, ref=%in", i,tag,ref);  
    if( tag==DFTAG_NDG )  
    { /* this is a Numeric Data group */  
      /* get index (which SDS in the file 0,1,2,...)  */  
      int32 sds_index=SDreftoindex(sd_id,ref);  
      /* select this SDS and get identifier  */  
      int32 sds_id=SDselect(sd_id,sds_index);  
      status = SDgetinfo(sds_id, sd_name, &rank, dims, &nt, &nattrs);  
      if( debug & 2 )  
        printf("SDgetinfo: name=%s, rank = %i, dims = %i, %i, %i, %in",sd_name,rank,  
	     dims[0],dims[1],dims[2],dims[3]);  
        
      if( name==sd_name )  
      {  
        found=TRUE;  
        /* --- we set rank=1 if the array was null for a put ---- */ 
        if( rank==NUM_APP_DIMS ) 
	{ 
          int n;  
  	  for( n=0; n<rank; n++ )  
	  {  
	    start[n]=0;  
	    edges[n]=dims[n];  
	  }  

          /* get base for arrays (set to zero if the attribute isn't there) : */  
          int32 attr_index = SDfindattr(sds_id,(char*)"arrayBase");  
          if( attr_index >= 0 )   
            SDreadattr(sds_id,attr_index,base);  
          else  
          {   
            for( n=0; n<NUM_APP_DIMS; n++ )  
              base[n]=0;  
	  }  
          if( debug & 2 )  
            printf("SDreadattr: attr_index=%i, base = %i, %i, %i, %in",attr_index, 
              base[0],base[1],base[2],base[3]);  
          #If #type eq #serialType
    	    x.redim(dims[0],dims[1],dims[2],dims[3]); /* ****** fix this for more dims **** */  
	    for( n=0; n<rank; n++ )  
              x.setBase(base[n],n);  
            /* now read in the array data */  
            status = SDreaddata(sds_id, start, NULL, edges,(unsigned char*)x.getDataPointer());   
          #Else
            // For distributed arrays we read the whole array into a temporary location and then copy the
            // appropriate portion to the local array

	    Range S0(base[0],base[0]+dims[0]-1);
	    Range S1(base[1],base[1]+dims[1]-1);
	    Range S2(base[2],base[2]+dims[2]-1);
	    Range S3(base[3],base[3]+dims[3]-1);
	    serialType xs(S0,S1,S2,S3);

// parse error here with gcc 3.2.2 ??
//              serialType xs(Range(base[0],base[0]+dims[0]-1),  
//                            Range(base[1],base[1]+dims[1]-1),  
//                            Range(base[2],base[2]+dims[2]-1),  
//                            Range(base[3],base[3]+dims[3]-1)); 

            status = SDreaddata(sds_id, start, NULL, edges,(unsigned char*)xs.getDataPointer()); 

            const serialType & xLocal = x.getLocalArrayWithGhostBoundaries();
      
            Range R1(max(S0.getBase(),xLocal.getBase(0)),min(S0.getBound(),xLocal.getBound(0)));
            Range R2(max(S1.getBase(),xLocal.getBase(1)),min(S1.getBound(),xLocal.getBound(1)));
            Range R3(max(S2.getBase(),xLocal.getBase(2)),min(S2.getBound(),xLocal.getBound(2)));
            Range R4(max(S3.getBase(),xLocal.getBase(3)),min(S3.getBound(),xLocal.getBound(3)));
      
            xLocal(R1,R2,R3,R4)=xs(R1,R2,R3,R4);
      
            // xLocal.display("HDF_DB: xLocal after get");
          #End

	}  
        status = SDendaccess(sds_id);  
        break;  
      }  
      status = SDendaccess(sds_id);  
    }  
  }  
  if( !found && issueWarnings )  
  {  
    cout << "get: ERROR searching for " << (const char *)name << endl;  
  }      
  return found ? 0 : 1;  
    
}
#endMacro

// now declare instances of the macro
GETARRAY(floatSerialArray,floatSerialArray,DFNT_FLOAT32,get)
GETARRAY(intSerialArray,intSerialArray,DFNT_INT32,get)
GETARRAY(doubleSerialArray,doubleSerialArray,DFNT_FLOAT64,get)

GETARRAY(floatArray,floatSerialArray,DFNT_FLOAT32,getDistributed)
GETARRAY(intArray,intSerialArray,DFNT_INT32,getDistributed)
GETARRAY(doubleArray,doubleSerialArray,DFNT_FLOAT64,getDistributed)

#undef GET

/* -----
int HDF_DataBase::
get( floatArray & x, const aString & name ) const
{
  // get the total number of tag/reference pairs in the vgroup
  int npairs = Vntagrefs(rcData->vgroup_id);
  int32 vdata_tag, vdata_ref;
  char vdata_name[VSNAMELENMAX];
  int found=FALSE;
  for( int i=0; i<npairs; i++ )
  {
    // get tag and ref
    int status = Vgettagref(rcData->vgroup_id, i, &vdata_tag, &vdata_ref );
    printf(" get: i=%i, tag=%i, ref=%i\n", i,vdata_tag,vdata_ref);
    if( Visvs(rcData->vgroup_id,vdata_ref) )
    { // this is a vdata
      // get identifier for vdata
      int32 vdata_id=VSattach(file_id,vdata_ref,"r");
      // get name of the vdata
      VSgetname(vdata_id,vdata_name);
      printf(" get: vdata_name = %s\n",vdata_name);
      if( name==vdata_name )
      {
        if( debug & 2 )
  	  cout << "get: item found! \n";
	found=TRUE;
	int32 n_records;
	VSQuerycount( vdata_id, &n_records );
	printf(" get: n_records=%i \n",n_records);
	x.redim(n_records);
	VSread(vdata_id, (unsigned char*)x.getDataPointer(), n_records, FULL_INTERLACE );

        VSdetach(vdata_id);
        break;
      }
      VSdetach(vdata_id);
    }
  }
  if( !found )
  {
    cout << "get: ERROR searching for " << (const char *)name << endl;
  }    
  return found ? 0 : 1;
  
}

int HDF_DataBase::
put( const floatArray & x, const aString & name )
{
  // Create a Vdata to store the array values, set its name and class. 
  int32 vdata_id = VSattach(file_id, -1, "w");
  VSsetname(vdata_id, (const char *)name);
  VSsetclass(vdata_id, "floatArray");

  // Specify the Vdata data type, name and the order.  
  VSfdefine(vdata_id, (const char *)name, DFNT_FLOAT32, 1);  // order ??

  // Set the field names. 
  VSsetfields(vdata_id, (const char *)name);

  // Write the buffered data into the Vdata object. 
  int num=x.elementCount();
  VSwrite(vdata_id, (unsigned char*)(x.getDataPointer()), num, FULL_INTERLACE);

  // Insert the Vdata into the Vgroup. 
  Vinsert(rcData->vgroup_id, vdata_id);

  // Detach from the Vdata. 
  VSdetach(vdata_id);

  return 0;
}

----- */

// Define a macro to save either float/int/double
//  type=float/int/double HDFType=corresponding HDF type
//=====================================================================================  
// /Description: Save a type in the data-base. The type is saved as an HDF vdata.  
// /x (input): value to save.  
// /name (input): save the value with this name.  
// /Notes:
//    Save a float/int/double in a vdata. 
//=====================================================================================  
#undef PUT
#define PUT(type,HDFType) \
int HDF_DataBase::   \
put( const type & x, const aString & name )  \
{  \
  assert(rcData!=NULL); \
  if( file_id<=0 || sd_id<=0 ) \
  {\
    printf("HDF_DataBase::put(type,name):ERROR: file_id=%i and sd_id=%i when attempting to put name=%s\n",\
        file_id,sd_id,(const char*)name);\
    assert( file_id > 0 && sd_id > 0 );  \
  }\
  if( accessMode!=write ) \
  { \
    cout << "HDF_DataBase:ERROR:put: cannot put a float/double/int to a read-only file, name ="  \
         << (const char*) name << endl; \
    return 1; \
  } \
  if( mode==streamOutputMode ) \
  { \
    dataBaseBuffer->putToBuffer( 1,&x ); \
    return 0; \
  } \
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) ) \
    closeStream();    /* flush any stream buffers */ \
  /* Create a Vdata to store the array values, set its name and class. */   \
  int32 vdata_id = VSattach(file_id, -1, (accessMode==read ? "r" : "w"));   \
  if( vdata_id==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSattach\n"); \
    return 1; \
  } \
  int32 istat =VSsetname(vdata_id, (const char *)name);   \
  VSsetclass(vdata_id, #type );   \
  if( istat==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSsetclass\n"); \
    return 1; \
  } \
  /* Specify the Vdata data type, name and the order.  */     \
  istat=VSfdefine(vdata_id, (const char *)name, HDFType, 1);    \
  if( istat==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSdefine\n"); \
    throw "error"; \
    /* return 1;  */ \
  } \
  /* Set the field names.  */    \
  istat=VSsetfields(vdata_id, (const char *)name);   \
  if( istat==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSsetfields\n"); \
    return 1; \
  } \
  /* Write the buffered data into the Vdata object.  */    \
  int num=1;   \
  istat = VSwrite(vdata_id, (unsigned char*)(&x), num, FULL_INTERLACE);   \
  if( istat==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSwrite\n"); \
    return 1; \
  } \
  /* Insert the Vdata into the Vgroup.  */    \
  istat=Vinsert(rcData->vgroup_id, vdata_id);   \
  if( istat==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSinsert\n"); \
    return 1; \
  } \
  /* Detach from the Vdata. */  \
  istat=VSdetach(vdata_id);   \
  if( istat==FAIL ) \
  {  \
    printf("HDF_DataBase::put(" #type "): ERROR return from VSdetach\n"); \
    return 1; \
  } \
  return 0;   \
}

// now declare instances of the macro
PUT(float,DFNT_FLOAT32)
PUT(int,DFNT_INT32)
PUT(double,DFNT_FLOAT64)
#ifdef OV_BOOL_DEFINED
  PUT(bool,DFNT_INT32)
#endif
#undef PUT

// put a single aString:
int HDF_DataBase::   
put( const aString & x, const aString & name ) 
{  
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 ) 
  {
    printf("HDF_DataBase::put(aString,name):ERROR: file_id=%i and sd_id=%i when attempting to put name=%s\n",
        file_id,sd_id,(const char*)name);
    assert( file_id > 0 && sd_id > 0 );  
  }
  if( accessMode!=write ) 
  { 
    cout << "HDF_DataBase:ERROR:put: cannot put a float/double/int to a read-only file, name ="  
         << (const char*) name << endl; 
    return 1; 
  } 
  if( mode==streamOutputMode )
  {
    int num=x.length()+1;
    dataBaseBuffer->putToBuffer( 1,&num );   // save number of chars
    dataBaseBuffer->putToBuffer( num,(const char *)x ); 
    return 0;
  }
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers 
  /* Create a Vdata to store the array values, set its name and class. */   
  int32 vdata_id = VSattach(file_id, -1, (accessMode==read ? "r" : "w"));   
  if( vdata_id==FAIL )
  {  
    printf("HDF_DataBase::put( aString ): ERROR return from VSattach\n"); 
    return 1; 
  } 
  VSsetname(vdata_id, (const char *)name);   
  VSsetclass(vdata_id, "string" );   
  /* Specify the Vdata data type, name and the order.  */     
  VSfdefine(vdata_id, (const char *)name, DFNT_CHAR8, 1);    
  /* Set the field names.  */    
  VSsetfields(vdata_id, (const char *)name);   
  /* Write the buffered data into the Vdata object.  */    
  int num=x.length()+1;    // add one for '\0' terminator
  int32 istat = VSwrite(vdata_id, (unsigned char*)((const char *)x), num, FULL_INTERLACE);   
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put( aString ): ERROR return from VSwrite\n"); 
    return 1; 
  } 
  /* Insert the Vdata into the Vgroup.  */    
  istat = Vinsert(rcData->vgroup_id, vdata_id);   
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put( aString ): ERROR return from VSinsert\n"); 
    return 1; 
  } 
  /* Detach from the Vdata. */  
  istat = VSdetach(vdata_id);   
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put( aString ): ERROR return from VSdetach\n"); 
    return 1; 
  } 
  return 0;   
}

// put a "c" array of floats, int's or doubles

int HDF_DataBase::   
put( const int x[], const aString & name, const int number ) 
{  
//  intSerialArray a;
//  a.adopt(x,number); // this causes a leak (or else the number of A++ array increases)
  intSerialArray a(number);
  for( int i=0; i<number; i++ )
    a(i)=x[i];
  put(a,name);
  return 0;
}
int HDF_DataBase::   
put( const float x[], const aString & name, const int number ) 
{  
//  floatSerialArray a;
//  a.adopt(x,number);
  floatSerialArray a(number);
  for( int i=0; i<number; i++ )
    a(i)=x[i];
  put(a,name);
  return 0;
}
int HDF_DataBase::   
put( const double x[], const aString & name, const int number ) 
{  
//  doubleSerialArray a;
//  a.adopt(x,number);
  doubleSerialArray a(number);
  for( int i=0; i<number; i++ )
    a(i)=x[i];
  put(a,name);
  return 0;
}



//=================================================================================
// /Description:
//   Put an array of Strings.
// /x[] (input): array of Strings to save.
// /name (input): save the array under this name.
// /numberOfStrings (input): Save this many elements from the array.
// 
// /Notes:
//    The array of strings are concatenated together and saved in a vdata.
//=================================================================================
int HDF_DataBase::   
put( const aString x[], const aString & name, const int numberOfStrings ) 
{  
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 ) 
  {
    printf("HDF_DataBase::put(aString[],name):ERROR: file_id=%i and sd_id=%i when attempting to put name=%s\n",
        file_id,sd_id,(const char*)name);
    assert( file_id > 0 && sd_id > 0 );  
  }
  if( accessMode!=write ) 
  { 
    cout << "HDF_DataBase:ERROR:put: cannot put a float/double/int to a read-only file, name ="  
         << (const char*) name << endl; 
    return 1; 
  } 
  if( mode==streamOutputMode )
  {
    dataBaseBuffer->putToBuffer( 1,&numberOfStrings );   // save number of chars
    int i;
    for( i=0; i<numberOfStrings; i++ )
      put( x[i],"dummy");
    return 0;
  }
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    // flush any stream buffers 
  /* Create a Vdata to store the array values, set its name and class. */   
  int32 vdata_id = VSattach(file_id, -1, (accessMode==read ? "r" : "w"));   
  if( vdata_id==FAIL )
  {  
    printf("HDF_DataBase::put( aString ): ERROR return from VSattach\n"); 
    return 1; 
  } 
  VSsetname(vdata_id, (const char *)name);   
  VSsetclass(vdata_id, "string" );   
  /* Specify the Vdata data type, name and the order.  */     
  VSfdefine(vdata_id, (const char *)name, DFNT_CHAR8, 1);    
  /* Set the field names.  */    
  VSsetfields(vdata_id, (const char *)name);   
  /* Write the buffered data into the Vdata object.  */    
  // first concatenate all the strings together
  int num=0;
  int n;
  for( n=0; n<numberOfStrings; n++)
    num+=x[n].length()+1;  // add one for null terminator
  char *temp = new char[num];
  int j=0;
  for( n=0; n<numberOfStrings; n++)
  {
    for( int i=0; i<x[n].length(); i++ )
      temp[j++]=x[n][i];
    temp[j++]='\0';
  }
  if( debug & 2 )
    printf("Put aString[] number of chars = %i\n",num);
  int32 istat=VSwrite(vdata_id, (unsigned char*)((const char *)temp), num, FULL_INTERLACE);   
  delete [] temp;
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put( aString[] ): ERROR return from VSwrite\n"); 
    return 1; 
  } 
  
  /* Insert the Vdata into the Vgroup.  */    
  istat=Vinsert(rcData->vgroup_id, vdata_id);   
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put( aString[] ): ERROR return from VSinsert\n"); 
    return 1; 
  } 
  /* Detach from the Vdata. */  
  istat=VSdetach(vdata_id);   
  if( istat==FAIL ) 
  {  
    printf("HDF_DataBase::put( aString[] ): ERROR return from VSdetach\n"); 
    return 1; 
  } 
  return 0;   
}


// Define a macro to get either float/int/double
//  type=float/int/double HDFType=corresponding HDF type
//=====================================================================================  
// /Description: get a type from the data-base.   
// /x (input): value to get.   
// /name (input): name of the item.   
// /return value: 0 if the item was found, 1 otherwise.   
//=====================================================================================  
#undef GET
#define GET(type,HDFType) \
int HDF_DataBase::   \
get( type & x, const aString & name )  const  \
{   \
  assert(rcData!=NULL); \
  if( file_id<=0 || sd_id<=0 ) \
  {\
    printf("HDF_DataBase::get(type[],name):ERROR: file_id=%i and sd_id=%i when attempting to put name=%s\n",\
        file_id,sd_id,(const char*)name);\
    assert( file_id > 0 && sd_id > 0 );  \
  }\
  if( mode==streamInputMode ) \
  { \
    dataBaseBuffer->getFromBuffer( 1,&x ); \
    return 0; \
  } \
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )  \
    closeStream();    /* flush any stream buffers */  \
  /* get the total number of tag/reference pairs in the vgroup  */  \
  int npairs = Vntagrefs(rcData->vgroup_id);   \
  int32 vdata_tag, vdata_ref;   \
  char vdata_name[VSNAMELENMAX];   \
  int found=FALSE;   \
  int i;   \
  for( i=0; i<npairs; i++ )   \
  {   \
    /* get tag and ref  */  \
    int status = Vgettagref(rcData->vgroup_id, i, &vdata_tag, &vdata_ref );   \
    if( debug & 2 )   \
      printf(" get: i=%i, tag=%i, ref=%i\n", i,vdata_tag,vdata_ref);   \
    if( Visvs(rcData->vgroup_id,vdata_ref) )   \
    { /* this is a vdata  */  \
      /* get identifier for vdata   */ \
      int32 vdata_id=VSattach(file_id,vdata_ref,(accessMode==read ? "r" : "w"));   \
      /* get name of the vdata   */ \
      VSgetname(vdata_id,vdata_name);   \
      if( debug & 2 )   \
        printf(" get: vdata_name = %s\n",vdata_name);   \
      if( name==vdata_name )   \
      {   \
        if( debug & 2 )   \
	  cout << "get: item found! \n";   \
	found=TRUE;   \
	int32 n_records;   \
	VSQuerycount( vdata_id, &n_records );   \
        if( debug & 2 ) \
  	  printf(" get: n_records=%i \n",n_records);   \
	VSread(vdata_id, (unsigned char*)&x, n_records, FULL_INTERLACE );   \
   \
        VSdetach(vdata_id);   \
        break;   \
      }   \
      VSdetach(vdata_id);   \
    }   \
  }   \
  if( !found && issueWarnings )   \
  {   \
    cout << "get: ERROR searching for " << (const char *)name << endl;   \
  }       \
  return found ? 0 : 1;   \
     \
}

GET(float,DFNT_FLOAT32)
GET(int,DFNT_INT32)
GET(double,DFNT_FLOAT64)
#ifdef OV_BOOL_DEFINED
  GET(bool,DFNT_INT32)
#endif
#undef GET


int HDF_DataBase::   
get( aString & x, const aString & name )   const 
{   
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 ) 
  {
    printf("HDF_DataBase::get(aString,name):ERROR: file_id=%i and sd_id=%i when attempting to put name=%s\n",
        file_id,sd_id,(const char*)name);
    assert( file_id > 0 && sd_id > 0 );  
  }
  if( mode==streamInputMode )
  {
    int num;
    dataBaseBuffer->getFromBuffer( 1,&num );   // get number of chars
    char *temp = new char [num];
    dataBaseBuffer->getFromBuffer( num,temp ); 
    x=temp;
    delete [] temp;
    return 0;
  }
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    /* flush any stream buffers */ 
  /* get the total number of tag/reference pairs in the vgroup  */  
  int npairs = Vntagrefs(rcData->vgroup_id);   
  int32 vdata_tag, vdata_ref;   
  char vdata_name[VSNAMELENMAX];   
  int found=FALSE;   
  int i;
  for( i=0; i<npairs; i++ )   
  {   
    /* get tag and ref  */  
    int status = Vgettagref(rcData->vgroup_id, i, &vdata_tag, &vdata_ref );   
    if( debug & 2 )   
      printf(" get: i=%i, tag=%i, ref=%i\n", i,vdata_tag,vdata_ref);   
    if( Visvs(rcData->vgroup_id,vdata_ref) )   
    { /* this is a vdata  */  
      /* get identifier for vdata   */ 
      int32 vdata_id=VSattach(file_id,vdata_ref,(accessMode==read ? "r" : "w"));   
      /* get name of the vdata   */ 
      VSgetname(vdata_id,vdata_name);   
      if( debug & 2 )   
        printf(" get: vdata_name = %s\n",vdata_name);   
      if( name==vdata_name )   
      {   
        if( debug & 2 )   
	  cout << "get: item found! n";   
	found=TRUE;   
	int32 n_records;   
	VSQuerycount( vdata_id, &n_records );   
        if( debug & 1 ) 
  	  printf(" get: n_records=%i n",n_records);   
        char * temp = new char[n_records];
	VSread(vdata_id, (unsigned char*)temp, n_records, FULL_INTERLACE );   
        if( debug & 2 )
          printf("get(aString): temp = [%s] \n",temp);
        x=temp;
	delete [] temp;
   
        VSdetach(vdata_id);   
        break;   
      }   
      VSdetach(vdata_id);   
    }   
  }   
  if( !found  && issueWarnings )   
  {   
    cout << "get: ERROR searching for " << (const char *)name << endl;   
  }       
  return found ? 0 : 1;   
}


int HDF_DataBase::   
get( int x[], const aString & name, const int number ) const   
{   
  intSerialArray a;
  int returnValue=get(a,name);
  if( returnValue!=0 )
    return -1;

  int num=a.getLength(0);
  num= num <= number ? num : number;
  for( int i=0; i<num; i++ )
    x[i]=a(i);

  return num;
}
int HDF_DataBase::   
get( float x[], const aString & name, const int number ) const   
{   
  floatSerialArray a;
  int returnValue=get(a,name);
  if( returnValue!=0 )
    return -1;

  int num=a.getLength(0);
  num= num <= number ? num : number;
  for( int i=0; i<num; i++ )
    x[i]=a(i);

  return num;
}
int HDF_DataBase::   
get( double x[], const aString & name, const int number ) const   
{   
  doubleSerialArray a;
  int returnValue=get(a,name);
  if( returnValue!=0 )
    return -1;

  int num=a.getLength(0);
  num= num <= number ? num : number;
  for( int i=0; i<num; i++ )
    x[i]=a(i);

  return num;
}

// get an array of Strings
// get at most numberOfStrings elements in the array.
// return the number of strings actually saved in the array
int HDF_DataBase::   
get( aString x[], const aString & name, const int numberOfStrings ) const   
{   
  assert(rcData!=NULL);
  if( file_id<=0 || sd_id<=0 ) 
  {
    printf("HDF_DataBase::get(aString[],name):ERROR: file_id=%i and sd_id=%i when attempting to put name=%s\n",
        file_id,sd_id,(const char*)name);
    assert( file_id > 0 && sd_id > 0 );  
  }
  if( mode==streamInputMode )
  {
    int numberSaved=0;
    dataBaseBuffer->getFromBuffer( 1,&numberSaved );   // get number of strings in array
    if( numberSaved>numberOfStrings )
      numberSaved=numberOfStrings;
    for( int i=0; i<numberSaved; i++ )
      get( x[i],"dummy");
    return numberSaved;
  }
  if( dataBaseBuffer!=NULL && (mode==normalMode || mode==noStreamMode) )
    closeStream();    /* flush any stream buffers */ 
  /* get the total number of tag/reference pairs in the vgroup  */  
  int npairs = Vntagrefs(rcData->vgroup_id);   
  int32 vdata_tag, vdata_ref;   
  char vdata_name[VSNAMELENMAX];   
  int found=FALSE;   
  int numberSaved=0;
  int i;
  for( i=0; i<npairs; i++ )   
  {   
    /* get tag and ref  */  
    int status = Vgettagref(rcData->vgroup_id, i, &vdata_tag, &vdata_ref );   
    if( debug & 2 )   
      printf(" get: i=%i, tag=%i, ref=%i\n", i,vdata_tag,vdata_ref);   
    if( Visvs(rcData->vgroup_id,vdata_ref) )   
    { /* this is a vdata  */  
      /* get identifier for vdata   */ 
      int32 vdata_id=VSattach(file_id,vdata_ref,(accessMode==read ? "r" : "w"));   
      /* get name of the vdata   */ 
      VSgetname(vdata_id,vdata_name);   
      if( debug & 2 )   
        printf(" get: vdata_name = %s\n",vdata_name);   
      if( name==vdata_name )   
      {   
        if( debug & 2 )   
	  cout << "get: item found! \n";   
	found=TRUE;   
	int32 n_records;   
	VSQuerycount( vdata_id, &n_records );   
        if( debug & 2 ) 
  	  printf(" get aString[]: n_records=%i (=number of chars) max numberOfStrings=%i\n",n_records,
                  numberOfStrings);   
        char * temp = new char[n_records];
	VSread(vdata_id, (unsigned char*)temp, n_records, FULL_INTERLACE );   
        // split temp in different strings (separated by '\0')
        int j=0;
        for( numberSaved=0; numberSaved<numberOfStrings && j<n_records; numberSaved++)
	{
          if( debug & 2 ) cout << "char[" << j << "]=[" << temp[j] << "]\n";
	  x[numberSaved]=&temp[j];
          for( ; temp[j]!='\0' && j<n_records; j++ )  
	  {
          if( debug & 2 ) cout << "char[" << j << "]=[" << temp[j] << "]\n";
	  }
          j++;
	}
	delete [] temp;
        VSdetach(vdata_id);   
        break;   
      }   
      VSdetach(vdata_id);   
    }   
  }   
  if( !found )   
  {   
    cout << "get aString[]: ERROR searching for " << (const char *)name << endl;   
    return -1;
  }       
  return numberSaved;   
}



void  HDF_DataBase::
printStatistics() const 
// output statistics on the file such as number of vgroups, vdatas
{

  int numberOfVgroups = Hnumber(file_id,DFTAG_VG);
  int numberOfVDatas  = Hnumber(file_id,DFTAG_VS);
  int numberOfSDs     = Hnumber(file_id,DFTAG_SD);
  int numberOfSDGs    = Hnumber(file_id,DFTAG_SDG);
  int numberOfObjects  = Hnumber(file_id,DFTAG_WILDCARD);
  
  printf("HDF_DataBase:: There are %i vgroups, %i vdatas %i sds %i sdgs and %i objects in the file \n",
       numberOfVgroups,numberOfVDatas,numberOfSDs,numberOfSDGs,numberOfObjects);
}

#endif
